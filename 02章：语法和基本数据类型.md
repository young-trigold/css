**目录：**

- [2. 语法和基本数据类型](#2-语法和基本数据类型)
  - [2.1. 语法](#21-语法)
    - [2.1.1. 符号化](#211-符号化)
    - [2.1.2. 关键字](#212-关键字)
      - [2.1.2.1. 厂商前缀](#2121-厂商前缀)
    - [2.1.3. 字符和大小写](#213-字符和大小写)
  - [2.2. 语句](#22-语句)
  - [2.3. at 规则](#23-at-规则)
    - [2.3.1. 块](#231-块)
    - [2.3.2. 规则集，声明块和选择器](#232-规则集声明块和选择器)
    - [2.3.3. 声明和属性](#233-声明和属性)
    - [2.3.4. 注释](#234-注释)
  - [2.4. 值和单位](#24-值和单位)
    - [2.4.1. 值定义语法](#241-值定义语法)
      - [2.4.1.1. 组件值类型](#2411-组件值类型)
      - [2.4.1.2. 组件值组合符](#2412-组件值组合符)
      - [2.4.1.3. 组件值重复符](#2413-组件值重复符)
      - [2.4.1.4. 组合符和重复符模式](#2414-组合符和重复符模式)
      - [2.4.1.5. 组件值和空白](#2415-组件值和空白)
      - [2.4.1.6. 属性值例子](#2416-属性值例子)
    - [2.4.2. 文本数据类型](#242-文本数据类型)
      - [2.4.2.1. 预定义关键字](#2421-预定义关键字)
      - [2.4.2.2. 作者定义标识符：`<custom-ident>` 类型](#2422-作者定义标识符custom-ident-类型)
      - [2.4.2.3. 带引号的字符串：`<string>` 类型](#2423-带引号的字符串string-类型)
      - [2.4.2.4. 资源定位符：`<url>` 类型](#2424-资源定位符url-类型)
    - [2.4.3. 数字数据类型](#243-数字数据类型)
      - [2.4.3.1. 范围限制和范围定义记法](#2431-范围限制和范围定义记法)
      - [2.4.3.2. 整数：`<integer>` 类型](#2432-整数integer-类型)
      - [2.4.3.3. 实数：`<number>` 类型](#2433-实数number-类型)
      - [2.4.3.4. 带有单位的数字：尺寸值](#2434-带有单位的数字尺寸值)
    - [2.4.4. 百分数：`<percentage>` 类型](#244-百分数percentage-类型)
    - [2.4.5. 混合百分数和尺寸](#245-混合百分数和尺寸)
    - [2.4.6. 距离单位](#246-距离单位)
      - [2.4.6.1. 相对长度](#2461-相对长度)
      - [2.4.6.2. 绝对长度：cm, mm, Q, in, pt, pc, px 单位](#2462-绝对长度cm-mm-q-in-pt-pc-px-单位)
    - [2.4.7. 其他量](#247-其他量)
      - [2.4.7.1. 角度单位：`<angle>` 类型以及 deg, grad, read, turn 单位](#2471-角度单位angle-类型以及-deg-grad-read-turn-单位)
      - [2.4.7.2. 时长单位：`<time>` 类型以及 s, ms 单位](#2472-时长单位time-类型以及-s-ms-单位)
      - [2.4.7.3. 频率单位：`<frequency>` 类型以及 Hz, kHz 单位](#2473-频率单位frequency-类型以及-hz-khz-单位)
      - [2.4.7.4. 分辨率单位：`<resolution>` 类型以及 dpi, dpcm, dppx 单位](#2474-分辨率单位resolution-类型以及-dpi-dpcm-dppx-单位)
    - [2.4.8. 定义在其他地方的数据类型](#248-定义在其他地方的数据类型)
      - [2.4.8.1. 颜色：`<color>` 类型](#2481-颜色color-类型)
      - [2.4.8.2. 图像：`<image>` 类型](#2482-图像image-类型)
      - [2.4.8.3. 2D 位置：`<position>` 类型](#2483-2d-位置position-类型)
    - [2.4.9. 函数记法](#249-函数记法)
      - [2.4.9.1. 数学表达式：cal()](#2491-数学表达式cal)
    - [2.4.10. 属性引用：attr()](#2410-属性引用attr)

# 2. 语法和基本数据类型

## 2.1. 语法

本节描述了任何级别的 CSS（包括 CSS 2.2）所共有的语法（以及向前兼容的解析规则）。未来的 CSS 更新将遵守这一核心语法，尽管它们可能会增加额外的语法约束。

这些描述是规范性的。

在本规范中，"紧接在前" 或 "紧接在后" 的表述是指没有中间的空白或注释。

### 2.1.1. 符号化

所有级别的 CSS--level 1、level 2 和任何未来的级别--都使用相同的核心语法。这使得用户代理能够解析（尽管不能完全理解）用 CSS 级别编写的样式表，而这些级别在用户代理创建时还不存在。设计师可以利用这一特点来创建适用于较早的用户代理的样式表，同时也可以利用最新级别的 CSS 的可能性。

在词法层面上，CSS 样式表由一连串的词法单元组成。CSS 的词法单元列表如下。这些定义使用 Lex 风格的正则表达式。八进制代码参考了 ISO 10646（[ISO10646]）。和 Lex 一样，在有多个匹配的情况下，最长的匹配决定了标记。

| 词法单元      | 定义                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------ | ---------------------- | ---------------------- | ---------------------- | ---------------------- | -------------- | ------------------------------- |
| IDENT         | `{ident}`                                                    |
| ATKEYWORD     | `@{ident}`                                                   |
| STRING        | `{string}`                                                   |
| BAD_STRING    | `{badstring}`                                                |
| BAD_URI       | `{baduri}`                                                   |
| BAD_COMMENT   | `{badcomment}`                                               |
| HASH          | `#{name}`                                                    |
| NUMBER        | `{num}`                                                      |
| PERCENTAGE    | `{num}%`                                                     |
| DIMENSION     | `{num}{ident}`                                               |
| URI           | `{U}{R}{L}\({w}{string}{w}\)                                 | {U}{R}{L}\({w}([!#$%&*-\[\]-~] | {nonascii}             | {escape})\*{w}\)`      |
| UNICODE-RANGE | `u\+[?]{1,6}                                                 | u\+[0-9a-f]{1}[?]{0,5}         | u\+[0-9a-f]{2}[?]{0,4} | u\+[0-9a-f]{3}[?]{0,3} | u\+[0-9a-f]{4}[?]{0,2} | u\+[0-9a-f]{5}[?]{0,1} | u\+[0-9a-f]{6} | u\+[0-9a-f]{1,6}-[0-9a-f]{1,6}` |
| CDO           | `<!--`                                                       |
| CDC           | `-->`                                                        |
| :             | `:`                                                          |
| ;             | `;`                                                          |
| {             | `\{`                                                         |
| }             | `\}`                                                         |
| (             | `\(`                                                         |
| )             | `\)`                                                         |
| [             | `\[`                                                         |
| ]             | `\]`                                                         |
| S             | `[ \t\r\n\f]+`                                               |
| COMMENT       | `\/\*[^*]*\*+([^/*][^*]*\*+)*\/`                             |
| FUNCTION      | `{ident}\(`                                                  |
| INCLUDES      | `~=`                                                         |
| DASHMATCH     | `                                                            | =`                             |
| DELIM         | 任何未被上述规则匹配的其他字符，并且既不是单引号也不是双引号 |

上面大括号（{}）中的宏定义如下:

| 宏          | 定义                           |
| ----------- | ------------------------------ | -------------------------------- | --------------- | ------------- | ---- |
| ident       | `[-]?{nmstart}{nmchar}*`       |
| name        | `{nmchar}+`                    |
| nmstart     | `[_a-z]                        | {nonascii}                       | {escape}`       |
| nonascii    | `[^\0-\177]`                   |
| unicode     | `\\[0-9a-f]{1,6}(\r\n          | [ \n\r\t\f])?`                   |
| escape      | `{unicode}                     | \\[^\n\r\f0-9a-f]`               |
| nmchar      | `[_a-z0-9-]                    | {nonascii}                       | {escape}`       |
| num         | `[+-]?([0-9]+                  | [0-9]\*\.[0-9]+)(e[+-]?[0-9]+)?` |
| string      | `{string1}                     | {string2}`                       |
| string1     | `\"([^\n\r\f\\"]               | \\{nl}                           | {escape})\*\"`  |
| string2     | `\'([^\n\r\f\\']               | \\{nl}                           | {escape})\*\'`  |
| badstring   | `{badstring1}                  | {badstring2}`                    |
| badstring1  | `\"([^\n\r\f\\"]               | \\{nl}                           | {escape})\*\\?` |
| badstring2  | `\'([^\n\r\f\\']               | \\{nl}                           | {escape})\*\\?` |
| badcomment  | `{badcomment1}                 | {badcomment2}`                   |
| badcomment1 | `\/\*[^*]*\*+([^/*][^*]*\*+)*` |
| badcomment2 | `\/\*[^*]*(\*+[^/*][^*]*)*`    |
| baduri      | `{baduri1}                     | {baduri2}                        | {baduri3}`      |
| baduri1     | `{U}{R}{L}\({w}([!#$%&*-~]     | {nonascii}                       | {escape})\*{w}` |
| baduri2     | `{U}{R}{L}\({w}{string}{w}`    |
| baduri3     | `{U}{R}{L}\({w}{badstring}`    |
| nl          | `\n                            | \r\n                             | \r              | \f`           |
| w           | `[ \t\r\n\f]*`                 |
| L           | `l                             | \\0{0,4}(4c                      | 6c)(\r\n        | [ \t\r\n\f])? | \\l` |
| R           | `r                             | \\0{0,4}(52                      | 72)(\r\n        | [ \t\r\n\f])? | \\r` |
| U           | `u                             | \\0{0,4}(55                      | 75)(\r\n        | [ \t\r\n\f])? | \\u` |

例如，最长匹配规则意味着 "red-->"被标记为 IDENT "red--"后面是 DELIM">"，而不是 IDENT 后面是 CDC。

下面是 CSS 的核心语法。接下来的章节描述了如何使用它。附录 G 描述了一个更严格的语法，它更接近于 CSS 2 级语言。样式表中可以根据这个语法解析的部分，但不能根据附录 G 中的语法解析的部分，根据处理解析错误的规则，将被忽略。

| 语法单元 | 定义                             |
| -------- | -------------------------------- | ---------------- | ----------------- | ------------------ | -------- | ----- | --- | ---- | ------------- | -------- | --------- | --- | ----------------- | ------------- | ------------ | ------------- | ------------ | ----------------- |
| 样式表   | `[ CDO                           | CDC              | S                 | 语句 ]\*`          |
| 语句     | `规则集                          | at 规则`         |
| at 规则  | `ATKEYWORD S* any* [ 块          | ';' S\* ]`       |
| 块       | `'{' S\* [ any                   | 块               | ATKEYWORD S\*     | ';' S* ]* '}' S\*` |
| 规则集   | `选择器? '{' S* 声明列表 '}' S*` |
| 声明列表 | `声明 [ ';' S* 声明列表 ]?       | at 规则 声明列表 | /_ empty _/`      |
| 选择器   |                                  | `any+`           |
| 声明     | `属性 S* ':' S* 值`              |
| 属性     | `IDENT`                          |
| 值       | `[ any                           | 块               | ATKEYWORD S\* ]+` |
| any      | `[ IDENT                         | NUMBER           | PERCENTAGE        | DIMENSION          | STRING   | DELIM | URI | HASH | UNICODE-RANGE | INCLUDES | DASHMATCH | ':' | FUNCTION S\* [any | unused]\* ')' | '(' S\* [any | unused]\* ')' | '[' S\* [any | unused]_ ']'] S_` |
| unused   | `块                              | ATKEYWORD S\*    | ';' S\*           | CDO S\*            | CDC S\*` |

在 CSS 中没有使用 "unused" 语法产生式，将来也不会被任何扩展使用。它被包括在这里只是为了帮助处理错误。

COMMENT（注释）标记没有出现在语法中（以保持其可读性），但是任何数量的这些标记都可以出现在其他标记之外的任何地方。（但是请注意，在@charset 规则之前或之内的注释会禁用@charset）。

上述语法中的标记 S 代表空白。只有 "空格"（U+0020）、"制表"（U+0009）、"换行"（U+000A）、"回车"（U+000D）和 "换页"（U+000C）这些字符可以出现在空白处。其他类似空间的字符，如 "em-space"（U+2003）和 "ideographic space"（U+3000），从来不是空白空间的一部分。

在 CSS 2.2 中没有定义不能被此法单元或解析的输入的含义。

### 2.1.2. 关键字

关键词具有标识符的形式。关键词不能放在引号（"... "或'...'）之间。因此。

red 是一个关键词，但 "red"不是。(它是一个字符串。) 其他非法的例子：

```css
width: 'auto';
border: 'none';
background: 'red';
```

#### 2.1.2.1. 厂商前缀

在 CSS 中，标识符可以以'-'（破折号）或 '\_'（下划线）开头。以'-'或 '\_' 开头的关键词和属性名称被保留给厂商特定的扩展。这种厂商特定的扩展应该有以下格式之一：

```
'-' + 厂商标识符 + '-' + 有意义的名称
'_' + 厂商标识符 + '-' + 有意义的名称
```

例如，如果 XYZ 组织添加了一个属性来描述显示器东侧边框的颜色，他们可能称之为 -xyz-border-east-color。

其他已知的例子：

```css
-moz-box-sizing
-moz-border-radius
-wap-accesskey
```

首字母破折号或下划线被保证永远不会被任何当前或未来级别的 CSS 使用在属性或关键字中。因此，典型的 CSS 实现可能无法识别这样的属性，并可能根据处理解析错误的规则而忽略它们。然而，由于最初的破折号或下划线是语法的一部分，CSS 2.2 的实现者应该总是能够使用符合 CSS 标准的解析器，无论他们是否支持任何厂商的特定扩展。

作者应该避免厂商的特定扩展。

下表总结了常见的厂商前缀。

| 浏览器            | 前缀     |
| ----------------- | -------- |
| Chrome, Safari    | -webkit- |
| Opera             | -o-      |
| Firefox           | -moz-    |
| Internet Explorer | -ms-     |

### 2.1.3. 字符和大小写

以下规则始终有效。

所有的 CSS 语法在 ASCII 范围内是不区分大小写的（即[a-z]和[A-Z]是等同的），但不在 CSS 控制范围内的部分除外。例如，HTML 属性 "id "和 "class "的值、字体名称和 URI 的大小写敏感性不在本规范的范围之内。特别要注意的是，元素名称在 HTML 中是不区分大小写的，但在 XML 中是区分大小写的。

在 CSS 中，标识符（包括选择器中的元素名、类和 ID）只能包含字符[a-zA-Z0-9]和 ISO 10646 字符 U+0080 及以上，加上连字符（-）和下划线（\_）；它们不能以数字、两个连字符或连字符后的数字开头。标识符也可以包含转义字符和任何作为数字代码的 ISO 10646 字符（见下一项）。例如，标识符 "B&W？"可以写成 "B\&W\？"或 "B\26 W\3F"。
请注意，Unicode 的编码与 ISO10646 相当（见[UNICODE]和[ISO10646]）。

在 CSS 2.2 中，反斜杠（\）字符可以表示三种类型的字符转义之一。在一个 CSS 注释中，反斜杠代表它自己，如果反斜杠紧跟在样式表的末尾，它也代表它自己（即 DELIM 标记）。

首先，在一个字符串内，一个反斜杠后面的换行被忽略（即，字符串被认为不包含反斜杠或换行）。在字符串外部，反斜线后的换行代表其本身（即 DELIM 后的换行）。

第二，它取消了特殊 CSS 字符的意义。任何字符（除了十六进制数字、换行、回车或换页）都可以用反斜杠转义，以消除其特殊含义。例如，"\"是一个由一个双引号组成的字符串。样式表预处理器不能从样式表中删除这些反斜线，因为那会改变样式表的含义。

第三，反斜杠转义允许作者参考他们不容易放在文档中的字符。在这种情况下，反斜杠后面最多有六个十六进制数字（0...9A...F），这些数字代表 ISO 10646（[ISO10646]）字符，这个数字不能是零。(在 CSS 2.2 中没有定义如果一个样式表确实包含一个 Unicode 代码点为 0 的字符会发生什么。) 如果在十六进制数字后面有一个范围为[0-9a-fA-F]的字符，那么这个数字的结尾需要明确。有两种方法可以做到这一点。

用一个空格（或其他空白字符）。"\26 b"（"&b"）。在这种情况下，用户代理应将 "CR/LF "对（U+000D/U+000A）视为一个白色空格字符。

通过提供正好 6 个十六进制数字。"\000026b" ("&b")。

事实上，这两种方法可以结合使用。在十六进制转义之后，只有一个空白字符被忽略。请注意，这意味着转义序列后的 "真实 "空格必须是双倍的。

如果数字超出了 Unicode 允许的范围（例如"\110000 "高于当前 Unicode 允许的最大 10FFFF），UA 可以用 "替换字符"（U+FFFD）替换转义。如果要显示该字符，UA 应该显示一个可见的符号，比如 "缺失字符 "字形（参见 15.2，第 5 点）。

注意：反斜线转义总是被认为是标识符或字符串的一部分（即"\7B" 不是标点符号，尽管 "{" 是，而"\32" 允许放在类名的开头，尽管 "2" 不是）。

标识符 "te/st "与 "test "是完全相同的标识符。

## 2.2. 语句

一个 CSS 样式表，对于任何级别的 CSS 来说，都是由一个语句列表组成的（见上面的语法）。有两种声明：at-rules 和规则集。语句周围可能有空白。

## 2.3. at 规则

at 规则的开头是一个'@'字符，后面紧跟一个标识符（例如，'@import'，'@page'）。

一个 at 规则由包括下一个分号（;）或下一个块（以先到者为准）在内的所有内容组成。

CSS 2.2 的用户代理必须忽略任何出现在块内的'@import'规则，或者出现在任何非忽略的语句（除@charset 或@import 规则外）之后。

例如，假设一个 CSS 2.2 解析器遇到了这个样式表：

```css
@import 'subs.css';
h1 {
  color: blue;
}
@import 'list.css';
```

根据 CSS 2.2，第二个'@import'是非法的。CSS 2.2 解析器忽略了整个 at 规则，有效地将样式表简化为：

```css
@import 'subs.css';
h1 {
  color: blue;
}
```

在下面的例子中，第二个"@import" 规则是无效的，因为它发生在 "@media" 块内:

```css
@import 'subs.css';
@media print {
  @import 'print-main.css';
  body {
    font-size: 10pt;
  }
}
h1 {
  color: blue;
}
```

相反，为了达到只为 "print" 媒体导入样式表的效果，使用带有媒体语法的@import 规则，例如：

```css
@import 'subs.css';
@import 'print-main.css' print;
@media print {
  body {
    font-size: 10pt;
  }
}
h1 {
  color: blue;
}
```

### 2.3.1. 块

一个块以左大括号（{）开始，以匹配的右大括号（}）结束。中间可以有任何标记，但小括号（（））、大括号（[ ]）和大括号（{ }）必须总是成对出现，并且可以嵌套。单引号（'）和双引号（"）也必须出现在匹配对中，它们之间的字符被解析为一个字符串。关于字符串的定义，见上面的符号化。

下面是一个块的例子。请注意，双引号之间的右括号与块的开头括号不一致，第二个单引号是一个转义字符，因此与第一个单引号不一致:

```css
 {
  causta: '}' + ({7} * "'");
}
```

请注意，上述规则不是有效的 CSS 2.2，但它仍然是上述定义的一个块。

### 2.3.2. 规则集，声明块和选择器

一个规则集（也叫 "规则"）由一个选择器和一个声明块组成。

一个声明块以左大括号（{）开始，以匹配的右大括号（}）结束。在这中间必须有一个零或更多的声明和 at 规则的列表。声明必须以分号（;）结束，除非它们是列表中的最后一个。

注意：CSS level 2 没有可能出现在规则集内的 at 规则，但这种 at 规则可能会在未来的级别中被定义。

选择器（参见选择器一节）由第一个左大括号（{）以下的所有内容组成（但不包括）。一个选择器总是和一个声明块一起出现。当用户代理不能解析选择器时（即它不是有效的 CSS 2.2），它必须忽略选择器和后面的声明块（如果有的话）。

CSS 2.2 对选择器中的逗号（,）赋予了特殊的含义。然而，由于不知道逗号在未来的 CSS 更新中是否会获得其他含义，如果选择器中的任何地方有错误，整个声明都应该被忽略，即使选择器的其他部分在 CSS 2.2 中看起来是合理的。

例如，由于"&"在 CSS 2.2 的选择器中不是一个有效的标记，所以 CSS 2.2 的用户代理必须忽略整个第二行，并且不能将 h3 的颜色设置为红色：

```css
h1,
h2 {
  color: green;
}
h3,
h4 & h5 {
  color: red;
}
h6 {
  color: black;
}
```

下面是一个更复杂的例子。前两对大括号在一个字符串内，并没有标记选择器的结束。这是一个有效的 CSS 2.2 规则:

```css
p[example='public class foo\
{\
    private int x;\
\
    foo(int x) {\
        this.x = x;\
    }\
\
}'] {
  color: red;
}
```

### 2.3.3. 声明和属性

一个声明要么是空的，要么是由一个属性名称组成，后面是冒号（:），然后是一个属性值。在每个属性的周围可能有空白。

由于选择器的工作方式，同一选择器的多个声明可以被组织成分号（;）分隔的组。

因此，以下规则：

```css
h1 {
  font-weight: bold;
}
h1 {
  font-size: 12px;
}
h1 {
  line-height: 14px;
}
h1 {
  font-family: Helvetica;
}
h1 {
  font-variant: normal;
}
h1 {
  font-style: normal;
}
```

相当于：

```css
h1 {
  font-weight: bold;
  font-size: 12px;
  line-height: 14px;
  font-family: Helvetica;
  font-variant: normal;
  font-style: normal;
}
```

一个属性名称是一个标识符。任何标记都可以出现在属性值中。小括号（"()"）、中括号（"[ ]"）、大括号（"{ }"）、单引号（'）和双引号（"）必须成对出现，而且不在字符串中的分号必须被转义。括号、大括号和小括号可以嵌套。在引号内，字符被解析为一个字符串。

值的语法是为每个属性单独指定的，但在任何情况下，值都是由标识符、字符串、数字、长度、百分数、URI、颜色等构建的。

用户代理必须忽略具有无效的属性名称或无效的值的声明。每个 CSS 属性对它所接受的值都有自己的语法和语义限制。

例如，假设一个 CSS 2.2 解析器遇到了这个样式表：

```css
h1 {
  color: red;
  font-style: 12pt;
} /* 无效值: 12pt */
p {
  color: blue;
  font-vendor: any; /* 无效属性.: font-vendor */
  font-variant: small-caps;
}
em em {
  font-style: normal;
}
```

第一行的第二个声明有一个无效的值 "12pt"。第二行的第二个声明包含一个未定义的属性 "font-vendor"。CSS 2.2 解析器将忽略这些声明，有效地将样式表简化为：

```css
h1 {
  color: red;
}
p {
  color: blue;
  font-variant: small-caps;
}
em em {
  font-style: normal;
}
```

### 2.3.4. 注释

注释以字符 "/\*" 开始，以字符 "\*/" 结束。它们可以出现在其他标记之外的任何地方，其内容对渲染没有影响。注释不能被嵌套。

CSS 也允许在语法定义的某些地方使用 SGML 注释定界符（"<！--"和"-->"），但它们并不能给 CSS 注释定界。允许它们是为了使出现在 HTML 源文档中的样式规则（在 STYLE 元素中）可以从 HTML 3.2 之前的用户代理那里隐藏起来。

## 2.4. 值和单位

每个 CSS 属性的值定义字段可以包含关键字、数据类型（出现在<和>之间），以及关于它们如何被组合的信息。本规范中描述了许多属性可以使用的通用数据类型（`<length>`是最广泛使用的），而更具体的数据类型（例如，`<spacing-limit>`）则在相应的模块中描述。

注意：本章为 [CSS Values and Units Module Level 3](https://www.w3.org/TR/css-values-3/)。

### 2.4.1. 值定义语法

这里描述的 **值定义语法** 是用来定义 CSS 属性的有效值集（以及 CSS 的许多其他部分的有效语法）。一个如此描述的值可以有一个或多个组件。

#### 2.4.1.1. 组件值类型

组件值类型有几种指定方式：

1. 关键词值（如 auto、disc 等），按字面意思出现，不带引号（如 auto）。
2. 基本数据类型，出现在<和>之间（例如，`<length>`，<百分数>，等等）。对于数字数据类型，这种类型符号可以使用下面描述的括号范围符号来注释任何范围限制。
3. 与同名属性具有相同取值范围的类型（例如，`<'border-width>`，`<'background-attachment'>`，等等）。在这种情况下，类型名称是括号内的属性名称（带引号）。这样的类型不包括 CSS 范围内的关键字，如继承，也不包括任何顶层的逗号分隔的列表乘数（即如果属性配对被定义为`[<custom-ident> <integer>?]#`，那么`<'pairing'>`就相当于`[ <custom-ident> <integer>? ]`，而不是`<custom-ident> <integer> ]#`）。
4. 不与属性同名的非终结符。在这种情况下，非终端名称出现在<和>之间，如`<spacing-limit>`。注意`<border-width>`和`<'border-width'>`之间的区别：后者被定义为 border-width 属性的值，前者需要在其他地方明确展开。非终端的定义通常位于其在规范中首次出现的附近。

一些属性值的定义还包括斜线（/）、逗号（,）和/或括号作为字面意义。这些代表他们相应的标记。其他可能出现在组件值中的非关键字字面字符，如 "+"，必须写在单引号内。

**语法中指定的逗号在某些情况下是隐含的**，当用于分隔语法中的可选术语时，是可以省略的。在属性或其他 CSS 值的顶层列表中，或在一个函数的参数列表中，语法中指定的逗号必须被省略，如果。

- 逗号前面的所有项目都被省略了
- 逗号后面的所有项目都被省略了
- 由于逗号之间的项目被省略，多个逗号将是相邻的（忽略空白/注释）。

例如，如果一个函数可以依次接受三个参数，但所有参数都是可选的，那么语法可以这样写:

```css
example( first? , second? , third? )
```

鉴于这种语法，写`example(first, second, third)`是有效的，就像`example(first, second)`或`example(first, third)`或`example(second)`一样。然而，`example(first, , third)`是无效的，因为其中一个逗号不再分隔两个选项；同样，`example(,second)`和`example(first,)`也是无效的。`example(first second)`也是无效的，因为仍然需要逗号来实际分隔选项。

如果逗号不是隐含的可省略的，那么语法就必须复杂得多，才能正确地表达参数可省略的方式，从而大大掩盖了该特性的简单性。

所有的 CSS 属性也接受 CSS 范围内的关键字值作为其属性值的唯一组成部分。为了便于阅读，这些都没有在属性值的语法定义中明确列出。例如，border-color 的完整值定义是`<color>{1,4}`。| 尽管它被列为`<color>{1,4}`）。

注意：这意味着，一般来说，在同一声明中，将这些关键字与其他组件值结合起来，会导致无效的声明。例如，`background: url(corner.png) no-repeat, inherit;` 是无效的。

#### 2.4.1.2. 组件值组合符

组件值可以被放置成如下的属性值：

- 并列的组件意味着所有的组件都必须按照给定的顺序出现。
- 一个双和号（&&）分隔了两个或更多的组件，所有的组件都必须以任何顺序出现。
- 双竖线(||)分隔两个或多个选项：其中一个或多个选项必须以任何顺序出现。
- 一个竖线(||)分隔两个或更多的选项：其中一个必须出现。
- 大括号（[ ]）是用来分组的。

并列式比双和号强，双和号比双竖线强，而双竖线比竖线强。因此，以下几行是等同的：

```
a b | c || d && e f
[ a b ] | [ c || [ d && [ e f ]] ]
```

对于可重新排序的组合器（||，&&），语法的排序并不重要：同一分组中的组件可以按任何顺序交错排列。因此，以下几行是等价的。

```
a || b || a
b || a || c
```

#### 2.4.1.3. 组件值重复符

每个类型、关键词或括号内的组别都可以由以下修饰词跟随：

- 一个星号（\*）表示前面的类型、词或组出现了零次或多次。
- 加号（+）表示前面的类型、词或组出现一次或多次。
- 问号(?)表示前面的类型、词或组是可选的（出现次数为零或一次）。
- 大括号中的单个数字（{A}）表示前面的类型、词或组出现了 A 次。
- 大括号中以逗号隔开的一对数字（{A,B}）表示前面的类型、词或组至少出现 A 次，最多出现 B 次。B 可以省略（{A,}），表示至少要有 A 次的重复，重复的次数没有上限。
- 哈希标记（#）表示前面的类型、词或组出现了一次或多次，由逗号标记隔开（可以选择用空白和/或注释包围）。它后面可以选择使用上面的大括号形式，以精确指示重复出现的次数，如<length>#{1,4}。
- 组后的感叹号（！）表示该组是必需的，必须产生至少一个值；即使该组内的项目的语法允许省略整个内容，也不能省略至少一个组件值。

对于重复的组件值（用\*、+或#表示），UA 必须支持组件的至少 20 次重复。如果一个属性值包含的重复次数超过了支持的次数，那么该声明必须被忽略，就像它是无效的。

#### 2.4.1.4. 组合符和重复符模式

有一小部分常见的方法可以将多个独立的组件值以特定的数字和顺序组合起来。特别是，通常要表达的是，从一组分量值中，作者必须选择零或更多，一个或更多，或所有的分量值，并且以语法中指定的顺序或以任何顺序。

所有这些都可以用组合器和乘法器的简单模式轻松表达：

|            | 按顺序                | 任意顺序 |
| ---------- | --------------------- | -------- | --- | --- | --- | --- |
| 0 个或多个 | `A? B? C?`            | `A?      |     | B?  |     | C?` |
| 1 个或多个 | `[ A? B? C? ]!`       | `A       |     | B   |     | C`  |
| 所有       | `A B C` `A && B && C` |

请注意，所有“任意顺序”的可能性都是用组合符表达的，而“按顺序”的可能性都是并列的变体。

#### 2.4.1.5. 组件值和空白

除非另有规定，空白和/或注释可以出现在使用上述组合符和重复符组合的组件之前、之后和/或之间。

注意：在很多情况下，组件之间实际上需要有空格，以便将它们相互区分开来。例如，数值 1em2em 将被解析为一个带有数字 1 和标识符 em2em 的单一<维度标记>，这是一个无效的单位。在这种情况下，需要在 2 前面加一个空格，以使其被解析为两个长度的 1em 和 2em。

#### 2.4.1.6. 属性值例子

Below are some examples of properties with their corresponding value definition fields

| 属性            | 值定义字段                                     | 例子值                                                            |
| --------------- | ---------------------------------------------- | ----------------------------------------------------------------- | ------------------------------- | ------------ | -------------- | ------------ | --- | ------ | ------------------ |
| orphans         | `<integer>`                                    | 3                                                                 |
| text-align      | `left                                          | right                                                             | center                          | justify`     | center         |
| padding-top     | `<length>                                      | <percentage>`                                                     | 5%                              |
| outline-color   | `<color>                                       | invert`                                                           | #fefefe                         |
| text-decoration | `none                                          | underline                                                         |                                 | overline     |                | line-through |     | blink` | overline underline |
| font-family     | `[ <family-name>                               | <generic-family> ]#`                                              | "Gill Sans", Futura, sans-serif |
| border-width    | `[ <length>                                    | thick                                                             | medium                          | thin ]{1,4}` | 2px medium 4px |
| text-shadow     | `[ inset? && [ <length>{2,4} && <color>? ] ]#` | none 3px 3px rgba(50%, 50%, 50%, 50%), lemonchiffon 0 0 4px inset |

### 2.4.2. 文本数据类型

**文本数据类型** 包括各种关键词和标识符，以及字符串（`<string>`）和 URL（`<url>`）。

CSS **标识符**，一般用`<ident>`表示，由符合`<ident-token>`语法的字符序列组成。[CSS3SYN]标识符不能被加引号；否则它们将被解释为字符串。

#### 2.4.2.1. 预定义关键字

在值定义字段中，具有预定义的关键词按字面意思出现。关键词是 CSS 的标识符，对 ASCII 大小写不敏感（即[a-z]和[A-Z]是等同的）。

例如，下面是 border-collapse 属性的值定义：

```
值: collapse | separate
```

下面是它的一个使用例子:

```
table { border-collapse: separate }
```

**全局关键字： initial, inherit 和 unset**

正如上面所定义的，所有的属性都接受 **全局关键字**，这些关键字可用来表示所有 CSS 属性值。

initial 关键字代表指定为该属性初始值的值。inherit 关键字表示该属性在元素的父级上的计算值。unset 关键字的作用是 inherit 或 initial，取决于该属性是否被继承。所有这些关键字在 Cascade 模块中都有规范性的定义。[CSS3CASCADE]

其他的 CSS 规范可以定义其他的全局关键字。

#### 2.4.2.2. 作者定义标识符：`<custom-ident>` 类型

一些属性接受任意的作者定义的标识符作为组件值。这种通用数据类型由`<custom-ident>`表示，它代表任何有效的 CSS 标识符，不会被误解为该属性的值定义中的预定义关键字。这样的标识符是完全区分大小写的，即使是在 ASCII 范围内（例如，example 和 EXAMPLE 是两个不同的、不相关的用户定义的标识符）。

CSS 范围内的关键字不是有效的`<custom-ident>`。默认关键字是保留的，也不是有效的`<custom-ident>`。使用`<custom-ident>`的规范必须清楚地指定哪些其他关键字被排除在`<custom-ident>`之外（如果有的话）--例如，说该属性的值定义中的任何预定义的关键字被排除。被排除的关键字在所有 ASCII 大小写中都被排除。

当解析属性值中位置不明确的关键字时，`<custom-ident>` 产生式只能在没有其他未完成的产生式可以要求该关键字的情况下要求它。

例如，简写声明 `animation: eas-in eas-out` 等同于冗长声明 `animation-timing-function: eas-in; animation-name: eas-out;`。ease-in 被属于 animation-timing-function 的 `<easing-function>` 产生式所声称，留下 ease-out 被属于 animation-name 的 `<custom-ident>` 产生式声称。

注意：当用`<custom-ident>`设计语法时，`<custom-ident>`应该总是“位置不明确”，这样它就不可能与属性中的任何关键字值冲突。

#### 2.4.2.3. 带引号的字符串：`<string>` 类型

字符串用`<string>`表示，由一串用双引号或单引号限定的字符组成。它们对应于 CSS 语法模块[CSS3SYN]中的`<string-token>`产生式。

双引号不能出现在双引号内，除非转义（如"\"或"\22"）。对于单引号（'\''或'\27'）也是如此。

```
内容: "this is a 'string'.";
内容: "this is a \"string\".;
内容: 'this is a "string".';
内容: This is a \'string\'.";
```

出于审美或其他原因，有可能将字符串分成几行，但在这种情况下，换行本身必须用反斜线（\）来转义。随后，换行符将从字符串中删除。例如，以下两个选择器是完全相同的。

```css
a[title='a 不是一个\
非常长的标题'] {
  /*...*/
}

a[title='一个不太长的标题'] {
  /*...*/
}
```

由于字符串不能直接表示换行，要在字符串中包含换行，请使用转义"\A"。(十六进制的 A 是 Unicode 中的换行字符（U+000A），但在 CSS 中代表 "换行" 的一般概念）。

#### 2.4.2.4. 资源定位符：`<url>` 类型

url() 函数记法，用 `<url>` 表示，代表一个 URL，它是一个指向资源的指针。一个 `<url>` 的典型语法是：`

```
<url> = url( <string> <url-modifier>* )
```

下面是一个使用 URL 作为背景图片的例子:

```css
body {
  background: url('http://www.example.com/pinkish.gif');
}
```

`<url>` 也可以不加引号地写在 URL 本身周围，在这种情况下，它会被特别地解析为一个 `<url-token>` [CSS3SYN]。

例如，下面的声明是相同的：

```css
background: url('http://www.example.com/pinkish.gif');
background: url(http://www.example.com/pinkish.gif);
```

注意：这种不加引号的语法不能接受`<url-modifier>`参数，并且有额外的转义要求：在 URL 中出现的括号、空白字符、单引号（'）和双引号（"）必须用反斜杠转义，例如：`url(open\(parens), url(close\)parens)`。(在带引号的 `<string>` url()中，只有换行符和用于引用字符串的字符需要被转义）。根据 URL 的类型，也可以将这些字符写成 URL 的转义（例如，url(open%28parens)或 url(close%29parens)），如[URL]中所述。

一些 CSS 上下文（比如@import）也允许`<url>`由一个光秃秃的`<string>`表示，没有 url()包装。在这种情况下，字符串的行为与包含该字符串的 url()函数相同。

例如，下面的语句是相同的：

```css
@import url('base-theme.css');
@import 'base-theme.css';
```

1. **相对 URL**

为了创建不依赖于资源绝对位置的模块化样式表，作者应该使用相对 URL。相对的 URL（如[URL]中定义的）使用一个基本的 URL 被解析成完整的 URL。RFC 3986 第 3 节定义了这一过程的规范性算法。对于 CSS 样式表，基本 URL 是样式表本身的 URL，而不是样式化的源文档的 URL。嵌入在文档中的样式表的基本 URL 与它们的容器有关。

当`<url>`出现在一个属性的计算值中时，它被解析为一个绝对的 URL，如前段所述。UA 不能解析为绝对 URL 的 URL 的计算值是指定值。

例如，假设有以下规则：

```css
body {
  background: url('tile.png');
}
```

位于一个由 URL 指定的样式表中: http://www.example.org/style/basic.css。

源文档的`<body>`的背景将用 URL 指定的资源所描述的任何图像来铺设：http://www.example.org/style/tile.png。

无论包含`<body>`的源文档的 URL 是什么，都会使用相同的图像。

2. **片段 URL**

为了解决浏览器 URL 处理中一些常见的偏心问题，CSS 对仅有片段的 URL 有特殊的行为。

如果一个 url()的值以 U+0023 数字符号(#)字符开始，那么就按照正常的 URL 解析，但另外设置 url()的本地 url 标志。

当匹配一个设置了本地 url 标志的 url()时，除了 URL 的片段外，忽略所有的东西，并针对当前文档解析该片段，相对的 URL 是针对该文档解析的。这种引用必须始终被视为同文档（而不是跨文档）。

当序列化一个设置了本地 url 标志的 url()时，它必须只序列化为片段。

3. **空 URL**

如果 url()的值是空字符串（如 url("")或 url()），url 必须解析到一个无效的资源（类似于 url about:invalid 的作用）。

注意：这与网络平台中其他地方的嵌入式资源的空 url 的行为相吻合，并且避免了由于编辑错误而导致 url()值为空，重新请求样式表或主机文档的过多流量，这几乎肯定是 url()显示的无效的资源。网络平台上的链接确实允许空的 url，所以如果/当 CSS 获得一些控制超链接的功能时，在这些情况下可以放松这一限制。

4. **URL 修饰符**

url()函数支持指定额外的`<url-modifier>`，它以某种方式改变了 URL 的含义或解释。一个`<url-modifier>`可以是一个`<ident>`或者一个功能符号。

本规范没有定义任何`<url-modifier>`，但是其他规范可能会这样做。

注意：一个没有引号或者没有用 url()符号包装的`<url>`不能接受任何`<url-modifier>`。

### 2.4.3. 数字数据类型

数字数据类型包括`<integer>`, `<number>`, `<percentage>`, 以及各种维度，包括`<length>`, `<angle>`, `<time>`, `<frequency>`, 和`<resolution>`。

注意：虽然这里定义了通用的尺寸，但其他一些模块定义了额外的数据类型（例如，[css-grid-1]引入了 fr 单位），其用法更加本地化。

#### 2.4.3.1. 范围限制和范围定义记法

属性可以将数字值限制在某个范围内。如果数值超出了允许的范围，那么除非另有规定，否则该声明是无效的，必须被忽略。范围限制可以在数字类型符号中使用 CSS 括号内的范围符号--[min,max]--在角括号内，在识别关键字之后，表示 min 和 max 之间（并包括）的封闭范围。例如，`<integer [0, 10]>` 表示 0 到 10 之间的整数，包括在内。

注意：CSS 值通常不允许开放范围；因此只使用方括号符号。

CSS 理论上支持所有数值类型的无限精度和无限范围；但是在现实中，实现的能力是有限的。UA 应该支持合理有用的范围和精度。理想情况下，范围的极值是无限的，并根据情况使用 ∞ 或-∞ 表示。

如果没有指明范围，无论是通过使用括号内的范围符号还是在属性描述中，那么就假定`[-∞,∞]`。

注意：在撰写本文时，括号内的范围符号是新的；因此在大多数 CSS 规范中，任何范围限制都只用散文描述。(例如，"不允许使用负值" 或 "负值无效"表示`[0,∞]`范围）。这并没有使它们的约束力降低。

#### 2.4.3.2. 整数：`<integer>` 类型

整数值用`<integer>`来表示。

当按字面意思书写时，整数是一个或多个十进制数字 0 到 9，并对应于 CSS 语法模块[CSS3SYN]中的`<number-token>`产生式的一个子集。整数的第一个数字可以紧接着用-或+来表示整数的符号。

#### 2.4.3.3. 实数：`<number>` 类型

数值用`<number>`表示，并代表实数，可能还有小数部分。

当按字面意思书写时，数字要么是一个整数，要么是 0 个或多个小数位，后面是一个点（.），后面是一个或多个小数位，还有一个由 "e" 或 "E" 和一个整数组成的指数。它对应于 CSS 语法模块[CSS3SYN]中的`<number-token>`产生式。与整数一样，数字的第一个字符可以紧接着用"-"或 "+"来表示该数字的符号。

#### 2.4.3.4. 带有单位的数字：尺寸值

一般来说，尺寸是指带有单位的数字；并以`<dimension>`表示。

从字面上看，尺寸是一个数字，后面紧跟着一个单位标识符，这是一个标识符。它对应于 CSS 语法模块[CSS3SYN]中的`<dimension-token>`产生式。像关键字一样，单位标识符是不区分 ASCII 大小写的。

CSS 使用`<dimension>`来指定距离（`<length>`）、持续时间（`<time>`）、频率（`<frequency>`）、分辨率（`<resolution>`）和其他数量。

**兼容性单位**

当序列化计算值[CSSOM]时，兼容的单位（那些由静态乘法因子关联的单位，比如 px 和 in 之间的 96:1 因子，或者 em 和 px 之间的计算字体大小因子）被转换为一个单一的规范单位。每一组兼容单位都定义了其中哪一个是将被用于序列化的规范单位。

当序列化作为使用值的解析值时，所有表示长度的值类型（百分数、数字、关键字等）都被认为与长度兼容。同样地，任何未来返回使用过的值的 API 必须考虑任何代表距离/长度/频率/等的值与相关的尺寸类别兼容，并相应地进行规范化。

### 2.4.4. 百分数：`<percentage>` 类型

百分数用`<percentage>`表示，表示一个值是另一个参考值的某个分数。

当按字面意思书写时，百分数由一个数字紧跟一个百分号%组成。它对应于 CSS 语法模块[CSS3SYN]中的`<percentage-token>`产生式。

百分数总是相对于另一个数量，例如长度。每个允许百分数的属性也定义了百分数所指向的数量。这个数量可以是同一元素的另一个属性的值，也可以是一个祖先元素的属性的值，还可以是格式化上下文的测量值（例如，包含块的宽度），或者其他东西。

### 2.4.5. 混合百分数和尺寸

如果`<percentage>`可以与相同分量值位置的尺寸或数字代表相同的数量，因此可以在 calc()表达式中与它们结合，那么在属性语法中可以使用以下方便的符号：

`<length-percentage>`
相当于`[ <length> | <percentage> ]`，其中的`<percentage>`将解析为`<length>`。

`<frequency-percentage>`
相当于`[ <frequency> | <percentage> ]`，其中`<percentage>`将被解析为`<frequency>`。

`<angle-percentage>`
等同于`[ <angle> | <percentage> ]`，其中`<percentage>`将解析为`<angle>`。

`<time-percentage>`
相当于`[ <time> | <percentage> ]`，其中`<percentage>`将解析为`<time>`。

`<number-percentage>`
相当于`[ <number> | <percentage> ]`，其中`<percentage>`将被解析为`<number>`。

例如，width 属性可以接受`<length>`或`<percentage>`，两者都代表距离的量度。这意味着`width: calc(500px + 50%);`是允许的--这两个值都被转换为绝对长度并加在一起。如果包含的块是 1000px 宽，那么`width: 50%;`就相当于`width: 500px`，而`width: calc(50% + 500px)`因此最终相当于`width: calc(500px + 500px)`或`width: 1000px`。
另一方面，hsl()函数的第二个和第三个参数只能用`<percentage>`来表示。虽然允许在它们的位置上使用 calc()产生式，但它们只能将百分数与自己结合起来，如`calc(10% + 20%)`。

注意：规范不应该用`<percentage>`来代替语法中的尺寸，除非它们是兼容的。

### 2.4.6. 距离单位

长度指的是距离测量，在属性定义中用`<length>`来表示。一个长度是一个维度。

对于零长度来说，单位标识符是可选的（也就是说，可以在语法上表示为`<number>` 0）。然而，如果 0 可以被解析为属性中的`<number>`或`<length>`（例如 line-height），它必须被解析为`<number>`。

属性可以将长度值限制在某个范围内。如果该值超出了允许的范围，该声明是无效的，必须被忽略。

虽然有些属性允许负的长度值，但这可能会使格式化复杂化，而且可能有特定的实现限制。如果允许负的长度值但不能支持，那么必须把它转换为可以支持的最近的值。

在使用的长度不能被支持的情况下，用户代理必须在实际值中对其进行近似。

有两种类型的长度单位：相对和绝对。

#### 2.4.6.1. 相对长度

**相对长度单位** 指定一个相对于另一个长度的长度。使用相对单位的样式表可以更容易地从一个输出环境扩展到另一个。

相对单位是：

| 单位 | 相对于                                   |
| ---- | ---------------------------------------- |
| em   | 元素的字体大小                           |
| ex   | 元素字体的 x-高度                        |
| ch   | 元素字体中 "0"（ZERO，U+0030）字样的宽度 |
| rem  | 根元素的字体大小                         |
| vw   | 为视口宽度的 1%                          |
| vh   | 为视窗高度的 1%                          |
| vmin | 视口小尺寸的 1%                          |
| vmax | 视口较大尺寸的 1%                        |

子元素不继承为其父元素指定的相对值；它们继承的是计算值。

1. **字体相关长度：em, ex, ch, rem 单位**

**字体相关长度** 指的是它们所使用的元素的字体度量，或者，在 rem 的情况下，指的是根元素的度量）。

- **em 单位**

等于它所使用的元素的 'font-size' 属性的计算值。

规则:

```css
h1 {
  line-height: 1.2em;
}
```

表示 h1 元素的行高将比 h1 元素的字体大小大 20%。另一方面：

```css
h1 {
  font-size: 1.2em;
}
```

表示 h1 元素的字体大小将比 h1 元素所继承的计算字体大小大 20%。

- **ex 单位**

等于第一个可用字体[CSS3-FONTS]的使用的 x-高度。x-高度之所以被称为 x-高度，是因为它通常等于小写字母 "x "的高度。然而，即使对于不包含 "x "的字体，也会定义一个 ex。一种字体的 x-高度可以通过不同的方式找到。有些字体包含可靠的 x-高度的度量。如果没有可靠的字体度量标准，UA 可以根据小写字母的高度来确定 x-高度。一种可能的启发式方法是看小写字母 "o "的字形在基线以下延伸了多远，然后从其边界框的顶部减去这个值。在无法确定 X-高度或不切实际的情况下，必须假定值为 0.5em。

- **ch 单位**

等于渲染字体中的 "0"（ZERO，U+0030）字形的使用提前量。(一个字形的提前量是它的提前宽度或高度，以该元素的内联轴为准）。
注意：一个字形的提前量取决于书写模式和文本方向，以及字体设置、文本变换和任何其他影响字形选择或方向的属性。

在无法确定 "0" 字形的尺寸或不切实际的情况下，必须假定它是 0.5em 宽，1em 高。因此，在一般情况下，ch 单位回落到 0.5em，而当它被直立排版时（即书写模式为 vertical-rl 或 vertical-lr，文字方向为直立），则回落到 1em。

- **rem 单位**

等于根元素上字体大小的计算值。

如果在根元素的 'font-size' 属性中使用，或者在没有根元素的文档中，1rem 等于 'font-size' 属性的初始值。

当在它们所指的元素上的 'font-size' 属性值中使用时，这些单位指的是父元素的计算字体度量（如果元素没有父元素，则指与字体属性初始值对应的计算字体度量）。当在元素的上下文之外使用时（比如在媒体查询中），这些单位指的是与 'font' 属性的初始值相对应的计算过的字体度量。

2. **视口-百分数长度：vw, vh, vmin, vmax 单位**

视口百分数的长度是相对于初始包含块的大小而言的。当初始包含区块的高度或宽度发生变化时，它们会被相应地缩放。然而，任何滚动条都被认为不存在。

对于分页媒体，视口百分数长度的确切定义被推迟到[CSS3PAGE]。

- **vw 单位**

等于初始包含块的宽度的 1%。

在下面的例子中，如果视口的宽度是 200mm，h1 元素的字体大小将是 16mm（即（8×200mm）/100）。

```css
h1 {
  字体大小: 8vw;
}
```

- **vh 单位**

等于初始包含块的高度的 1%。

- **vmin 单位**
  相当于 vw 或 vh 中较小的一个。

- **vmax 单位**
  相当于 vw 或 vh 中较大的一个。

#### 2.4.6.2. 绝对长度：cm, mm, Q, in, pt, pc, px 单位

**绝对长度单位** 是相互固定的，并锚定在一些物理测量上。它们主要在输出环境已知的情况下有用。绝对单位包括物理单位（in, cm, mm, pt, pc, Q）和视觉角度单位（px）。

| 单位 | 名称         | 等同于                 |
| ---- | ------------ | ---------------------- |
| cm   | 里面         | 1cm = 96px/2.54        |
| mm   | 毫米         | 1mm =1cm 的 10 分之一  |
| Q    | 四分之一毫米 | 1Q = 1mm 的 4 分之一   |
| in   | 英寸         | 1in = 2.54cm = 96px    |
| pc   | 皮卡         | 1pc = 1in 的 6 分之一  |
| pt   | 点数         | 1pt = 1in 的 72 分之一 |
| px   | 像素         | 1px = 1in 的 96 分之一 |

```css
h1 {
  margin: 0.5in;
} /* 英寸 */

h2 {
  line-height: 3cm;
} /* 厘米 */

h3 {
  word-spacing: 4mm;
} /* 毫米 */

h3 {
  letter-spacing: 1q;
} /* 四分之一毫米 */

h4 {
  font-size: 12pt;
} /*点数 */

h4 {
  font-size: 1pc;
} /* 皮卡 */

p {
  font-size: 12px;
} /* 像素 */
```

所有的绝对长度单位都是兼容的，px 是它们的标准单位。

对于一个 CSS 设备来说，这些尺寸的锚定方式是:

- 通过将物理单位与它们的物理测量值联系起来，或者
- 通过将像素单位与参考像素联系起来

对于典型观看距离的印刷媒体，锚定单位应该是标准物理单位之一（英寸、厘米等）。对于屏幕媒体（包括高分辨率设备）、低分辨率设备和具有不寻常观看距离的设备，建议将锚定单位改为像素单位。对于这些设备，建议像素单位指的是最接近参考像素的设备像素整数。

注意：如果锚定单位是像素单位，物理单位可能不符合他们的物理测量。或者，如果锚单位是物理单位，像素单位可能不会映射到设备像素的整数。

注意：这个像素单位和物理单位的定义与以前版本的 CSS 不同。特别是，在以前的 CSS 版本中，像素单位和物理单位没有固定的比例关系：物理单位总是与它们的物理测量值联系在一起，而像素单位则会变化以最接近参考像素。(做出这个改变是因为太多的现有内容依赖于 96dpi 的假设，而打破这个假设会破坏内容。)

注意：数值是不区分大小写的，并以小写形式序列化，例如 1Q 序列化为 1q。

**参考像素** 是在像素密度为 96dpi 的设备上一个像素的视觉角度，与读者的距离为一臂长度。对于 28 英寸的标称臂长，视觉角度因此约为 0.0213 度。对于在手臂长度上的阅读，1px 因此对应于大约 0.26 毫米（1/96 英寸）。

下面的图片说明了观看距离对参考像素尺寸的影响：71 厘米（28 英寸）的阅读距离导致参考像素为 0.26 毫米，而 3.5 米（12 英尺）的阅读距离导致参考像素为 1.3 毫米。

![像素说明1](illustrations/pixel1.png)

这第二张图片说明了设备的分辨率对像素单位的影响：在低分辨率设备（如典型的计算机显示器）中，1px 乘 1px 的区域由一个点覆盖，而在高分辨率设备（如打印机）中，同样的区域由 16 个点覆盖。

![像素说明2](illustrations/pixel2.png)

### 2.4.7. 其他量

#### 2.4.7.1. 角度单位：`<angle>` 类型以及 deg, grad, read, turn 单位

角度值是用`<angle>`表示的`<dimension>`。角度单位的标识符为：

- **deg**
  角度。一个完整的圆有 360 度。

- **grad**
  梯度，也被称为 "gon" 或 "grade"。一个完整的圆里有 400 个梯度。

- **rad**
  弧度。一个完整的圆里有 2π 个弧度。

- **turn**
  周。一整圈有一周。
  例如，一个直角是 90deg 或 100grad 或 0.25turn 或大约 1.57rad。

所有的`<angle>`单位都是兼容的，度是它们的典型单位。

按照惯例，当一个角度在 CSS 中表示一个方向时，它通常被解释为一个方位角，其中 0 度是屏幕上的 "上" 或 "北"，而更大的角度是更顺时针的（所以 90 度是 "右" 或 "东"）。

例如，在 linear-gradient() 函数中，决定梯度方向的`<angle>`被解释为一个方位角。

注意：由于传统的原因，`<angle>`的一些用法允许裸露的 0 表示 0deg。然而，这在一般情况下是不正确的，并且不会出现在`<angle>`类型的未来使用中。

#### 2.4.7.2. 时长单位：`<time>` 类型以及 s, ms 单位

时间值是用`<time>`表示的尺寸。时间单位的标识符为：

- **s**
  秒。

- **ms**
  毫秒。一秒钟内有 1000 毫秒。

所有的`<time>`单位都是兼容的，而 s 是它们的典型单位。

属性可以将时间值限制在某个范围内。如果该值超出了允许的范围，该声明是无效的，必须被忽略。

#### 2.4.7.3. 频率单位：`<frequency>` 类型以及 Hz, kHz 单位

频率值是以`<frequency>`表示的尺寸。频率单位的标识符为：

- **Hz**
  赫兹。它表示每秒钟发生的次数。

- **kHz**
  千赫兹（KiloHertz）。一个千赫兹是 1000 赫兹。

例如，在表示声音的音高时，200Hz（或 200hz）是低音，而 6kHz（或 6khz）是高音。

所有`<frequency>`单位都是兼容的，Hz 是它们的典型单位。

注意：数值是不区分大小写的，并以小写形式序列化，例如，1Hz 序列化为 1hz。

#### 2.4.7.4. 分辨率单位：`<resolution>` 类型以及 dpi, dpcm, dppx 单位

分辨率单位是用`<resolution>`表示的尺寸。分辨率单位的标识符为：

- dpi
  每英寸的点数。

- dpcm
  每厘米的点数。

- dppx
  每 px 的点数单位。

`<resolution>` 单位表示图形表示中单个 "点" 的大小，表示这些点在 CSS 中适合多少个 in、cm 或 px。关于用途，请参见例如[MEDIAQ]中的分辨率媒体查询或[CSS3-IMAGES]中定义的图像分辨率属性。

所有`<resolution>`单位都是兼容的，dppx 是它们的标准单位。

请注意，由于 CSS in 与 CSS px 的固定比例为 1：96，1dppx 相当于 96dpi。这与 CSS 中显示的图像的默认分辨率相对应：见 image-resolution。

下面的@media 规则使用媒体查询[MEDIAQ]为每一 CSS px 单位使用两个或更多设备像素的设备分配了一些特殊的样式规则。

```css
@media (min-resolution: 2dppx) {
  ...;
}
```

### 2.4.8. 定义在其他地方的数据类型

一些数据类型被定义在他们自己的模块中。这个例子讲的是一些最常见的，在几个规范中使用的数据。

#### 2.4.8.1. 颜色：`<color>` 类型

`<color>` 数据类型在[CSS3COLOR]中定义。支持 CSS 颜色级别 3 或其后续版本的 UA 必须按照其中的定义解释`<color>`。

#### 2.4.8.2. 图像：`<image>` 类型

`<image>`数据类型在[CSS3-IMAGES]中定义。支持 CSS 图像值第 3 级或其后续版本的 UA 必须按照其中的定义解释`<image>`。尚不支持 CSS 图像第 3 级的用户代理必须将`<image>`解释为`<url>`。

#### 2.4.8.3. 2D 位置：`<position>` 类型

`<position>`值指定一个对象区域（如背景图像）在一个定位区域（如背景定位区域）内的位置。它被解释为对 background-position 的指定。[css3-background]

```
<position> = [
  [ left | center | right ] || [ top | center | bottom ]
|
  [ left | center | right | <length-percentage> ]
  [ top | center | bottom | <length-percentage> ]?
|
  [ [ left | right ] <length-percentage> ] &&
  [ [ top | bottom ] <length-percentage> ]
]
```

注意：'background-position'属性也接受三值语法。这已经被普遍禁止了，因为当它与属性值中的其他长度或百分数成分结合时，会产生解析上的歧义。

串行化时的标准顺序是水平组件，然后是垂直组件。

当在语法中与其它关键字、`<length>`或`<percentage>`一起指定时，`<position>`被贪婪地解析；它消耗尽可能多的组件。

例如，transform-origin 将一个 3D 位置定义为（有效地）`<position> <length>?`。像 left 50px 这样的值将被解析为一个 2 值的`<position>`，其中省略了一个 z 分量；另一方面，像 top 50px 这样的值将被解析为一个单值的`<position>`，后面还有一个`<length>`。

### 2.4.9. 函数记法

**函数记法** 是一种可以表示更复杂的类型或调用特殊处理的组件值。语法以函数的名称开始，后面紧跟一个左括号（即`<funtion-token>`），然后是符号的参数，后面是一个右括号。紧接着括号内的空白是允许的，但也是可选的。函数可以接受多个参数，其格式类似于 CSS 属性值。

一些传统的函数记法，如 rgba()，不必要地使用逗号，但一般来说，逗号只用于分隔列表中的项目，或分隔语法中的片段，否则会产生歧义。如果用逗号来分隔参数，逗号前后的空白是可选的。

```css
background: url(http://www.example.org/image);
color: rgb(100, 200, 50);
content: counter(list-item) '. ';
width: calc(50% - 2em);
```

#### 2.4.9.1. 数学表达式：cal()

calc()函数允许用加法(+)、减法(-)、乘法(\*)和除法(/)的数学表达式作为组件值。calc()表达式表示它所包含的数学计算的结果，使用标准的运算符优先级规则。它可以用于允许使用`<length>`, `<frequency>`, `<angle>`, `<time>`, `<percentage>`, `<number>`, 或 `<integer>` 值的地方。cal()表达式的组件可以是字面值或 attr()或 cal()表达式。

```css
section {
  float: left;
  margin: 1em;
  border: solid 1px;
  width: calc(100% / 3 - 2 * 1em - 2 * 1px);
}

p {
  margin: calc(1rem - 2px) calc(1rem - 1px);
}
```

下面的设置使字体大小正好适合视口内的 40em，确保无论屏幕大小如何，总是有大致相同数量的文本填充在屏幕上：

```css
:root {
  font-size: calc(100vw / 40);
}
```

如果设计的其他部分是用 rem 单位指定的，那么整个布局的比例将与视口宽度相匹配。

下面的例子堆叠了两张背景图片，第一张完全居中，第二张在第一张的底部和左边偏移 20px：

```css
.foo {
  background: url(top.png), url(bottom.png);
  background-repeat: no-repeat;
  background-position: 50% 50%, calc(50% + 20px) calc(50% + 20px);
}
```

这个例子展示了如何在梯度上放置颜色站，与两端的距离相等：

```css
.foo {
  background-image: linear-gradient(
    to right,
    silver,
    white 50px,
    white calc(100% - 50px),
    silver
  );
}
```

1. **语法**

calc()函数的语法是：

```
<calc()> = calc( <calc-sum> )
<calc-sum> = <calc-product> [ ['+' | '-' ] <calc-product> ]*
<calc-product> = <calc-value> [ '*' <calc-value> | '/' <calc-number-value> ]*
<calc-value> = <number> | <dimension> | <percentage> | ( <calc-sum> )
<calc-number-sum> = <calc-number-product> [ ['+' | '-' ] <calc-number-product> ]*.
<calc-number-product> = <calc-number-value> [ '*' <calc-number-value> | '/' <calc-number-value> ] *
<calc-number-value> = <number> | ( <calc-number-sum> )
```

此外，在+和-运算符的两边都需要留白。(\*和/运算符在使用时可以不在其周围留白)。

UA 必须支持至少 20 个项的 calc()表达式，其中每个 NUMBER、DIMENSION 或 PERCENTAGE 是一个项。如果一个 calc()表达式包含的术语超过支持的数量，它必须被视为无效的。

2. **类型检查**

数学表达式有一个解析类型，它是`<length>`、`<frequency>`、`<angle>`、`<time>`、`<percentage>`、`<number>`或`<integer>`中的一个。解决的类型必须对表达式放置的地方有效；否则，表达式就无效了。表达式的解析类型是由它所包含的值的类型决定的。`<number-token>`的类型是`<number>`或`<integer>`。`<dimension-token>`的类型由它的单位决定（cm 是`<length>`，deg 是`<angle>`，等等）。一个 attr()表达式的类型是由它的`<type-or-unit>`参数给出的。

注意：因为 `<number-token>` 总是被解释为` <number>` 或 `<integer>`，"无单位 0" `<length>` 在 calc() 中不被支持。也就是说，`width: calc(0 + 5px);` 是无效的，尽管`width: 0;`和`width: 5px;`都是有效的。

如果百分数在表达式的上下文中被接受，并且它们被定义为相对于除`<number>`以外的另一种类型，那么`<percent-token>`将被视为该类型。例如，在宽度属性中，百分数具有`<length>`类型。如果在该上下文中，`<percentage>`值与任何其他类型的值不兼容，那么百分数才具有`<percentage>`类型。如果百分数通常不允许代替 calc()，那么包含百分数的 calc()表达式在该上下文中是无效的。

注意：注意相对于`<number>`的`<percentage>`，比如不透明度，在 calc()中是不允许的。允许这样做会给 "单位代数"（允许`<dimension>`的乘法/除法）带来很大的问题，而且到目前为止的每一种情况下，都没有提供任何新的功能。(例如，不透明度：25%与不透明度：.25 是一样的；这只是一个微不足道的语法转换）。

注意：尽管有几个属性在使用值时，裸露的`<number>`变成了`<length>`（特别是 line-height 和 tab-size），但在 calc()中，`<number>`从未变成 "length-like"。它们总是保持为`<number>`。

操作符形成子表达式，它们根据其参数获得类型。为了使表达式更简单，运算符对它们接受的类型有限制。在每个运算符中，左、右参数的类型被检查是否符合这些限制。如果兼容，类型就会按照下面描述的方式解决（下面为了简单起见，忽略了运算符的优先级规则）:

- 在+或-处，检查两边是否有相同的类型，或者一边是`<number>`，另一边是`<integer>`。如果两边都是同一类型，则解析为该类型。如果一边是`<number>`，另一边是`<integer>`，则解析为`<number>`。
- 在\*处，检查至少有一条边是`<number>`。如果两边都是`<integer>`，解析为`<integer>`。否则，解析为另一边的类型。
- 在/，检查右边是否是`<number>`。如果左边是`<integer>`，解析为`<number>`。否则，解析为左边的类型。

如果一个运算符没有通过上述检查，那么该表达式是无效的。另外，除以 0 也是无效的。这既包括除以字面数字 0，也包括任何求值为 0 的数字表达式（因为纯数字表达式在解析时不需要任何额外的信息就可以被求值）。

注意：代数简化并不影响 calc()表达式的有效性或其解析类型。例如，calc(5px - 5px + 10s)和 calc(0 \* 5px + 10s)都是无效的，因为它们试图添加一个长度和一个时间。

3. **计算值**

calc()表达式的计算值是所有组件都被计算的表达式。

如果百分数在计算值时没有被解决，它们就不会在 calc() 表达式中被解决，例如，calc(100% - 100% + 1em) 被解决为 calc(1em + 0%)，而不是 1em。如果在一个值中有计算百分数的特殊规则（例如高度属性），那么只要 calc()表达式包含百分数，它们就会适用。

例如，font-size 在计算值时计算百分数值，以便可以计算字体的相对长度单位，而 background-position 对于百分数值有依赖布局的行为，因此在使用值时才会解决百分数问题。

由于这个原因，background-position 的计算在 calc()中保留了百分数，而 font-size 将直接把这种表达式计算成长度。

鉴于表格单元格和表格元素的宽度和高度计算的复杂性，在自动和固定布局的表格中，涉及表格列、表格列组、表格行、表格行组和表格单元格的宽度和高度的百分数的数学表达式，可能会被视为指定了自动。

4. **范围检查**

在 calc()中不进行数值的解析时范围检查，因此超出范围的数值不会导致声明无效。然而，由表达式产生的值必须被钳制在目标上下文允许的范围内。在可能的范围内对计算的值进行夹紧，如果计算不能充分简化表达式以允许范围检查，也对使用的值进行夹紧。(不对指定的值进行钳制）。

注意：这要求所有接受 calc()的上下文将其允许的值定义为一个封闭（而不是开放）的区间。

由于不允许小于 0px 的宽度，这三种声明是等同的：

```css
width: calc(5px - 10px);
width: calc(-5px);
width：0px;
```

但是请注意，width: -5px 并不等同于 width: calc(-5px)! calc()之外的超范围值在语法上是无效的，会导致整个声明被删除。

### 2.4.10. 属性引用：attr()

attr() 函数被允许作为应用于元素或伪元素的属性中的一个组件值。它返回元素上一个属性的值。如果在一个伪元素上使用，它返回伪元素的源元素上的属性值。

attr()表达式的计算值是元素上具有指定名称的属性的值，根据下面的规则。

注意：在 CSS2.1 [CSS21] 中，attr() 表达式总是返回一个字符串。在 CSS3 中，attr()表达式可以返回许多不同的类型。attr()表达式不能返回所有的东西，例如，它不能做计数器、命名的字符串、引号或关键字值，如 auto、nowrap 或 baseline。这是有意为之的，因为 attr()表达式的意图不是让我们能够使用 CSS 来描述一种表现语言的格式，而是让 CSS 能够考虑到语义数据。

attr()表达式的新语法是：

```
attr( <attr-name> <type-or-unit>? [, <attr-fallback> ] ?)
```

其中 `<attr-name>` 是一个 CSS 的限定名称（[CSS3NAMESPACE] 中的 qname 生产），代表一个属性名称。(与属性选择器一样，`<attr-name>` 的大小写敏感度取决于文档语言。

可选的 `<type-or-unit>` 参数是从下面的列表中抽取的一个关键字，它告诉 UA 如何解释属性值，并为 attr() 表达式定义了一个类型。如果省略，则暗示为字符串。

可选的 `<attr-fallback>` 参数表示一个回退值，如果命名的属性缺失，或者它的值不能被解析为给定的类型，或者对属性来说是无效的/超出范围的，那么它将被使用。如果它不存在，给定的 <类型或单位>`的默认值（来自下面的列表）将被暗示。`
type-or-unit)表达式只有在以下情况下才有效：

- attr()表达式的类型在 attr()表达式放置的地方有效。
- 属性名的命名空间前缀，如果有的话，被定义。
- `<attr-fallback>`在 attr()表达式放置的地方有效。
- `<attr-fallback>` 不包含另一个 attr() 表达式。
- 并且，如果 attr() 表达式不是一个属性的唯一组件值，`<attr-fallback>` 匹配 attr() 的类型。

注意，如果 attr() 表达式是整个属性值，默认值不需要是给定的类型。例如，如果作者要求的属性类型是 px，默认值仍然可以是 auto，就像在 `width: attr(size px, auto);`。

然而，如果 attr() 与其他值一起使用以形成完整的属性值，那么默认值必须与 attr() 的类型匹配。例如，box-shadow: attr(size px, inset) 5px 10px blue;是无效的，尽管如果你用 px 长度或 inset 关键字来替换 attr()表达式，它将创建一个有效的声明。

如果指定的属性存在于元素上，属性的值必须按照`<type-or-unit>`参数的要求进行解析(定义在下面的列表)。除非类型是字符串，否则它必须首先剥离前导和尾部的白色空间。结果值是 attr() 表达式的值。如果这个值没有按照要求解析，attr()表达式的值就是它的回退值。

`<type-or-unit>`的关键字是：

- **string**
  属性值被当作 CSS `<string>` 的内容。默认是空字符串。
  注意：这不会用 CSS 解析器重新解析属性值。因此，例如，一个属性的值是"\51"，它将产生一个包含这三个字符的字符串，而不是一个包含 "Q "的字符串（转义将评估为的字符）。

- **color**
  属性值必须解析为`<hash-token>`或`<ident-token>`，并成功解释为`<color>`。默认是 currentcolor。

- **URL**
  该属性值被视为 CSS `<string>`的内容。它被解释为 url()符号中的一个引号字符串。默认值是 about:invalid，这是一个定义的 URL（在附录 A 中），指向一个不存在的文档，具有一般的错误条件。相对的 URL 必须根据文档语言的规则做成绝对的，因为它适用于来自元素的 URL；它们不是相对于样式表的。

- **integer**
  属性值必须解析为`<number-token>`，并成功解释为`<integer>`。默认值是 0，如果 0 对该属性无效，则是该属性的最小值。如果有关属性只接受一定范围内的整数，而该属性超出了范围，也必须使用默认值。

- **number**
  属性值必须解析为`<number-token>`，并被解释为`<number>`。默认值是 0，否则，如果 0 对属性无效，则是属性的最小值。如果有关属性只接受一定范围内的整数，而该属性超出了范围，也必须使用默认值。

- **length, angle, time, frequency**
  属性值必须解析为`<dimension-token>`，并成功解释为指定的类型。默认值是相关单位中的 0，如果相关单位中的 0 对该属性无效，则是该属性的最小值。如果有关属性只接受一定范围内的值（例如正的长度或 0 到 90 度的角度），而该属性超出了范围（例如负的长度或 180 度），也必须使用默认值。如果单位是相对长度，必须计算成绝对长度。

- **%**, 匹配`<length>`、`<angle>`、`<time>` 或 `<frequency>` 单位之一的关键字
  属性值必须解析为`<number-token>`，并被解释为具有指定单位的尺寸。默认值是相关单位中的 0，如果相关单位中的 0 对该属性无效，则是该属性的最小值。如果相关的属性只接受一定范围内的值（例如正的长度或 0 到 90 度的角度），而属性超出了范围（例如负的长度或 180 度），也必须使用默认值。如果单位是相对长度，必须计算成绝对长度。

这个例子显示了使用 attr()来直观地说明一个 XML 文件中的数据:

```css
<stock
  > <wood
  length='12'/
  > <wood
  length='5'/
  > <metal
  length='19'/
  > <wood
  length='4'/
  > </stock
  > stock::before {
  display: block;
  content: 'To scale, the lengths of materials in stock are:';
}

stock > * {
  display: block;
  width: attr(length em); /* 默认值 0 */
  height: 1em;
  border: solid thin;
  margin: 0.5em;
}

wood {
  background: orange url(wood.png);
}

metal {
  background: silver url(metal.png);
}
```

以下所有的例子都是无效的，会导致解析时间错误，从而导致相关的声明--这里是所有的声明--被忽略：

```css
content: attr(title color); /* 'content' 不接受颜色 */

content: attr(end-of-quote string, inherit) close-quote;
/* 这里不允许使用'inherit'值，因为结果会是
'inherit close-quote'，这是无效的。 */

margin: attr(vertical length) attr(horizontal deg);
/* 在这一点上，deg 单位是无效的 */

color: attr(color); /* 'color' 不接受字符串 */
```

注意：attr()表达式目前不能回落到另一个属性上。未来的 CSS 版本可能会朝这个方向扩展 attr() 。
