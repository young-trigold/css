目录：

- [7. 视觉格式化模型细节](#7-视觉格式化模型细节)
  - [7.1. 包含块的定义](#71-包含块的定义)
  - [7.2. width 属性](#72-width-属性)
  - [7.3. 计算 width 和 margin](#73-计算-width-和-margin)
    - [7.3.1. 行内，非替换性元素](#731-行内非替换性元素)
    - [7.3.2. 行内，替换性元素](#732-行内替换性元素)
    - [7.3.3. 块级，非替换性元素，正常流](#733-块级非替换性元素正常流)
    - [7.3.4. 块级，替换性元素，正常流](#734-块级替换性元素正常流)
    - [7.3.5. 浮动，非替换性元素](#735-浮动非替换性元素)
    - [7.3.6. 浮动，替换性元素](#736-浮动替换性元素)
    - [7.3.7. 绝对定位，非替换性元素](#737-绝对定位非替换性元素)
    - [7.3.8. 绝对定位，替换性元素](#738-绝对定位替换性元素)
    - [7.3.9. 行内块级，非替换性元素，正常流](#739-行内块级非替换性元素正常流)
    - [7.3.10. 行内块级，替换性元素，正常流](#7310-行内块级替换性元素正常流)
  - [7.4. 最小与最大宽度](#74-最小与最大宽度)
  - [7.5. height 属性](#75-height-属性)
  - [7.6. 计算 height 和 margin](#76-计算-height-和-margin)
  - [7.7. 最小与最大高度](#77-最小与最大高度)
  - [7.8. 行高的计算](#78-行高的计算)

# 7. 视觉格式化模型细节

## 7.1. 包含块的定义

一个元素的盒子的位置和大小有时是相对于某个矩形计算的，这个矩形称为元素的 **包含块**。一个元素的包含块定义如下：

1. 根元素所在的包含块是一个被称为 **初始包含块** 的矩形。对于连续媒体，它具有视口的尺寸，并被锚定在画布原点；对于分页媒体，它是页面区域。初始包含块的 "direction" 属性与根元素的相同。
2. 对于其他元素，如果该元素的 position 是 "relative" 或 'static'，则包含块由最近的祖先元素的内容边缘形成，该盒子是一个块容器或建立了一个格式化的上下文。
3. 如果元素有'position: fixed'，在连续媒体的情况下，包含块由视口建立，在分页媒体的情况下，包含块由页面区域建立。
4. 如果该元素有'position: absolute'，包含块由最近的祖先元素建立，其'position'为'absolute'、'relative'或'fixed'，方式如下：
   1. 如果该祖先元素是一个行内元素，那么包含块就是为该元素生成的第一个和最后一个行内盒子的内边距内边距周围的边界。在 CSS 2.2 中，如果行内元素被分割成多行，那么包含块是未定义的。
   2. 否则，包含块是由祖先的内边距边缘形成的。

如果没有这样的祖先元素，包含块就是初始包含块。

在分页媒体中，一个绝对定位的元素是相对于它的包含块定位的，忽略任何分页（就像文档是连续的）。该元素随后可能在几个页面上被分割。

对于绝对定位的内容，如果它被解析到一个页面上的某个位置，而不是正在排版的页面（当前页面），或者被解析到当前页面上已经被渲染打印的位置，打印机可以将内容放在：

- 在当前页的另一个位置上
- 在随后的页面上，或者
- 可以省略它。

请注意，一个被分割在几个页面上的块级元素在每个页面上的宽度可能不同，而且可能有特定的设备限制。

## 7.2. width 属性

| 属性名   | width                                    |
| -------- | ---------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                | <percentage> | auto | inherit` |
| 初始值   | auto                                     |
| 适用元素 | 除了行内非替换性元素，表格行，列组的元素 |
| 可继承性 | 否                                       |
| 百分数值 | 相对于包含块的宽度                       |
| 适用媒体 | 视觉                                     |
| 计算值   | 百分数，auto 见规定，或绝对长度          |

此属性指定了盒子的内容宽度。

这个属性不适用于非替换的行内元素。非替换的行内元素盒子的内容宽度是其内渲染内容的宽度（在任何子元素的相对偏移之前）。回顾一下，行内盒子流向行盒子。行盒子的宽度由其包含块给出，但可能会因为浮子的存在而被缩短。

属性值有以下含义：

- `<length>`
  用长度单位指定内容区的宽度。

- `<percentage>`
  指定一个百分数的宽度。这个百分数是相对于生成的盒子的包含块的宽度计算的。如果包含块的宽度取决于这个元素的宽度，那么产生的布局在 CSS 2.2 中是未定义的。注意：对于绝对定位的元素，其包含的块是基于一个块容器元素的，百分数是相对于该元素的内边距盒子的宽度计算的。这是对 CSS1 的一个改变，在 CSS1 中，百分数宽度总是根据父元素的内容盒子来计算。

- auto
  宽度取决于其他属性的值。见下面的章节。

'width' 的负值是非法的。

## 7.3. 计算 width 和 margin

一个元素的 'width'、'margin-left'、'margin-right'、'left' 和 'right' 属性用于布局的值取决于生成的盒子的类型和相互之间的关系。(用于布局的值有时被称为使用值。)原则上，使用值与计算值相同，'auto' 被一些合适的值取代，百分数根据包含块计算，但也有例外。以下情况需要加以区分：

1. 行内，非替换性元素
2. 行内，替换性元素
3. 块级，非替换性元素，正常流
4. 块级，替换性元素，正常流
5. 浮动，非替换性元素
6. 浮动，替换性元素
7. 绝对定位，非替换性元素
8. 绝对定位，替换性元素
9. 行内块级，非替换性元素，正常流
10. 行内块级，替换性元素，正常流

对于第 1-6 点和第 9-10 点，在相对定位元素的情况下，'left' 和 'right' 的值由[相对定位](#643-相对定位)章节的规则决定。

注意。下面计算的 'width' 的使用值是一个暂定值，可能要计算多次，取决于 'min-width' 和 'max-width'，见下面的最小和最大宽度部分。

### 7.3.1. 行内，非替换性元素

'width' 属性不适用。'margin-left' 或 'margin-right' 的计算值 'auto' 会变成一个使用值 '0'。

### 7.3.2. 行内，替换性元素

如果 'margin-left' 或 'margin-right' 的计算值为 'auto'，则使用值为 '0'。

如果 'height' 和 'width' 的计算值都是 'auto'，并且该元素也有一个固有的宽度，那么这个固有的宽度就是 'width'的使用值。

如果 'height' 和 'width' 的计算值都是 'auto'，元素没有固有宽度，但有固有高度和固有比例；或者如果 'width' 的计算值是 'auto'，'height' 有其他计算值，而元素确实有固有比例；那么 'width' 的使用值是：

```
(使用的高度) * (固有比例)
```

如果 'height' 和 'width' 的计算值都是 'auto'，而元素有一个固有比例，但没有固有高度或宽度，那么 'width' 的使用值在 CSS 2.2 中是未定义的。然而，我们建议，如果包含块的宽度本身并不取决于替换性元素的宽度，那么 'width' 的使用值将从正常流中用于块级非替换元素的约束方程中计算。

否则，如果 'width' 的计算值为 'auto'，而该元素有一个固有宽度，那么这个固有宽度就是 'width' 的使用值。

否则，如果 'width' 的计算值是 'auto'，但没有满足上述条件，那么 'width' 的使用值就变成 300px。如果 300px 太宽而无法适应设备，那么 UA 应该使用具有 2:1 比例且适合设备的最大矩形的宽度来代替。

### 7.3.3. 块级，非替换性元素，正常流

在其他属性的使用值中，以下约束必须成立：

```
'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' = 包含块的宽度
```

如果 'width' 不是 'auto'，并且 'border-left-width'+'padding-left'+'width'+'padding-right'+'border-right-width'（加上任何不是'auto'的'margin-left'或'margin-right'）大于包含块的宽度，那么对于以下规则，任何 'margin-left '或 'margin-right' 的 auto 值将被视为 0。

如果上述所有的计算值都不是 'auto'，那么这些值被称为 "过度约束"，其中一个使用值将不得不与它的计算值不同。如果包含块的 'direction' 属性的值是 'ltr'，那么 'margin-right' 的指定值就会被忽略，该值会被计算出来，以便使方程两边相等。如果 'direction' 的值是 'rtl'，这将发生在 'margin-left' 上。

如果正好有一个值被指定为 'auto'，那么它的使用值就会从方程中产生。

如果 'width' 被设置为 'auto'，任何其他的 'auto' 值都会变成 '0'，而 'width' 会从方程中产生。

如果 'margin-left' 和 'margin-right' 都是 'auto'，它们的使用值是相等的。这将使元素在水平方向上相对于包含块的边缘居中。

### 7.3.4. 块级，替换性元素，正常流

'width' 的使用值被确定为行内替换性元素。然后应用非替换性块级元素的规则来确定外边距。

### 7.3.5. 浮动，非替换性元素

如果 'margin-left' 或' margin-right' 被计算为 'auto'，它们的使用值是 '0'。

如果 'width' 被计算为 'auto'，使用值是“收缩到适合”的宽度。

收缩宽度的计算与使用自动表格布局算法计算表格单元的宽度类似。大致是：通过格式化内容，计算出首选的宽度，除了明确的换行之外，不需要换行，还可以计算出首选的最小宽度，例如，通过尝试所有可能的换行。CSS 2.2 并没有定义确切的算法。第三，找到可用的宽度：在这种情况下，这是包含块的宽度减去 "margin-left"、"border-left-width"、"padding-left"、"padding-right"、"border-right-width"、"margin-right "的使用值，以及任何相关滚动条的宽度。

然后，收缩到合适的宽度是：min(max(首选最小宽度，可用宽度), 首选宽度)。

### 7.3.6. 浮动，替换性元素

如果 'margin-left' 或 'margin-right' 被计算为 'auto'，它们的使用值是 '0'。'width' 的使用值与行内替换性的元素一样确定。

### 7.3.7. 绝对定位，非替换性元素

在本节和下一节中，术语“静态位置”（一个元素）大致指一个元素在正常流动中的位置。更确切地说：

- **静态位置的包含块** 是一个假设的盒子的包含块，如果其指定的 'position' 值为 'static'，其指定的 'float' 为 'none'，则该盒子将成为该元素的第一个盒子。

- 'left' 的静态位置是指如果元素的 'position' 属性为 'static'，'float' 为 'none'，那么从包含块的左边缘到一个假设的盒子的左边缘的距离，这个盒子将是元素的第一个盒子。如果假设的盒子是在包含块的左边，那么这个值是负的。

- 'right' 的静态位置是指从包含块的右边缘到上述同一假设盒子的右边缘的距离。如果假设的盒子在包含块边缘的左边，这个值就是正的。

但是，用户代理并没有实际计算该假设盒子的尺寸，而是自由地猜测其可能的位置。

为了计算静态位置，固定位置元素的包含块是初始包含块，而不是视口，所有可滚动的盒子都应该被假定为滚动到原点。

决定这些元素的使用值的约束条件是：

```
'left' + 'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + 'right' = 包含块的宽度
```

如果 'left'、'width'、'right'三者都是'auto'。首先将'margin-left'和'margin-right'的任何'auto'值设置为 0。然后，如果建立静态位置的元素的'direction'属性是'ltr'，则将'left'设置为静态位置，并应用下面的第三条规则；否则，将'right'设置为静态位置，并应用下面的第一条规则。

如果这三条都不是'auto'：如果'margin-left'和'margin-right'都是'auto'，在两个边距得到相等值的额外约束下求解方程，除非这会使它们变成负值，在这种情况下，当包含块的方向是'ltr'（'rtl'），将'margin-left'（'margin-right'）设置为零，求解为'margin-right'（'margin-left'）。如果'margin-left'或'margin-right'中的一个是'auto'，求解该值的方程。如果数值被过度限制，忽略'left'（如果包含块的'direction'属性是'rtl'）或'right'（如果'direction'是'ltr'）的数值，并求解该数值。

否则，将'margin-left'和'margin-right'的'auto'值设置为 0，并从以下六条规则中选择一条适用。

1. 'left'和'width'都是'auto'，而'right'不是'auto'，那么宽度就会被收缩到合适的范围。然后解决'left'的问题
2. 'left'和'right'是'auto'，'width'不是'auto'，那么如果建立静态位置的元素的'direction'属性是'ltr'，则将 3. 'left'设为静态位置，否则将'right'设为静态位置。然后求解'left'（如果'方向是'rtl'）或'right'（如果'direction'是'ltr'）。
3. 如果'width'和'right'是'auto'，而'left'不是'auto'，那么宽度就会被收缩到合适的位置。然后求解'right'。
4. 'left'是'auto'，'width'和'right'不是'auto'，那么求解'left'。
5. 'width'是'auto'，'left'和'right'都不是'auto'，那么求'width'。
6. 'right'是'auto'，'left'和'width'不是'auto'，那么求'right'。

收缩至合适宽度的计算与使用自动表格布局算法计算表格单元的宽度类似。大致是：通过格式化内容，计算首选的宽度，除了明确的换行之外，不需要换行，同时计算首选的最小宽度，例如，尝试所有可能的换行。CSS 2.2 并没有定义确切的算法。第三，计算可用的宽度：在将 'left'（情况 1）或 'right'（情况 3）设置为 0 之后，通过求解 'width' 来找到。

然后，收缩到合适的宽度是：min(max(首选最小宽度，可用宽度)，首选宽度)。

### 7.3.8. 绝对定位，替换性元素

在这种情况下，上一节节适用于包括约束方程在内的所有内容，但上一节的其余部分被以下规则所取代：

1. 'width'的使用值与行内替换元素一样确定。如果'margin-left'或'margin-right'被指定为'auto'，其使用值由以下规则决定。
2. 如果'left'和'right'的值都是'auto'，那么如果建立静态位置包含块的元素的'direction'属性是'ltr'，将'left'设置为静态位置；否则如果'direction'是'rtl'，将'right'设置为静态位置。
3. 如果'left'或'right'是'auto'，将'margin-left'或'margin-right'上的任何'auto'改为'0'。
4. 如果此时'margin-left'和'margin-right'仍然是'auto'，在两个边距必须相等的额外约束下求解方程，除非这将使它们变成负值，在这种情况下，当包含块的方向是'ltr'（'rtl'），将'margin-left'（'margin-right'）设置为 0，并求解'margin-right'（'margin-left'）。
5. 如果这时有一个'auto'的左边，求解这个值的方程。
6. 如果这时数值被过度限制，忽略'left'（如果包含块的'方向'属性是'rtl'）或'right'（如果'方向'是'ltr'）的数值并求解该数值。

### 7.3.9. 行内块级，非替换性元素，正常流

如果'width'是'auto'，使用的值是浮动元素的收缩宽度。

如果'margin-left'或'margin-right'的计算值为'auto'，则使用值为'0'。

### 7.3.10. 行内块级，替换性元素，正常流

与行内替换性元素完全相同。

## 7.4. 最小与最大宽度

| 属性名   | min-width                                    |
| -------- | ---------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                | <percentage> | inherit` |
| 初始值   | 0                                     |
| 适用元素 | 除了行内非替换性元素，表格行，列组的元素 |
| 可继承性 | 否                                       |
| 百分数值 | 相对于包含块的宽度                       |
| 适用媒体 | 视觉                                     |
| 计算值   | 百分数，auto 见规定，或绝对长度          |

| 属性名   | max-width                                    |
| -------- | ---------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                | <percentage> | none | inherit` |
| 初始值   | none                                     |
| 适用元素 | 除了行内非替换性元素，表格行，列组的元素 |
| 可继承性 | 否                                       |
| 百分数值 | 相对于包含块的宽度                       |
| 适用媒体 | 视觉                                     |
| 计算值   | 百分数，auto 见规定，或绝对长度          |

这两个属性允许作者将内容宽度限制在一定范围内。值有以下含义：

- `<length>`
指定一个固定的最小或最大使用宽度。
- `<percentage>`
指定用于确定使用值的百分比。这个百分比是相对于生成的盒子的包含块的宽度计算的。如果包含块的宽度为负数，则使用值为零。如果包含块的宽度取决于这个元素的宽度，那么生成的布局在CSS 2.2中是未定义的。
- none
(仅适用于'max-width'）对盒子的宽度没有限制。

'min-width' 和 'max-width' 的负值是非法的。

在CSS 2.2中，'min-width' 和'max-width'对表格、行内表格、表格单元格、表格列和列组的影响是未定义的。

下面的算法描述了这两个属性如何影响 'width' 属性的使用值。

暂时使用的宽度是按照上面 "计算宽度和边距 "的规则计算的（不包括'min-width'和'max-width'）。
如果暂定使用的宽度大于'max-width'，则再次应用上述规则，但这次使用'max-width'的计算值作为'width'的计算值。
如果结果宽度小于'min-width'，则再次应用上面的规则，但这次使用'min-width'的值作为'width'的计算值。
这些步骤并不影响上述属性的真实计算值。

然而，对于有内在比例的替换性元素，并且'width'和'height'都指定为'auto'，算法如下：

从表中选择适当的违反约束的高度和宽度的解析值。将最大宽度和最大高度作为max(min, max)，使min≤max成立。在这个表中，w和h代表宽度和高度的计算结果，忽略了 "最小宽度"、"最小高度"、"最大宽度 "和 "最大高度 "属性。通常情况下，这些是内在的宽度和高度，但在有内在比例的替换元素的情况下，它们可能不是。

注意：在设置了明确的宽度或高度，而其他维度是自动的情况下，在自动侧应用最小或最大约束会导致过度约束的情况。规范中的行为是明确的，但可能不是作者所期望的。在这种情况下，可以使用CSS3对象拟合属性来获得不同的结果。

|违反约束的情况| 解决的宽度| 解决的高度|
| --- | --- | --- |
|none| w |h|
w > max-width max-width max(max-width * h/w, min-height)
w < min-width min-width min(min-width * h/w, max-height)
h > max-height max(max-height * w/h, min-width) max-height
h < min-height min(min-height * w/h, max-width) min-height
(w>最大宽度)和(h>最大高度)，其中(最大宽度/w≤最大高度/h) 最大宽度max(最小高度，最大宽度*h/w)
(w>最大宽度)和(h>最大高度)，其中(max-width/w>max-height/h) max(min-width, max-height * w/h) max-height
(w < 最小宽度) 和 (h < 最小高度)，其中 (最小宽度/w ≤ 最小高度/h) min(最大宽度，最小高度 * w/h) 最小高度
(w<最小宽度)和(h<最小高度)，其中(最小宽度/w>最小高度/h) min-width min(max-height, min-width * h/w)
(w < min-width) and (h > max-height) min-width max-height
(w>最大宽度)和(h<最小高度)最大宽度最小高度
然后应用上面 "计算宽度和边距 "下的规则，就像'width'被计算为这个值一样。

## 7.5. height 属性

## 7.6. 计算 height 和 margin

## 7.7. 最小与最大高度

## 7.8. 行高的计算
