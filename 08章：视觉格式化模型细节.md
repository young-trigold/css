目录：

- [8. 视觉格式化模型细节](#8-视觉格式化模型细节)
  - [8.1. 包含块的定义](#81-包含块的定义)
  - [8.2. width 属性](#82-width-属性)
  - [8.3. 计算 width 和 margin](#83-计算-width-和-margin)
    - [8.3.1. 行内，非替换性元素](#831-行内非替换性元素)
    - [8.3.2. 行内，替换性元素](#832-行内替换性元素)
    - [8.3.3. 块级，非替换性元素，正常流](#833-块级非替换性元素正常流)
    - [8.3.4. 块级，替换性元素，正常流](#834-块级替换性元素正常流)
    - [8.3.5. 浮动，非替换性元素](#835-浮动非替换性元素)
    - [8.3.6. 浮动，替换性元素](#836-浮动替换性元素)
    - [8.3.7. 绝对定位，非替换性元素](#837-绝对定位非替换性元素)
    - [8.3.8. 绝对定位，替换性元素](#838-绝对定位替换性元素)
    - [8.3.9. 行内块级，非替换性元素，正常流](#839-行内块级非替换性元素正常流)
    - [8.3.10. 行内块级，替换性元素，正常流](#8310-行内块级替换性元素正常流)
  - [8.4. 最小与最大宽度](#84-最小与最大宽度)
  - [8.5. height 属性](#85-height-属性)
  - [8.6. 计算 height 和 margin](#86-计算-height-和-margin)
    - [8.6.1. 行内，非替换性元素](#861-行内非替换性元素)
    - [8.6.2. 第 2，4，10，6 点](#862-第-24106-点)
    - [8.6.3. 块级，非替换性元素，正常流](#863-块级非替换性元素正常流)
    - [8.6.4. 绝对定位，非替换性元素](#864-绝对定位非替换性元素)
    - [8.6.5. 复杂情况](#865-复杂情况)
    - [8.6.6. 块格式化背景根的'自动'高度](#866-块格式化背景根的自动高度)
  - [8.7. 最小与最大高度](#87-最小与最大高度)
  - [8.8. 行高的计算](#88-行高的计算)
    - [8.8.1. 领先和半领先](#881-领先和半领先)

# 8. 视觉格式化模型细节

## 8.1. 包含块的定义

一个元素的盒子的位置和大小有时是相对于某个矩形计算的，这个矩形称为元素的 **包含块**。一个元素的包含块定义如下：

1. 根元素所在的包含块是一个被称为 **初始包含块** 的矩形。对于连续媒体，它具有视口的尺寸，并被锚定在画布原点；对于分页媒体，它是页面区域。初始包含块的 "direction" 属性与根元素的相同。
2. 对于其他元素，如果该元素的 position 是 "relative" 或 'static'，则包含块由最近的祖先元素的内容边缘形成，该盒子是一个块容器或建立了一个格式化的上下文。
3. 如果元素有'position: fixed'，在连续媒体的情况下，包含块由视口建立，在分页媒体的情况下，包含块由页面区域建立。
4. 如果该元素有'position: absolute'，包含块由最近的祖先元素建立，其'position'为'absolute'、'relative'或'fixed'，方式如下：
   1. 如果该祖先元素是一个行内元素，那么包含块就是为该元素生成的第一个和最后一个行内盒子的内边距内边距周围的边界。在 CSS 2.2 中，如果行内元素被分割成多行，那么包含块是未定义的。
   2. 否则，包含块是由祖先的内边距边缘形成的。

如果没有这样的祖先元素，包含块就是初始包含块。

在分页媒体中，一个绝对定位的元素是相对于它的包含块定位的，忽略任何分页（就像文档是连续的）。该元素随后可能在几个页面上被分割。

对于绝对定位的内容，如果它被解析到一个页面上的某个位置，而不是正在排版的页面（当前页面），或者被解析到当前页面上已经被渲染打印的位置，打印机可以将内容放在：

- 在当前页的另一个位置上
- 在随后的页面上，或者
- 可以省略它。

请注意，一个被分割在几个页面上的块级元素在每个页面上的宽度可能不同，而且可能有特定的设备限制。

## 8.2. width 属性

| 属性名   | width                                    |
| -------- | ---------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                | <percentage> | auto | inherit` |
| 初始值   | auto                                     |
| 适用元素 | 除了行内非替换性元素，表格行，列组的元素 |
| 可继承性 | 否                                       |
| 百分数值 | 相对于包含块的宽度                       |
| 适用媒体 | 视觉                                     |
| 计算值   | 百分数，auto 见规定，或绝对长度          |

此属性指定了盒子的内容宽度。

这个属性不适用于非替换的行内元素。非替换的行内元素盒子的内容宽度是其内渲染内容的宽度（在任何子元素的相对偏移之前）。回顾一下，行内盒子流向行盒子。行盒子的宽度由其包含块给出，但可能会因为浮子的存在而被缩短。

属性值有以下含义：

- `<length>`
  用长度单位指定内容区的宽度。

- `<percentage>`
  指定一个百分数的宽度。这个百分数是相对于生成的盒子的包含块的宽度计算的。如果包含块的宽度取决于这个元素的宽度，那么产生的布局在 CSS 2.2 中是未定义的。注意：对于绝对定位的元素，其包含的块是基于一个块容器元素的，百分数是相对于该元素的内边距盒子的宽度计算的。这是对 CSS1 的一个改变，在 CSS1 中，百分数宽度总是根据父元素的内容盒子来计算。

- auto
  宽度取决于其他属性的值。见下面的章节。

'width' 的负值是非法的。

## 8.3. 计算 width 和 margin

一个元素的 'width'、'margin-left'、'margin-right'、'left' 和 'right' 属性用于布局的值取决于生成的盒子的类型和相互之间的关系。(用于布局的值有时被称为使用值。)原则上，使用值与计算值相同，'auto' 被一些合适的值取代，百分数根据包含块计算，但也有例外。以下情况需要加以区分：

1. 行内，非替换性元素
2. 行内，替换性元素
3. 块级，非替换性元素，正常流
4. 块级，替换性元素，正常流
5. 浮动，非替换性元素
6. 浮动，替换性元素
7. 绝对定位，非替换性元素
8. 绝对定位，替换性元素
9. 行内块级，非替换性元素，正常流
10. 行内块级，替换性元素，正常流

对于第 1-6 点和第 9-10 点，在相对定位元素的情况下，'left' 和 'right' 的值由[相对定位](#643-相对定位)章节的规则决定。

注意。下面计算的 'width' 的使用值是一个暂定值，可能要计算多次，取决于 'min-width' 和 'max-width'，见下面的最小和最大宽度部分。

### 8.3.1. 行内，非替换性元素

'width' 属性不适用。'margin-left' 或 'margin-right' 的计算值 'auto' 会变成一个使用值 '0'。

### 8.3.2. 行内，替换性元素

如果 'margin-left' 或 'margin-right' 的计算值为 'auto'，则使用值为 '0'。

如果 'height' 和 'width' 的计算值都是 'auto'，并且该元素也有一个固有的宽度，那么这个固有的宽度就是 'width'的使用值。

如果 'height' 和 'width' 的计算值都是 'auto'，元素没有固有宽度，但有固有高度和固有比例；或者如果 'width' 的计算值是 'auto'，'height' 有其他计算值，而元素确实有固有比例；那么 'width' 的使用值是：

```
(使用的高度) * (固有比例)
```

如果 'height' 和 'width' 的计算值都是 'auto'，而元素有一个固有比例，但没有固有高度或宽度，那么 'width' 的使用值在 CSS 2.2 中是未定义的。然而，我们建议，如果包含块的宽度本身并不取决于替换性元素的宽度，那么 'width' 的使用值将从正常流中用于块级非替换元素的约束方程中计算。

否则，如果 'width' 的计算值为 'auto'，而该元素有一个固有宽度，那么这个固有宽度就是 'width' 的使用值。

否则，如果 'width' 的计算值是 'auto'，但没有满足上述条件，那么 'width' 的使用值就变成 300px。如果 300px 太宽而无法适应设备，那么 UA 应该使用具有 2:1 比例且适合设备的最大矩形的宽度来代替。

### 8.3.3. 块级，非替换性元素，正常流

在其他属性的使用值中，以下约束必须成立：

```
'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' = 包含块的宽度
```

如果 'width' 不是 'auto'，并且 'border-left-width'+'padding-left'+'width'+'padding-right'+'border-right-width'（加上任何不是'auto'的'margin-left'或'margin-right'）大于包含块的宽度，那么对于以下规则，任何 'margin-left '或 'margin-right' 的 auto 值将被视为 0。

如果上述所有的计算值都不是 'auto'，那么这些值被称为 "过度约束"，其中一个使用值将不得不与它的计算值不同。如果包含块的 'direction' 属性的值是 'ltr'，那么 'margin-right' 的指定值就会被忽略，该值会被计算出来，以便使方程两边相等。如果 'direction' 的值是 'rtl'，这将发生在 'margin-left' 上。

如果正好有一个值被指定为 'auto'，那么它的使用值就会从方程中产生。

如果 'width' 被设置为 'auto'，任何其他的 'auto' 值都会变成 '0'，而 'width' 会从方程中产生。

如果 'margin-left' 和 'margin-right' 都是 'auto'，它们的使用值是相等的。这将使元素在水平方向上相对于包含块的边缘居中。

### 8.3.4. 块级，替换性元素，正常流

'width' 的使用值被确定为行内替换性元素。然后应用非替换性块级元素的规则来确定外边距。

### 8.3.5. 浮动，非替换性元素

如果 'margin-left' 或' margin-right' 被计算为 'auto'，它们的使用值是 '0'。

如果 'width' 被计算为 'auto'，使用值是“收缩到适合”的宽度。

收缩宽度的计算与使用自动表格布局算法计算表格单元的宽度类似。大致是：通过格式化内容，计算出首选的宽度，除了明确的换行之外，不需要换行，还可以计算出首选的最小宽度，例如，通过尝试所有可能的换行。CSS 2.2 并没有定义确切的算法。第三，找到可用的宽度：在这种情况下，这是包含块的宽度减去 "margin-left"、"border-left-width"、"padding-left"、"padding-right"、"border-right-width"、"margin-right "的使用值，以及任何相关滚动条的宽度。

然后，收缩到合适的宽度是：min(max(首选最小宽度，可用宽度), 首选宽度)。

### 8.3.6. 浮动，替换性元素

如果 'margin-left' 或 'margin-right' 被计算为 'auto'，它们的使用值是 '0'。'width' 的使用值与行内替换性的元素一样确定。

### 8.3.7. 绝对定位，非替换性元素

在本节和下一节中，术语“静态位置”（一个元素）大致指一个元素在正常流动中的位置。更确切地说：

- **静态位置的包含块** 是一个假设的盒子的包含块，如果其指定的 'position' 值为 'static'，其指定的 'float' 为 'none'，则该盒子将成为该元素的第一个盒子。

- 'left' 的静态位置是指如果元素的 'position' 属性为 'static'，'float' 为 'none'，那么从包含块的左边缘到一个假设的盒子的左边缘的距离，这个盒子将是元素的第一个盒子。如果假设的盒子是在包含块的左边，那么这个值是负的。

- 'right' 的静态位置是指从包含块的右边缘到上述同一假设盒子的右边缘的距离。如果假设的盒子在包含块边缘的左边，这个值就是正的。

但是，用户代理并没有实际计算该假设盒子的尺寸，而是自由地猜测其可能的位置。

为了计算静态位置，固定位置元素的包含块是初始包含块，而不是视口，所有可滚动的盒子都应该被假定为滚动到原点。

决定这些元素的使用值的约束条件是：

```
'left' + 'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + 'right' = 包含块的宽度
```

如果 'left'、'width'、'right'三者都是'auto'。首先将'margin-left'和'margin-right'的任何'auto'值设置为 0。然后，如果建立静态位置的元素的'direction'属性是'ltr'，则将'left'设置为静态位置，并应用下面的第三条规则；否则，将'right'设置为静态位置，并应用下面的第一条规则。

如果这三条都不是'auto'：如果'margin-left'和'margin-right'都是'auto'，在两个边距得到相等值的额外约束下求解方程，除非这会使它们变成负值，在这种情况下，当包含块的方向是'ltr'（'rtl'），将'margin-left'（'margin-right'）设置为 0，求解为'margin-right'（'margin-left'）。如果'margin-left'或'margin-right'中的一个是'auto'，求解该值的方程。如果数值被过度限制，忽略'left'（如果包含块的'direction'属性是'rtl'）或'right'（如果'direction'是'ltr'）的数值，并求解该数值。

否则，将'margin-left'和'margin-right'的'auto'值设置为 0，并从以下六条规则中选择一条适用。

1. 'left'和'width'都是'auto'，而'right'不是'auto'，那么宽度就会被收缩到合适的范围。然后解决'left'的问题
2. 'left'和'right'是'auto'，'width'不是'auto'，那么如果建立静态位置的元素的'direction'属性是'ltr'，则将 3. 'left'设为静态位置，否则将'right'设为静态位置。然后求解'left'（如果'方向是'rtl'）或'right'（如果'direction'是'ltr'）。
3. 如果'width'和'right'是'auto'，而'left'不是'auto'，那么宽度就会被收缩到合适的位置。然后求解'right'。
4. 'left'是'auto'，'width'和'right'不是'auto'，那么求解'left'。
5. 'width'是'auto'，'left'和'right'都不是'auto'，那么求'width'。
6. 'right'是'auto'，'left'和'width'不是'auto'，那么求'right'。

收缩至合适宽度的计算与使用自动表格布局算法计算表格单元的宽度类似。大致是：通过格式化内容，计算首选的宽度，除了明确的换行之外，不需要换行，同时计算首选的最小宽度，例如，尝试所有可能的换行。CSS 2.2 并没有定义确切的算法。第三，计算可用的宽度：在将 'left'（情况 1）或 'right'（情况 3）设置为 0 之后，通过求解 'width' 来找到。

然后，收缩到合适的宽度是：min(max(首选最小宽度，可用宽度)，首选宽度)。

### 8.3.8. 绝对定位，替换性元素

在这种情况下，上一节节适用于包括约束方程在内的所有内容，但上一节的其余部分被以下规则所取代：

1. 'width'的使用值与行内替换元素一样确定。如果'margin-left'或'margin-right'被指定为'auto'，其使用值由以下规则决定。
2. 如果'left'和'right'的值都是'auto'，那么如果建立静态位置包含块的元素的'direction'属性是'ltr'，将'left'设置为静态位置；否则如果'direction'是'rtl'，将'right'设置为静态位置。
3. 如果'left'或'right'是'auto'，将'margin-left'或'margin-right'上的任何'auto'改为'0'。
4. 如果此时'margin-left'和'margin-right'仍然是'auto'，在两个边距必须相等的额外约束下求解方程，除非这将使它们变成负值，在这种情况下，当包含块的方向是'ltr'（'rtl'），将'margin-left'（'margin-right'）设置为 0，并求解'margin-right'（'margin-left'）。
5. 如果这时有一个'auto'的左边，求解这个值的方程。
6. 如果这时数值被过度限制，忽略'left'（如果包含块的'方向'属性是'rtl'）或'right'（如果'方向'是'ltr'）的数值并求解该数值。

### 8.3.9. 行内块级，非替换性元素，正常流

如果'width'是'auto'，使用的值是浮动元素的收缩宽度。

如果'margin-left'或'margin-right'的计算值为'auto'，则使用值为'0'。

### 8.3.10. 行内块级，替换性元素，正常流

与行内替换性元素完全相同。

## 8.4. 最小与最大宽度

| 属性名   | min-width                                |
| -------- | ---------------------------------------- | ------------ | -------- |
| 值       | `<length>                                | <percentage> | inherit` |
| 初始值   | 0                                        |
| 适用元素 | 除了行内非替换性元素，表格行，列组的元素 |
| 可继承性 | 否                                       |
| 百分数值 | 相对于包含块的宽度                       |
| 适用媒体 | 视觉                                     |
| 计算值   | 百分数，auto 见规定，或绝对长度          |

| 属性名   | max-width                                |
| -------- | ---------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                | <percentage> | none | inherit` |
| 初始值   | none                                     |
| 适用元素 | 除了行内非替换性元素，表格行，列组的元素 |
| 可继承性 | 否                                       |
| 百分数值 | 相对于包含块的宽度                       |
| 适用媒体 | 视觉                                     |
| 计算值   | 百分数，auto 见规定，或绝对长度          |

这两个属性允许作者将内容宽度限制在一定范围内。值有以下含义：

- `<length>`
  指定一个固定的最小或最大使用宽度。
- `<percentage>`
  指定用于确定使用值的百分比。这个百分比是相对于生成的盒子的包含块的宽度计算的。如果包含块的宽度为负数，则使用值为 0。如果包含块的宽度取决于这个元素的宽度，那么生成的布局在 CSS 2.2 中是未定义的。
- none
  (仅适用于'max-width'）对盒子的宽度没有限制。

'min-width' 和 'max-width' 的负值是非法的。

在 CSS 2.2 中，'min-width' 和'max-width'对表格、行内表格、表格单元格、表格列和列组的影响是未定义的。

下面的算法描述了这两个属性如何影响 'width' 属性的使用值。

暂时使用的宽度是按照上面 "计算宽度和边距 "的规则计算的（不包括'min-width'和'max-width'）。
如果暂定使用的宽度大于'max-width'，则再次应用上述规则，但这次使用'max-width'的计算值作为'width'的计算值。
如果结果宽度小于'min-width'，则再次应用上面的规则，但这次使用'min-width'的值作为'width'的计算值。
这些步骤并不影响上述属性的真实计算值。

然而，对于有内在比例的替换性元素，并且'width'和'height'都指定为'auto'，算法如下：

从表中选择适当的违反约束的高度和宽度的解析值。将最大宽度和最大高度作为 max(min, max)，使 min≤max 成立。在这个表中，w 和 h 代表宽度和高度的计算结果，忽略了 "最小宽度"、"最小高度"、"最大宽度 "和 "最大高度 "属性。通常情况下，这些是内在的宽度和高度，但在有内在比例的替换元素的情况下，它们可能不是。

注意：在设置了明确的宽度或高度，而其他维度是自动的情况下，在自动侧应用最小或最大约束会导致过度约束的情况。规范中的行为是明确的，但可能不是作者所期望的。在这种情况下，可以使用 CSS3 对象拟合属性来获得不同的结果。

| 违反约束的情况 | 解决的宽度 | 解决的高度 |
| -------------- | ---------- | ---------- |
| none           | w          | h          |

w > max-width max-width max(max-width _ h/w, min-height)
w < min-width min-width min(min-width _ h/w, max-height)
h > max-height max(max-height _ w/h, min-width) max-height
h < min-height min(min-height _ w/h, max-width) min-height
(w>最大宽度)和(h>最大高度)，其中(最大宽度/w≤ 最大高度/h) 最大宽度 max(最小高度，最大宽度*h/w)
(w>最大宽度)和(h>最大高度)，其中(max-width/w>max-height/h) max(min-width, max-height * w/h) max-height
(w < 最小宽度) 和 (h < 最小高度)，其中 (最小宽度/w ≤ 最小高度/h) min(最大宽度，最小高度 _ w/h) 最小高度
(w<最小宽度)和(h<最小高度)，其中(最小宽度/w>最小高度/h) min-width min(max-height, min-width _ h/w)
(w < min-width) and (h > max-height) min-width max-height
(w>最大宽度)和(h<最小高度)最大宽度最小高度
然后应用上面 "计算宽度和边距 "下的规则，就像'width'被计算为这个值一样。

## 8.5. height 属性

| 属性名   | height                                   |
| -------- | ---------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                | <percentage> | auto | inherit` |
| 初始值   | auto                                     |
| 适用元素 | 除了行内非替换性元素，表格行，列组的元素 |
| 可继承性 | 否                                       |
| 百分数值 | 见规范                                   |
| 适用媒体 | 视觉                                     |
| 计算值   | 百分数，auto 见规定，或绝对长度          |

此属性指定了盒子的内容高度。

此属性不适用于非替换的行内元素。请参阅关于计算非替换的行内元素的高度和边距的章节，了解所使用的规则。

值有以下含义。

<length></length>
用一个长度值来指定内容区的高度。
<percentage>
指定一个百分比的高度。这个百分比是相对于生成的方框的包含块的高度计算的。如果没有明确指定包含块的高度（即取决于内容高度），并且这个元素不是绝对定位的，那么所使用的高度就像指定了'auto'那样被计算。根元素上的百分比高度是相对于初始包含块的。注意：对于绝对定位的元素，其包含块是基于块级元素的，百分比的计算是相对于该元素的填充框的高度。这是对 CSS1 的一个改变，在 CSS1 中，百分比总是相对于父元素的内容框来计算的。
自动
的高度取决于其他属性的值。见下面的散文。
请注意，绝对定位元素的包含块的高度与元素本身的大小无关，因此这样的元素上的百分比高度总是可以被解决。然而，可能在文档中较晚的元素被处理之前，高度是不知道的。

高度 "的负值是非法的。

例如，下面的规则将段落的内容高度设置为 100 像素。

```css
p {
  height: 100px;
}
```

内容高度超过 100 像素的段落将根据'overflow'属性溢出。

## 8.6. 计算 height 和 margin

为了计算 "top"、"margin-top"、"height"、"margin-bottom "和 "bottom "的值，必须区分各种类型的盒子。

1. 行内，非替换性元素
2. 行内，替换性元素
3. 块级，非替换性元素，正常流
4. 块级，替换性元素，正常流
5. 浮动，非替换性元素
6. 浮动，替换性元素
7. 绝对定位，非替换性元素
8. 绝对定位，替换性元素
9. 行内块级，非替换性元素，正常流
10. 行内块级，替换性元素，正常流

对于 1-6 和 9-10 点，'top'和'bottom'的使用值由[相对定位](#743-相对定位)的规则决定。

注意：这些规则适用于根元素，就像适用于任何其他元素一样。

请注意。下面计算的'高度'的使用值是一个暂定值，可能要计算多次，取决于'最小高度'和'最大高度'，见下面的最小和最大高度部分。

### 8.6.1. 行内，非替换性元素

高度 "属性并不适用。内容区的高度应该基于字体，但本规范没有规定如何确定。UA 可以，例如，使用 em-box 或字体的最大升序和降序。(后者可以确保部分高于或低于 em-box 的字形仍然落在内容区域内，但会导致不同字体的盒子大小不同；前者可以确保作者可以控制相对于 "行高 "的背景样式，但会导致字形被画在内容区域之外）。

注意：CSS 的第 3 级可能会包括一个属性，用于选择内容高度所使用的字体尺度。

一个行内的、未被替换的方框的垂直填充、边框和边距从内容区域的顶部和底部开始，与 "行高 "无关。但在计算行框的高度时，只使用'行高'。

如果使用了一种以上的字体（当字形出现在不同的字体中时可能会发生这种情况），本规范没有定义内容区的高度。然而，我们建议选择这样的高度，即内容区的高度刚好能满足（1）em-boxes，或（2）元素中所有字体的最大升序和降序。请注意，这个高度可能会大于所涉及的任何字体大小，这取决于字体的基线对齐情况。

### 8.6.2. 第 2，4，10，6 点

如果'margin-top'或'margin-bottom'是'auto'，它们的使用值是 0。

如果'height'和'width'的计算值都是'auto'，并且该元素也有一个固有的高度，那么这个固有的高度就是'height'的使用值。

否则，如果'height'的计算值是'auto'，而该元素有一个内在的比率，那么'height'的使用值是。

(使用的宽度) / (内在的比率)

否则，如果'height'的计算值是'auto'，而元素有一个固有的高度，那么这个固有的高度就是'height'的使用值。

否则，如果'height'的计算值为'auto'，但不符合上述条件，那么'height'的使用值必须被设置为最大的矩形的高度，该矩形的比例为 2：1，高度不超过 150px，宽度不超过设备宽度。

### 8.6.3. 块级，非替换性元素，正常流

本节也适用于正常流程中的块级非替换元素，当'overflow'没有计算到'visible'，但已经被传播到视口。

如果'margin-top'或'margin-bottom'是'auto'，它们的使用值是 0。 如果'height'是'auto'，高度取决于该元素是否有任何块级的子元素以及是否有填充或边界。

该元素的高度是其顶部内容边缘到以下第一个适用的距离。

最后一行框的底边，如果该框建立了一个或多个行的行内格式化环境的话
如果子元素的底边不与元素的底边一起折叠，则为其最后一个内流子元素的底边（可能是折叠的）的底边
最后一个内流子元素的底边，该元素的上边距不与该元素的底边距一起折叠。
零，否则
只有正常流程中的子代被考虑在内（即浮动框和绝对位置的框被忽略，相对位置的框被考虑，但不考虑其偏移）。请注意，子框可能是一个匿名的块框。

### 8.6.4. 绝对定位，非替换性元素

在本节和下一节中，术语 "静态位置"（一个元素）大致是指一个元素在正常流程中的位置。更准确地说，"top "的静态位置是指从包含块的顶部边缘到一个假设的盒子的顶部边缘的距离，如果它指定的 "position "值是 "static"，它指定的 "float "是 "none"，它指定的 "clear "是 "none"，那么这个盒子将成为该元素的第一个盒子。(注意，由于第 9.7 节的规则，这可能需要为'display'假设一个不同的计算值）。如果假设的盒子在包含块的上方，那么这个值就是负的。

但是，用户代理可以自由地猜测其可能的位置，而不是实际计算那个假设的盒子的尺寸。

为了计算静态位置，固定位置的元素的包含块是初始包含块，而不是视口。

对于绝对位置的元素，垂直尺寸的使用值必须满足这个约束条件。

top' + 'margin-top' + 'border-top-width' + 'padding-top' + 'height' + 'padding-bottom' + 'border-bottom-width' + 'margin-bottom' + 'bottom' = 包含块的高度

如果'top'、'height'和'bottom'三者都是自动的，就把'top'设置为静态位置并应用下面的第三条规则。

如果三者都不是自动的：如果'margin-top'和'margin-bottom'都是自动的，在两个边距得到相等值的额外约束下解决这个方程。如果'margin-top'或'margin-bottom'中的一个是'auto'，就用这个值解方程。如果这些值被过度约束，忽略'底部'的值，用该值求解。

否则，从以下六条规则中选择一条适用。

'top'和'height'是'auto'，'bottom'不是'auto'，那么高度是基于 10.6.7 的内容，将'margin-top'和'margin-bottom'的'auto'值设为 0，并求解'top'。
'top'和'bottom'是'auto'，'height'不是'auto'，那么将'top'设置为静态位置，将'margin-top'和'margin-bottom'的'auto'值设置为 0，并求解'bottom'。
'height'和'bottom'都是'auto'，而'top'不是'auto'，那么高度将基于 10.6.7 中的内容，将'margin-top'和'margin-bottom'的'auto'值设置为 0，并求解'bottom'。
'top'是'自动'，'height'和'bottom'不是'自动'，那么将'margin-top'和'margin-bottom'的'自动'值设为 0，并求解'top'。
高度 "是 "自动"，"顶部 "和 "底部 "不是 "自动"，那么 "margin-top "和 "margin-bottom "的 "自动 "值被设置为 0，然后求解 "高度"。
底部 "是 "自动"，"顶部 "和 "高度 "不是 "自动"，那么将 "margin-top "和 "margin-bottom "的 "自动 "值设置为 0，然后求解 "底部"。
10.6.5 绝对定位的、被替换的元素
这种情况与上一种情况类似，只是元素有一个固有的高度。现在的替换顺序是。

高度 "的使用值和行内替换元素一样被确定。如果'margin-top'或'margin-bottom'被指定为'auto'，其使用值由以下规则决定。
如果'top'和'bottom'的值都是'auto'，用元素的静态位置替换'top'。
如果'bottom'是'auto'，用'0'替换'margin-top'或'margin-bottom'上的任何'auto'。
如果此时'margin-top'和'margin-bottom'仍然是'auto'，在两个边距必须得到相等的值的额外约束下解方程。
如果这时只剩下一个'自动'，就用这个值解方程。
如果在这一点上，数值被过度限制，忽略'底部'的数值，并对该数值进行求解。

### 8.6.5. 复杂情况

本节适用于。

当'overflow'不计算为'visible'时，正常流程中的块级、非替换的元素（除非'overflow'属性的值已经传播到视口）。
'Inline-block'，非置换元素。
浮动的、非替换的元素。
如果'margin-top'或'margin-bottom'是'auto'，它们的使用值是 0。如果'height'是'auto'，高度取决于该元素的子元素，根据 10.6.7。

对于'inline-block'元素，在计算线框的高度时，会使用 margin box。

### 8.6.6. 块格式化背景根的'自动'高度

在某些情况下（例如，见上文 10.6.4 和 10.6.6 节），建立块格式化上下文的元素的高度计算如下。

如果它只有行内级的子元素，其高度是最上面的行框的顶部和最下面的行框的底部之间的距离。

如果它有块级的子代，高度是最上面的块级子代框的上边距和最下面的块级子代框的下边距之间的距离。

绝对位置的子框被忽略，相对位置的子框被认为没有其偏移。请注意，子框可能是一个匿名的块框。

此外，如果该元素有任何浮动的后代，其底部边缘低于该元素的底部内容边缘，那么高度将被增加，以包括这些边缘。只有参与这个块格式化上下文的浮子才会被考虑在内，例如，绝对定位的子代内的浮子或其他浮子不会被考虑。

## 8.7. 最小与最大高度

有时将元素的高度限制在某个范围内是很有用的。有两个属性提供了这个功能。

| 属性名   | min-height                                                                           |
| -------- | ------------------------------------------------------------------------------------ | ------------ | -------- |
| 值       | `<length>                                                                            | <percentage> | inherit` |
| 初始值   | 0                                                                                    |
| 适用元素 | 所有元素，但具有除 table-caption、table 和 inline-table 以外的表格显示类型的元素除外 |
| 可继承   | 否                                                                                   |
| 百分数   | 见规范                                                                               |
| 计算值   | 指定的百分数或绝对长度                                                               |

| 属性名   | max-height                                                                           |
| -------- | ------------------------------------------------------------------------------------ | ------------ | ---- | -------- |
| 值       | `<length>                                                                            | <percentage> | none | inherit` |
| 初始值   | 0                                                                                    |
| 适用元素 | 所有元素，但具有除 table-caption、table 和 inline-table 以外的表格显示类型的元素除外 |
| 可继承   | 否                                                                                   |
| 百分数   | 见规范                                                                               |
| 计算值   | 指定的百分数或绝对长度                                                               |

这两个属性允许作者将盒子的高度限制在一个特定的范围内。值有以下含义。

<length></p><p><p>指定一个固定的最小或最大的计算高度。
指定一个固定的最小或最大计算高度。
<百分比>
指定用于确定使用值的百分比。这个百分比是相对于生成的方框的包含块的高度计算的。如果没有明确指定包含块的高度（即取决于内容高度），并且这个元素不是绝对定位的，百分比值将被视为'0'（对于'最小高度'）或'无'（对于'最大高度'）。
无
(仅在'max-height'上）对盒子的高度没有限制。
最小高度 "和 "最大高度 "的负值是非法的。

在 CSS 2.2 中，'最小高度'和'最大高度'对表格、行内表格、表格单元格、表格行和行组的影响是未定义的。

下面的算法描述了这两个属性如何影响'高度'属性的使用值。

暂时使用的高度是按照上面 "计算高度和边距 "的规则计算的（不包括'最小高度'和'最大高度'）。
如果这个暂定高度大于'max-height'，上述规则将再次被应用，但这次使用'max-height'的值作为'height'的计算值。
如果得出的高度小于'min-height'，上述规则将再次被应用，但这次使用'min-height'的值作为'height'的计算值。
这些步骤不会影响'高度'的真实计算值。因此，举例来说，它们不会影响边缘的折叠，因为边缘的折叠取决于计算值。

然而，对于'宽度'和'高度'都计算为'自动'的被替换元素，使用上面最小和最大宽度下的算法来找到使用的宽度和高度。然后应用上面 "计算高度和边距 "下的规则，使用所得的宽度和高度，就像它们是计算值一样。

## 8.8. 行高的计算

正如在关于行内格式化上下文的章节中所描述的，用户代理将行内级的方框流入垂直堆叠的行方框。行框的高度是按以下方式确定的。

行框中每个行内级框的高度被计算。对于被替换的元素、inline-block 元素和 inline-table 元素，这是其边框的高度；对于行内框，这是其 "行高"。(见 "计算高度和边距 "和 "领先和半领先 "中的行内框高度）。
行内框根据其'垂直对齐'属性垂直对齐。如果它们是 "顶部 "或 "底部 "对齐的，它们的对齐方式必须使行框的高度最小。如果这样的盒子足够高，有多种解决方案，而且 CSS 2.2 并没有定义线框的基线位置（即支线的位置，见下文）。
线条框的高度是最上面的框顶和最下面的框底之间的距离。(这包括支杆，在下面的 "线高 "中解释）。
空的行内元素产生空的行内框，但这些框仍然有边距、填充、边框和行高，因此像有内容的元素一样影响这些计算。

### 8.8.1. 领先和半领先

CSS 假定每一种字体都有字体度量，指定了基线以上的特征高度和基线以下的深度。在本节中，我们用 A 来表示这个高度（对于一个给定尺寸的字体），用 D 表示深度。我们还定义了 AD=A+D，即从顶部到底部的距离。(注意，这些都是字体整体的度量，不需要与任何单个字形的升序和降序相对应。

用户代理必须通过其相关的基线将非替换的行内框中的字形相互对齐。然后，为每个字形确定 A 和 D。请注意，单个元素中的字形可能来自不同的字体，因此不一定都有相同的 A 和 D。如果行内框根本不包含字形，它将被视为包含一个具有该元素第一个可用字体的 A 和 D 的支柱（宽度为零的不可见字形）。

还是对每个字形，确定要添加的前导 L，其中 L='行高'-AD。一半的前导被添加到 A 上面，另一半添加到 D 下面，从而使字形及其前导在基线以上的总高度为 A'=A+L/2，总深度为 D'=D+L/2。

注意。L 可以是负数。

行内框的高度包括了所有字形及其每边的半引号，因此正好是 "线高"。子元素的盒子不影响这个高度。

尽管非替换元素的边距、边框和填充物不进入行框的计算，但它们仍然在行内框周围被渲染。这意味着，如果'line-height'指定的高度小于所包含的盒子的内容高度，那么填充物和边框的背景和颜色可能会 "渗入 "相邻的线框中。用户代理应该按照文档顺序渲染方框。这将导致后面几行的边框在前面几行的边框和文本上涂抹。

注意。CSS 2.2 没有定义行内框的内容区域是什么（见上文 10.6.1），因此不同的用户代理可能会在不同的地方绘制背景和边框。

注意。建议使用 OpenType 或 TrueType 字体的实现者使用字体 OS/2 表中的 A 和 D 的度量 "sTypoAscender "和 "sTypoDescender"（在缩放到当前元素的字体大小后）。如果没有这些指标，应该使用 HHEA 表中的 "Ascent "和 "Descent "指标。

| 属性名   | line-height                                       |
| -------- | ------------------------------------------------- | -------- | -------- | ------------ | -------- |
| 值       | `normal                                           | <number> | <length> | <percentage> | inherit` |
| 初始值   | normal                                            |
| 适用元素 | 所有元素                                          |
| 可继承   | 否                                                |
| 百分数   | 相对于元素本身的字体大小                          |
| 计算值   | `<length>` 和 `<percentage>` 为绝对值，其他见规范 |

在一个内容由行内级元素组成的块状容器元素上，'line-height'指定了该元素中行框的最小高度。这个最小高度由基线以上的最小高度和基线以下的最小深度组成，完全就像每个行框从一个零宽度的行内框开始，具有该元素的字体和行高属性。我们把这个假想的盒子称为 "支杆"。(这个名字是受 TeX 的启发）。

基线上下的字体的高度和深度被假定为包含在字体中的度量。(更多细节，请参见 CSS 第 3 级）。

在一个非替换的行内元素上，'line-height'指定了计算线框高度时使用的高度。

这个属性的值有以下含义。

正常
告诉用户代理，根据元素的字体，将使用的值设置为一个 "合理 "的值。该值与<number>的含义相同。我们建议'normal'的使用值在 1.0 到 1.2 之间。计算值是'正常'。
<length>（长度
在计算线框高度时使用指定的长度。负值是非法的。
<数>
该属性的使用值是这个数字乘以元素的字体大小。负值是非法的。计算出来的值与指定的值相同。
<百分数>
该属性的计算值是这个百分比乘以该元素的计算字体大小。负值是非法的。
下面例子中的三个规则有相同的结果线高。

div { line-height: 1.2; font-size: 10pt } /_ 数字 _/
div { line-height: 1.2em; font-size: 10pt } /_长度_/_。 /_ 长度 */
div { line-height: 120%; font-size: 10pt }/*百分比*/\*\*。 /* 百分比 \*/
当一个元素包含以多种字体呈现的文本时，用户代理可以根据最大的字体大小来确定 "正常 "的 "行高 "值。

注意。当一个块状容器框中的所有行内框只有一个'行高'值，并且它们都是相同的字体（并且没有替换的元素、行内框元素等），上述做法将确保连续的行的基线正好相隔'行高'。当不同字体的文本列必须对齐时，这一点很重要，例如在一个表格中。

| 属性名   | vertical-align                                    |
| -------- | ------------------------------------------------- | --- | ----- | --- | -------- | ------ | ------ | ----------- | ------------ | -------- | -------- |
| 值       | ` baseline                                        | sub | super | top | text-top | middle | bottom | text-bottom | <percentage> | <length> | inherit` |
| 初始值   | baseline                                          |
| 适用元素 | 行内级和表格单元格                                |
| 可继承   | 否                                                |
| 百分数   | 相对于元素本身的行高                              |
| 计算值   | `<length>` 和 `<percentage>` 为绝对值，其他见规范 |

此属性影响线框内由 inline-level 元素生成的方框的垂直定位。

注意。此属性的值在表格的背景下有不同的含义。详情请参考表格高度算法一节。

下面的值只对父元素行内元素有意义，或对父元素块状容器元素的支柱有意义。

在下面的定义中，对于行内非替换元素，用于对齐的盒子是高度为 "行高 "的盒子（包含盒子的字形和每边的半引号，见上文）。对于所有其他元素，用于对齐的方框是边距方框。

基线
将方框的基线与父方框的基线对齐。如果盒子没有基线，则将底部边缘与父盒子的基线对齐。
中间
将盒子的垂直中点与父盒子的基线加上父盒子的一半 X 高度对齐。
子
将方框的基线降低到父方框的下标的适当位置。(这个值对元素文本的字体大小没有影响)。
超级
将方框的基线提高到父方框的上标的适当位置。(这个值对元素文本的字体大小没有影响。)
text-top
将盒子的顶部与父元素内容区的顶部对齐（见 10.6.1）。
text-bottom
将方框的底部与父内容区的底部对齐（见 10.6.1）。
<百分数
将方框提高（正值）或降低（负值）这个距离（"行高 "值的百分比）。值'0%'意味着与'基线'相同。
<length>（长度
将方框提高（正值）或降低（负值）这个距离。值'0cm'表示与'基线'相同。
下面的值是将元素相对于线框对齐。由于该元素可能有相对于它对齐的子元素（这些子元素又可能有相对于它们对齐的子元素），这些值使用对齐子树的边界。一个行内元素的对齐子树包含该元素和所有子联元素的对齐子树，其计算的'垂直对齐'值不是'顶'或'底'。对齐的子树的顶部是子树中方框顶部的最高值，底部也是类似的。

顶部
将对齐的子树的顶部与线框的顶部对齐。
底部
将已对齐的子树的底部与线框的底部对齐。
inline-table "的基线是该表第一行的基线。

一个'inline-block'的基线是它在正常流程中最后一个行框的基线，除非它没有内流行框，或者它的'overflow'属性的计算值不是'visible'，在这种情况下，基线是底部边缘。
