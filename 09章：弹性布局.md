**目录：**

- [9. 弹性布局](#9-弹性布局)
  - [9.1. 弹性盒子盒模型以及术语](#91-弹性盒子盒模型以及术语)
  - [9.2. 弹性容器](#92-弹性容器)
  - [9.3. 弹性子项](#93-弹性子项)
    - [9.3.1. 绝对定位的弹性子项](#931-绝对定位的弹性子项)
    - [9.3.2. 弹性子项的内外边距](#932-弹性子项的内外边距)
    - [9.3.3. 弹性子项 Z-轴顺序](#933-弹性子项-z-轴顺序)
    - [9.3.4. 折叠子项](#934-折叠子项)
    - [9.3.5. 弹性子项的自动最小大小](#935-弹性子项的自动最小大小)
  - [9.4. 顺序和方向](#94-顺序和方向)
    - [9.4.1. flex-direction 属性](#941-flex-direction-属性)
    - [9.4.2. flex-wrap 属性](#942-flex-wrap-属性)
    - [9.4.3. flex-flow 属性](#943-flex-flow-属性)
    - [9.4.4. order 属性](#944-order-属性)
      - [9.4.4.1. 重新排序和可访问性](#9441-重新排序和可访问性)
  - [9.5. 弹性行](#95-弹性行)
  - [9.6. 弹性度](#96-弹性度)
    - [9.6.1. flex 简写属性](#961-flex-简写属性)
    - [9.6.2. flex 简写属性](#962-flex-简写属性)
    - [9.6.3. flex-grow](#963-flex-grow)
    - [9.6.4. flex-shrink](#964-flex-shrink)
    - [9.6.5. flex-basis](#965-flex-basis)
  - [9.7. 对齐](#97-对齐)
    - [9.7.1. 自动外边距对齐](#971-自动外边距对齐)
    - [9.7.2. justify-content 属性](#972-justify-content-属性)
    - [9.7.3. align-items 和 align-self 属性](#973-align-items-和-align-self-属性)
    - [9.7.4. align-content 属性](#974-align-content-属性)
    - [9.7.5. 弹性容器基线](#975-弹性容器基线)
  - [9.8. 弹性布局算法](#98-弹性布局算法)

# 9. 弹性布局

注意：本章为 [Flexible Box Layout Module Level 1](https://www.w3.org/TR/css-flexbox-1/)。

CSS 2.1 定义了四种布局模式：根据盒子与同级和祖先盒子的关系来确定盒子的大小和位置的算法：

- 块布局，设计用于布居文档
- 行内布局，设计用于布局文本
- 表格布局，设计用于以表格的形式布局 2D 数据
- 定位布局，设计用于非常明确的定位，而不考虑文档中的其他元素

本模块引入了一种新的布局模式：**弹性布局**，它是为布局更复杂的应用程序和网页而设计的。

弹性布局从表面上看与块布局相似。它缺乏许多可用于块布局的更复杂的以文本或文档为中心的属性，如浮动和列。作为回报，它获得了简单而强大的工具，用于分配空间，并以网络应用和复杂网页经常需要的方式对齐内容。弹性容器的内容：

- 可以按任何流动方向布局(向左、向右、向下，甚至向上！)。
- 可以在样式层颠倒显示顺序或重新排列(即视觉顺序可以独立于源和语音顺序)。
- 可以沿单一(主)轴线性布局，或沿次要(交叉)轴包装成多个行
- 可以“放缩”它们的尺寸以应对可用的空间
- 可以相对于它们的容器或彼此在副轴(交叉轴)上对齐
- 可以沿主轴动态地折叠或松开，同时保留容器的交叉尺寸

## 9.1. 弹性盒子盒模型以及术语

**弹性容器** 是由一个 display 计算为 flex 或 inline-flex 的元素生成的盒子。弹性容器的流内子项被称为 **弹性子项**，并使用弹性布局模型进行布局。

与块和行内布局不同，其布局计算偏向于块和行流内动方向，而弹性布局则偏向于 **弹性方向**。为了更容易地谈论弹性布局，本节定义了一组与弹性流相关的术语。Flex-flow 值和书写模式决定了这些术语如何映射到物理方向(上/右/下/左)、轴(垂直/水平)和尺寸(宽/高)。

![弹性方向术语](illustrations/flex-direction-terms.svg)

- **主轴/主尺寸**
  弹性容器的 **主轴** 是布置弹性子项的主要轴线。它在 **主尺寸** 上延伸。
- **主起点/主终点**
  弹性子项被放置在容器内，从主起点一侧开始，向主终点一侧前进。
- **主大小/主大小属性**
  弹性容器或弹性子项的宽度或高度(以主尺寸为准)是该盒子的主尺寸。因此，它的主大小属性是它的宽度或高度属性，无论哪一个在主尺寸中。同样，它的最小和最大主尺寸属性是它的最小宽度/最大宽度或最小高度/最大高度属性，以在主尺寸上为准，并确定其最小/最大主尺寸。
- **交叉轴/交叉尺寸**
  垂直于主轴的轴称为十字轴。它在交叉尺寸中延伸。
- **交叉起点/交叉终点**
  弹性行装满物品，从弹性容器的交叉起点一侧开始，向交叉终点一侧放入容器中。
- **交叉大小/交叉大小属性**
  一个弹性容器或弹性子项的宽度或高度，无论哪一个在交叉尺寸中，都是该盒子的交叉尺寸。因此，它的交叉尺寸属性是它的宽度或高度属性，无论哪一个在交叉尺寸中。同样，它的最小和最大交叉尺寸属性是它的最小宽度/最大宽度或最小高度/最大高度属性，以在交叉尺寸中的哪个为准，并确定其最小/最大交叉尺寸。

本规范中使用的其他尺寸术语在 CSS 内在和外在尺寸中定义。[CSS-SIZING-3]

## 9.2. 弹性容器

| 属性名     | display |
| ---------- | ------- | ------------ |
| 新的属性值 | `flex   | inline-flex` |

- **flex**
  这个值会使一个元素产生一个弹性容器，当放置在流布局中时是块级的。
- **inline-flex**
  此值使元素在流布局中产生一个弹性容器，它是行内级的。

一个弹性容器为其内容建立一个新的弹性格式化上下文。这与建立一个块格式化上下文是一样的，只是使用的是弹性布局而不是块布局。例如，浮动盒子不会侵入弹性容器，弹性容器的外边距不会随其内容的外边距折叠。弹性容器为其内容形成一个包含块，就像块容器一样。[CSS21] 'overflow' 属性适用于弹性容器。

弹性容器不是块容器，因此，一些以块布局为假设而设计的属性并不适用于弹性布局。特别是：

- float 和 clear 不会创建浮动或清除弹子项，也不会使其脱离流。

- vertical-align 对弹性子项没有影响。

- ::first-line 和 ::first-letter 伪元素不适用于弹性容器，并且弹性容器不会为其祖先盒子提供第一个格式化的行或第一个字母。

如果一个元素的指定显示方式是 inline-flex，那么它的显示属性在某些情况下会计算为 flex：CSS 2.1 第 9.7 节中的表格被修改为包含一个额外的行，inline-flex 在 "指定值" 列，flex 在 "计算值 "列。

## 9.3. 弹性子项

宽泛地讲，一个弹性容器的弹性子项是代表其流内的内容的盒子。

弹性容器的每个流内子项都成为一个弹性子项，而每个连续的子文本运行序列都被包裹在一个匿名的块容器弹性子项中。然而，如果整个子文本运行序列只包含空白(即可以被 white-space 属性影响的字符)，它反而不会被渲染(就像它的文本节点是 display:none 一样)。

```html
<div style="display:flex">
  <!-- 弹性子项: block child -->
  <div id="item1">block</div>

  <!-- 弹性子项: floated element; floating is ignored -->
  <div id="item2" style="float: left;">float</div>

  <!-- 弹性子项: anonymous block box around inline content -->
  anonymous item 3

  <!-- 弹性子项: inline child -->
  <span>
    item 4
    <!-- 弹性子项s do not split around blocks -->
    <q style="display: block" id="not-an-item">item 4</q>
    item 4
  </span>
</div>
```

![弹性子项的确定](illustrations/弹性子项的确定.png)

请注意，元素间的空白消失了：它没有成为自己的弹性子项，尽管元素间的文本确实被包裹在一个匿名弹性子项中。

还要注意的是，匿名子项的盒子是不可添加样式的，因为没有元素可以分配样式规则。然而，它的内容将从弹性容器中继承样式（如设置 font 属性）。

一个弹性子项为其内容建立了一个独立的格式化上下文。然而，弹性子项本身是弹性级的盒子，而不是块级盒子：它们参与其容器的弹性格式化上下文，而不是块格式化上下文。

注意：阅读本规范的作者可能想跳过下面的盒子生成和静态位置细节。

弹性子项的 'display' 值是块化的：如果生成弹性容器的元素的流内子项的指定 'display' 是一个行内级的值，它就会被计算成块级的等值。(参见 CSS2.1§9.7[CSS21]和 CSS 显示[CSS3-DISPLAY]中关于这种类型的显示值转换的细节）。

注意：某些 'display' 值通常会触发在原始盒子周围创建匿名盒子。如果这样的盒子是一个弹性子项，它首先被封锁，所以匿名盒子的创建将不会发生。例如，两个连续的显示为 table-cell 的弹性子项将成为两个独立的显示为 block 的弹性子项，而不是被包裹成一个匿名表格。

在 `display: table` 的弹性子项中，表格包装盒会成为弹性子项，并且顺序和 align-self 属性适用于它。任何标题框的内容都有助于计算表格包装盒的最小内容和最大内容尺寸。然而，就像宽度和高度一样，灵活的长方形也适用于表格框，具体如下：弹性子项的最终尺寸是通过执行布局来计算的，就像表格包含盒子的边缘和表格框的内容边缘之间的距离都是表格框的边界+填充区域的一部分，而表格框就是弹性子项。

### 9.3.1. 绝对定位的弹性子项

由于它是流外的，一个绝对定位的弹性容器的子项不参与弹性布局。

一个绝对定位的弹性容器的子项的静态位置是这样确定的：假设子项和弹性容器都是固定尺寸的盒子，那么子项的位置就如同它是弹性容器中唯一的弹性子项。为了这个目的，'auto' 外边距被视为 0。

换句话说，一个绝对定位的弹性容器的子项的静态位置矩形是弹性容器的内容盒子，其中静态位置矩形是用于确定绝对定位的盒子的静态位置偏移的对齐容器。

(在块布局中，静态位置矩形对应于 CSS2.1 §10.3.7 中描述的 "假设盒子" 的位置。因为它没有对齐属性，所以 CSS2.1 总是在静态位置矩形中使用绝对定位的盒子的块开始内行开始对齐。请注意，这个定义最终会转移到 CSS 定位模块中）。

这样做的效果是，如果你在一个弹性容器的绝对定位的子项上设置，例如，`align-self: center;`，子项上的自动偏移将使其在弹性容器的横轴上居中。

然而，由于绝对定位的盒子被认为是“固定尺寸”的，'stretch' 的值被视为与 flex-start 相同。

### 9.3.2. 弹性子项的内外边距

相邻弹性子项的外边距不会折叠。

弹性子项上的百分比外边距和内边距，就像块盒子上的外边距和内边距一样，是根据其包含块的行内尺寸来确定的，例如，在水平书写模式下，左/右/上/下的百分比都是根据其包含块的宽度来确定的。

'auto' 外边距在相应的尺寸上扩展以吸收额外的空间。它们可用于对齐，或将相邻的弹性子项分开。请参阅使用 'auto' 外边距进行对齐。

### 9.3.3. 弹性子项 Z-轴顺序

弹性子项与行内块[CSS21]完全相同，只是使用了修改过的文档顺序来代替原始文档顺序，并且除了自动以外的 z-index 值会创建一个堆叠上下文，即使位置是静态的（行为与相对位置完全一样）。

注意：定位在弹性子项之外的子代仍然参与弹性子项建立的任何堆叠上下文。

### 9.3.4. 折叠子项

在弹性子项上指定 `visibility:collapse` 会使其成为一个折叠的弹性子项，产生类似于 table-row 或 table-column 的 visibility:collapse 的效果：折叠的弹性子项被完全从渲染中移除，但会留下一个 "支柱 "以保持弹性行的交叉尺寸稳定。因此，如果一个弹性容器只有一条弹性行，动态折叠或解除折叠的项目可能会改变弹性容器的主尺寸，但保证对其交叉尺寸没有影响，也不会导致页面布局的其他部分 "摇摆"。然而，在折叠后会重新进行弹性行包装，因此具有多条线的弹性容器的交叉尺寸可能会也可能不会改变。

尽管折叠的弹性子项不会被渲染，但它们确实出现在格式化结构中。因此，与 display:none 项[CSS21]不同的是，依赖于方框出现在格式化结构中的效果（如递增计数器或运行动画和过渡）仍然在折叠的项上运行。

为了计算支杆的大小，首先在所有项目都不折叠的情况下进行弹性布局，然后在每个折叠的项目被一个支杆取代的情况下重新运行，该支杆保持了该项目原来的行的交叉尺寸。关于 visibility:collapse 如何与 flex layout 交互的规范性定义，请参见 Flex Layout Algorithm。

注意：在任何弹性子项上使用 visibility:collapse 将导致弹性布局算法在中途重复，重新运行最昂贵的步骤。建议作者继续使用 display:none 来隐藏项目，如果这些项目不会被动态折叠和取消折叠，因为这对布局引擎来说更有效率。(因为当可见性改变时，只有部分步骤需要重复，然而，对于动态情况，仍然推荐使用 "可见性：折叠")。

### 9.3.5. 弹性子项的自动最小大小

注意：代表自动最小尺寸的 'auto' 关键字，是 'min-width' 和 'min-height' 属性的新初始值。该关键字以前在本规范中定义，但现在在 CSS 尺寸模块中定义。

为了给弹性子项提供一个更合理的默认最小尺寸，在不是滚动容器的弹性子项上，主轴自动最小尺寸的使用值是基于内容的最小尺寸；对于滚动容器，自动最小尺寸照例是 0。

一般来说，弹性子项的基于内容的最小尺寸是其内容尺寸建议和其指定尺寸建议中较小的一个。然而，如果盒子有一个长宽比并且没有指定的尺寸，其基于内容的最小尺寸是其内容尺寸建议和其转移尺寸建议中的较小者。如果盒子既没有指定尺寸建议，也没有长宽比，其基于内容的最小尺寸就是内容尺寸建议。

在此计算中使用的内容尺寸建议、指定尺寸建议和转移尺寸建议考虑了相关的最小/最大/首选尺寸属性，以便基于内容的最小尺寸不干扰任何作者提供的约束，并定义如下：

- **指定尺寸建议**
  如果项目的计算的主要尺寸属性是确定的，那么指定的尺寸建议就是该尺寸（如果它是确定的，则由其最大主要尺寸属性钳制）。否则，它是未定义的。
- **转移的尺寸建议**
  如果项目有一个内在的长宽比，并且它的计算的交叉尺寸属性是确定的，那么转移的尺寸建议是那个尺寸（如果它的最小和最大交叉尺寸属性是确定的，则由其夹紧），通过长宽比转换。否则，它是未定义的。
- **内容尺寸建议**
  内容尺寸建议是主轴中的最小内容尺寸，如果它有长宽比，则由通过长宽比转换的任何明确的最小和最大交叉尺寸属性钳制，然后由最大主尺寸属性进一步钳制，如果该属性是明确的。

为了计算盒子的固有尺寸（例如盒子的最小内容尺寸），基于内容的最小尺寸导致盒子在该轴上的尺寸变得不确定（即使例如其宽度属性指定了一个确定的尺寸）。请注意，这意味着针对该尺寸计算的百分比将表现为自动。

尽管如此，尽管在某些情况下可能需要额外的布局传递来重新解决百分比问题，但这个值（就像[CSS-SIZEING-3]中定义的 min-content、max-content 和 fit-content 值一样）并不妨碍解决项目中的百分比尺寸。

请注意，虽然基于内容的最小尺寸通常是合适的，并有助于防止内容重叠或溢出其容器之外，但在某些情况下它并不合适。

特别是，如果一个文档的主要内容区域使用了弹性尺寸，那么最好设置一个明确的字体相关的最小宽度，如：`min-width: 12em`。基于内容的最小宽度可能会导致一个大的表格或大的图像将整个内容区的尺寸拉伸到一个溢出区，从而使文本行无端地变长，难以阅读。

还要注意的是，当基于内容的尺寸被用在一个有大量内容的项目上时，布局引擎必须在找到其最小尺寸之前遍历所有这些内容，而如果作者设置了一个明确的最小尺寸，这就没有必要。(然而，对于内容较少的项目，这种遍历是微不足道的，因此不存在性能问题）。

## 9.4. 顺序和方向

弹性容器的内容可以以任何方向和任何顺序排列。这使得作者可以简单地实现以前需要复杂或脆弱的方法的效果，如使用 'float' 和 'clear' 属性的黑科技。这个功能是通过 'flex-direction'、'flex-wrap' 和 'order' 属性来实现的。

注意：弹性布局的重新排序功能有意地只影响视觉渲染，而让语音顺序和导航基于源顺序。这允许作者在操纵视觉呈现的同时，为非 CSS UA 和线性模型（如语音和顺序导航）保留源顺序。关于使用这种二分法来提高可及性的例子，请参见重新排序和可及性以及弹性布局概述。

作者不得使用 'order' 或 'flex-flow'/'flex-direction' 的 '\*-reverse' 值来替代正确的源排序，因为这样会破坏文档的可访问性。

### 9.4.1. flex-direction 属性

| 属性名   | flex-direction |
| -------- | -------------- | ----------- | ------ | --------------- |
| 值       | `row           | row-reverse | column | column-reverse` |
| 初始值   | row            |
| 适用元素 | 弹性容器       |
| 可继承性 | 否             |
| 百分数值 | 不适用         |
| 适用媒体 | 视觉           |
| 计算值   | 规定关键字     |

Flex-direction 属性通过设置弹性容器的主轴方向来指定如何在弹性容器中放置弹性子项。这决定了弹性子项的布局方向。

- **row**
  弹性性容器的主轴与当前书写模式的行内轴方向相同。主开始和主结束方向分别等同于当前书写模式的行内开始和行内结束方向。
- **row-reverse**
  与 row 相同，只是主开始和主结束的方向互换。
- **column**
  弹性容器的主轴与当前书写模式的块轴方向相同。主开始和主结束方向分别等同于当前书写模式的块开始和块结束方向。
- **column-reverse**
  与 column 相同，只是主开始和主结束方向互换。

注意：反转值不会反转盒子的顺序：与书写模式和方向[CSS3-WRITING-MODES]一样，它们只改变流动的方向。绘制顺序、讲话顺序和顺序导航顺序不受影响。

### 9.4.2. flex-wrap 属性

| 属性名   | flex-wrap  |
| -------- | ---------- | ---- | ------------- |
| 值       | `nowrap    | wrap | wrap-reverse` |
| 初始值   | nowrap     |
| 适用元素 | 弹性容器   |
| 可继承性 | 否         |
| 百分数值 | 不适用     |
| 适用媒体 | 视觉       |
| 计算值   | 规定关键字 |

'flex-wrap' 属性控制弹性容器是单行还是多行，以及交叉轴的方向，它决定了新行的堆叠方向。

- **nowrap**
  弹性容器是单行的。
- **wrap**
  弹性容器是多行的。
- **wrap-reverse**
  与 wrap 相同。

对于不是 wrap-reverse 的值，交叉开始方向相当于当前书写模式的 inline-start 或 block-start 方向（以交叉轴为准），交叉结束方向是交叉开始的相反方向。当弹性包覆为包覆反转时，交叉开始和交叉结束的方向会互换。

### 9.4.3. flex-flow 属性

| 属性名   | flex-flow           |
| -------- | ------------------- | --- | -------------- |
| 值       | `<'flex-direction'> |     | <'flex-wrap'>` |
| 初始值   | 见单个属性          |
| 适用元素 | 见单个属性          |
| 可继承性 | 见单个属性          |
| 百分数值 | 见单个属性          |
| 适用媒体 | 见单个属性          |
| 计算值   | 见单个属性          |

'flex-flow' 属性是设置 'flex-direction' 和 'flex-wrap' 属性的简写属性，它们共同定义了弹性容器的主轴和横轴。

### 9.4.4. order 属性

默认情况下，弹性子项是按照它们在源文档中出现的相同顺序显示和布局的。'order' 属性可以用来改变这种顺序。

| 属性名   | order       |
| -------- | ----------- |
| 值       | `<integer>` |
| 初始值   | 0           |
| 适用元素 | 弹性子项    |
| 可继承性 | 否          |
| 百分数值 | 不适用      |
| 适用媒体 | 视觉        |
| 计算值   | 规定整数    |

'order' 属性通过将其分配给有序数组来控制弹性子项在弹性容器中的出现顺序。它接受一个单一的`<integer>`值，该值指定了该弹性子项属于哪个序数组。

一个弹性容器按照修改过的文档顺序排列其内容，从编号最低的序数组开始向上排列。具有相同序号组的项目将按照它们在源文档中出现的顺序排列。这也会影响到绘画顺序[CSS21]，就像弹性子项在源文档中被重新排序一样。弹性容器的绝对定位的子项被视为具有顺序：0，以确定其相对于弹性子项的绘画顺序。

#### 9.4.4.1. 重新排序和可访问性

'order' 属性不影响非视觉媒体（如语音）的排序。同样地，'order' 也不影响顺序导航模式的默认遍历顺序（比如循环浏览链接，见例如 tabindex [HTML]）。

作者必须只在视觉媒体上使用 'order'，而不是在逻辑上对内容进行重新排序。使用 'order' 来执行逻辑重新排序的样式表是不符合要求的。

注意：这样做是为了让非视觉媒体和非 CSS UAs（它们通常以线性方式呈现内容）可以依赖逻辑源顺序，而顺序则用于定制视觉顺序。(由于视觉感知是二维和非线性的，所以所需的视觉顺序并不总是符合逻辑的)。

许多网页在标记中都有一个类似的形状，上面是页眉，下面是页脚，然后是内容区和中间的一个或两个附加列。一般来说，在页面的源代码中，最好是先有内容，再有附加列。然而，这使得许多常见的设计，如简单地将附加列放在左边，内容区放在右边，很难实现。多年来，这个问题已经通过许多方式得到了解决，当有两个附加列时，常常被称为 "圣杯布局"。'order' 使这个问题变得微不足道。例如，以下面一个页面的代码和所需布局的草图为例：

```html
<!DOCTYPE html>
<header>...</header>
<main>
  <article>...</article>
  <nav>...</nav>
  <aside>...</aside>
</main>
<footer>...</footer>
```

![弹性圣杯布局](illustrations/flex-order-page.svg)

这种布局可以通过弹性布局轻松实现：

```css
main {
  display: flex;
}
main > article {
  order: 2;
  min-width: 12em;
  flex: 1;
}
main > nav {
  order: 1;
  width: 200px;
}
main > aside {
  order: 3;
  width: 200px;
}
```

作为一个额外的奖励，默认情况下，所有的列都是等高的，主要内容将根据需要的宽度来填充屏幕。此外，这还可以与媒体查询相结合，在窄屏幕上切换到全垂直布局：

```css
@media (max-width: 600px) {
  /* Too narrow to support three columns */
  main {
    flex-flow: column;
  }
  main > article,
  main > nav,
  main > aside {
    /* Return them to document order */
    order: 0;
    width: auto;
  }
}
```

为了在所有的演示模式中保留作者预期的顺序，创作工具--包括所见即所得的编辑器以及基于网络的创作辅助工具--必须对基础文件源进行重新排序，而不能使用顺序来执行重新排序，除非作者明确表示基础文件的顺序（决定了语音和导航顺序）应该与视觉顺序不同步。

例如，一个工具可以同时提供弹性子项的拖放式重新排序，以及处理媒体查询，以便在每个屏幕尺寸范围内进行交替布局。

由于大多数情况下，重新排序应该影响所有的屏幕范围以及导航和语音顺序，该工具将在 DOM 层执行拖放式重新排序。然而，在某些情况下，作者可能希望每个屏幕尺寸有不同的视觉顺序。该工具可以通过与媒体查询一起使用顺序来提供这一功能，但也可以将最小的屏幕尺寸的顺序与底层的 DOM 顺序联系起来（因为这最有可能是一个逻辑的线性呈现顺序），同时使用顺序来决定其他尺寸范围内的视觉呈现顺序。

这个工具是符合要求的，而一个只使用顺序来处理拖放重新排序的工具（不管这样实现起来有多方便）将是不符合要求的。

注意：用户代理，包括浏览器、无障碍技术和扩展，可以提供空间导航功能。本节并不排除在这种空间导航模式中确定元素排序时尊重顺序属性；事实上，为了使这种功能发挥作用，需要考虑到这一点。但是顺序并不是这种空间导航功能需要考虑的唯一（甚至是主要）的 CSS 属性。一个实施良好的空间导航功能需要考虑 CSS 中所有修改空间关系的布局特性。

## 9.5. 弹性行

弹性容器中的弹性子项在弹性行内布局和对齐，弹性行是布局算法用于分组和对齐的假想容器。一个弹性容器可以是单行的，也可以是多行的，取决于'flex-wrap' 属性。

一个单行的弹性容器（即一个具有 'flex-wrap: nowrap' 的容器）将其所有的子项排成一行，即使这将导致其内容溢出。

多行弹性容器（即具有 'flex-wrap: wrap' 或 'flex-wrap: wrap-reverse' 的容器）将其弹性子项分成多行，类似于当文本变得太宽而无法容纳在现有行中时被分成新行的情况。当额外的行被创建时，它们会根据 'flex-wrap' 属性沿着横轴堆叠在弹性容器中。每一行至少包含一个弹性项目，除非弹性容器本身是完全空的。

这个例子显示了四个不适合水平并排的按钮，因此会包成多行：

```css
#flex {
  display: flex;
  flex-flow: row wrap;
  width: 300px;
}

.item {
  width: 80px;
}
```

```html
<div id="flex">
  <div class="item">1</div>
  <div class="item">2</div>
  <div class="item">3</div>
  <div class="item">4</div>
</div>
```

由于容器的宽度为 300px，只有三个项目适合在一行中出现。它们占据了 240px，剩下 60px 的剩余空间。因为 flex-flow 属性指定了一个多行的 flex 容器（由于其值中出现了 wrap 关键字），flex 容器将创建一个额外的行来容纳最后一个项目。

![multiline-no-flex](illustrations/multiline-no-flex.svg)

一旦内容被分成几行，每一行都是独立布局的；弹性度和 `justify-content` 以及 `align-self` 属性每次只考虑单行上的子项。

在多行弹性容器中（即使是只有一行的容器），每行的交叉尺寸是包含该行柔性项目所需的最小尺寸（由于 `align-self` 而对齐后），并且这些行在弹性容器中用 `align-content` 属性对齐。在一个单行的弹性容器中，行的交叉尺寸是弹性容器的交叉尺寸，而 `align-content` 没有影响。行的主尺寸总是与弹性容器的内容盒子的主尺寸相同。

下面是与前一个相同的例子，只是弹性子项都被赋予了 'flex: auto'。第一行有 60px 的剩余空间，所有的项目都有相同的弹性度，所以该行的三个项目都将获得 20px 的额外宽度，每个项目最后都是 100px 宽。剩下的项目是在自己的行上，将伸展到该行的整个宽度，即 300px：

![multiline-flex](illustrations/multiline-flex.svg)

## 9.6. 弹性度

弹性布局的决定性方面是使弹性子项“弹性化”的能力，改变它们的宽度/高度以填补主要尺寸的可用空间。这是由 'flex' 属性完成的。一个弹性容器将自由空间分配给它的子项（与它们的 'flex-grow' 系数成比例）以填充容器，或缩小它们（与它们的 'flex-shrink' 系数成比例）以防止溢出。

如果一个弹性子项的 'flex-grow' 值和 'flex-shrink' 值都为 0，那么它就是完全不弹性，否则就是弹性的。

### 9.6.1. flex 简写属性

| 属性名   | flex       |
| -------- | ---------- | -------------------------------- | --- | ----------------- |
| 值       | `none      | [ <'flex-grow'> <'flex-shrink'>? |     | <'flex-basis'> ]` |
| 初始值   | 0 1 auto   |
| 适用元素 | 弹性子项   |
| 可继承性 | 否         |
| 百分数值 | 见单个属性 |
| 适用媒体 | 视觉       |
| 计算值   | 见单个属性 |

flex 属性指定了弹性长度的组件：挠性系数（增长和收缩）和挠性基础。当一个盒子是一个柔性项目时，会参考柔性而不是主尺寸属性来决定盒子的主尺寸。如果一个盒子不是一个柔性项目，柔性就没有作用。

- <'flex-grow'>
  这个<number>组件设置了 flex-grow 长项，并指定了 flex 增长因子，该因子决定了在分配正自由空间时，flex 项相对于 flex 容器中其他 flex 项的增长程度。当省略时，它被设置为 1。
  介于 0 和 1 之间的 flex 值有一个有点特殊的行为：当行上的 flex 值之和小于 1 时，它们将占用小于 100%的自由空间。
- <'flex-shrink'>
  这个<number>组件设置了 flex-shrink 长方形，并指定了 flex 收缩系数，该系数决定了在分配负自由空间时，flex 项相对于 flex 容器中其他 flex 项的收缩程度。当省略时，它被设置为 1。
  注意：在分配负空间时，柔性收缩系数要乘以柔性基础尺寸。这与项目能够缩小的程度成比例地分配负空间，因此，例如，一个小项目不会在一个较大的项目被明显缩小之前就缩小到零。
- <'flex-basis'>
  这个组件设置了 flex-basis，它指定了 flex 基础：在自由空间根据 flex 因子分配之前，flex 项目的初始主要尺寸。
  <'flex-base'>接受与宽度和高度属性相同的值（除了 aut 的处理方式不同），再加上内容关键字。

auto
当在一个 flex 项目上指定时，auto 关键字会检索主尺寸属性的值作为使用的 flex-basis。如果该值本身是 auto，那么使用的值就是 content。
内容
表示基于柔性项目内容的自动尺寸。(它通常等同于最大内容尺寸，但会进行调整以处理长宽比、内在尺寸限制和正交流；详情见§9 Flex 布局算法）。
注意：这个值在最初发布的 Flexible Box Layout 中并不存在，因此一些旧的实施方案将不支持它。通过使用 auto 和 auto 的主尺寸（宽度或高度），可以达到同等效果。

- <'width'>
  对于所有其他值，flex-basis 的解决方式与宽度和高度的解决方式相同。当从 'flex' 简写属性中省略时，其指定值为 0。
- none
  关键字 none 扩展为 0 0 auto。

### 9.6.2. flex 简写属性

### 9.6.3. flex-grow

### 9.6.4. flex-shrink

### 9.6.5. flex-basis

## 9.7. 对齐

### 9.7.1. 自动外边距对齐

### 9.7.2. justify-content 属性

### 9.7.3. align-items 和 align-self 属性

### 9.7.4. align-content 属性

### 9.7.5. 弹性容器基线

## 9.8. 弹性布局算法
