**目录：**

- [7. 视觉格式化模型](#7-视觉格式化模型)
  - [7.1. 视觉格式化模型简介](#71-视觉格式化模型简介)
    - [7.1.1. 视口](#711-视口)
    - [7.1.2. 包含块](#712-包含块)
  - [7.2. 控制盒子生成](#72-控制盒子生成)
    - [7.2.1. 块级元素和块盒子](#721-块级元素和块盒子)
      - [7.2.1.1. 匿名块盒子](#7211-匿名块盒子)
    - [7.2.2. 行内级元素和行内盒子](#722-行内级元素和行内盒子)
      - [7.2.2.1. 匿名行内盒子](#7221-匿名行内盒子)
    - [7.2.3. display 属性](#723-display-属性)
  - [7.3. 定位方案](#73-定位方案)
    - [7.3.1. position 属性](#731-position-属性)
    - [7.3.2. 盒子偏移](#732-盒子偏移)
  - [7.4. 正常流](#74-正常流)
    - [7.4.1. 块格式化上下文](#741-块格式化上下文)
    - [7.4.2. 行内格式上下文](#742-行内格式上下文)
    - [7.4.3. 相对定位](#743-相对定位)
  - [7.5. 浮动](#75-浮动)
    - [7.5.1. float 属性](#751-float-属性)
    - [7.5.2. clear 属性](#752-clear-属性)
  - [7.6. 绝对定位](#76-绝对定位)
    - [7.6.1. 固定定位](#761-固定定位)
  - [7.7. display, position 和 float 之间的关系](#77-display-position-和-float-之间的关系)
  - [7.8. 对比正常流，浮动和绝对定位](#78-对比正常流浮动和绝对定位)
    - [7.8.1. 正常流](#781-正常流)
    - [7.8.2. 相对定位](#782-相对定位)
    - [7.8.3. 浮动](#783-浮动)
    - [7.8.4. 绝对定位](#784-绝对定位)
  - [7.9. 分层显示](#79-分层显示)
    - [7.9.1. z-index 属性](#791-z-index-属性)

# 7. 视觉格式化模型

## 7.1. 视觉格式化模型简介

本章和下一章描述了视觉格式化模型：用户代理如何处理视觉媒体的文档树。

在视觉格式化模型中，文档树中的每个元素都会根据盒模型生成 0 个或多个盒子。这些盒子的布局受以下因素制约：

- 盒子的尺寸和类型。
- 定位方案(正常流、浮动和绝对定位)。
- 文档树中元素之间的关系。
- 外部信息(例如，视口尺寸、图像的固有尺寸等)。

### 7.1.1. 视口

连续媒体的用户代理通常为用户提供一个视口(屏幕上的一个窗口或其他观察区域)，用户通过它来查阅文档。当视口被调整大小时，用户代理可能会改变文档的布局(见 [初始包含块](#81-包含块的定义))。

当视口小于渲染文档的画布的面积时，用户代理应该提供一个滚动机制。每个画布最多只有一个视口，但用户代理可以渲染到一个以上的画布上(即提供同一文档的不同视图)。

### 7.1.2. 包含块

在 CSS 2.2 中，许多盒子的位置和大小都是相对于一个叫做包含块的矩形盒子的边缘计算的。一般来说，生成盒子作为后代盒子的包含块；我们说一个盒子为其后代盒子“建立”了包含块。短语“盒子的包含块”是指“盒子所处的包含块”，而不是它所生成的那个。

每个盒子都有一个相对于其包含块的位置，但它并不被这个包含块所限制；它可以溢出。

下一章将描述如何计算一个包含块的尺寸的细节。

## 7.2. 控制盒子生成

下面的章节描述了在 CSS 2.2 中可能生成的盒子的类型。一个盒子的类型部分地影响了它在视觉格式化模型中的行为。下面描述的 'display' 属性指定了一个盒子的类型。

'display' 属性的某些值会使源文档中的一个元素生成一个 **主盒子**，该主盒子包含了后代盒子和生成的内容，以及任何定位方案中涉及的盒子。一些元素可能在主盒子之外产生额外的盒子: list-item 元素。这些额外的盒子是相对于主盒子放置的。

### 7.2.1. 块级元素和块盒子

**块级元素**，即源文档中那些在视觉上被格式化为块的元素(例如，p 元素)，是产生块级主盒子的元素。使元素成为块级的 'display' 属性的值包括：'block', 'list-item' 和 'table'。**块级盒子** 是参与块格式化上下文的盒子。

在 CSS 2.2 中，块级盒子也是块容器盒子，除非它是表格盒子或替换性元素的主盒子。一个 **块容器盒子** 要么只包含块级盒子，要么建立一个行内格式化上下文，因此要么只包含行内级盒子。一个主盒子是块容器盒子的元素是一个 **块容器元素**。使一个非替换性元素生成一个块容器的 'display' 属性的值包括 'block'、'list-item'和'inline-block'。并非所有的块容器盒子都是块级盒子：非替换性行内块和非替换性表格单元格是块容器，但不是块级。同时也是块容器的块级盒子被称为 **块盒子**。

这三个术语“块级盒子”，“块容器盒子”和“块盒子”有时在不明确的情况下被缩写为“块”。

#### 7.2.1.1. 匿名块盒子

在这样的一个文档中：

```html
<div>
  Some text
  <p>More text</p>
</div>
```

(假设 div 和 p 都有 'display: block')，div 看起来既有行内内容又有块内容。为了便于定义格式，我们假设 "some TEXT" 周围有一个匿名的块盒子。

换句话说：如果一个块容器盒子(比如上面为 div 生成的)里面有一个块级盒子(比如上面的 p)，那么我们强制它里面只有块级盒子。

当一个行内盒子包含一个正常流的块级盒子时，行内盒子(及其在同一行内盒子的行内祖先盒子)会围绕块级盒子(以及任何连续的或仅由可折叠的空白和/或脱离正常流的元素分隔的块级兄弟盒子)断开，将行内盒子分割成两个盒子(即使任何一边是空的)，在块级盒子的两侧各一个。断裂前和断裂后的行内盒子被包围在匿名块级盒子中，而块级盒子成为这些匿名盒子的兄弟盒子。当这样的行内盒子受到相对定位的影响时，任何产生的平移也会影响到行内盒子中包含块级盒子。

这个模式将适用于以下例子，如果以下规则：

```css
p {
  display: inline;
}

span {
  display: block;
}
```

被用于该 HTML 文档:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<head>
  <title>匿名文本被一个块阻断</title>
</head>
<body>
  <p>
    这是在 span 之前的匿名文本。
    <span>这是span的内容</span>
    这是在 span 之后的匿名文本。
  </p>
</body>
```

P 元素包含一大块(C1)匿名文本，后面是一个块级元素，后面是另一大块(C2)匿名文本。由此产生的盒子将是一个代表 BODY 的块盒子，包含 C1 周围的一个匿名块盒子：SPAN 块盒子，以及 C2 周围的另一个匿名块盒子。

匿名盒子的属性是从包围的非匿名盒子中继承的(例如，在 "匿名块盒子" 小节标题下的例子中，DIV 的属性)。非继承的属性有其初始值。例如，匿名盒子的字体是继承自 DIV 的，但外边距将是 0。

在元素上设置的导致生成匿名块盒子的属性仍然适用于该元素的盒子和内容。例如，如果在上例中的 P 元素上设置了边框，那么边框将围绕 C1(在行末开放)和 C2(在行首开放)绘制。

一些用户代理以其他方式在包含块的行内上实现边框，例如，通过将这些嵌套的块包裹在 "匿名行盒子 "内，从而在这些行盒子周围绘制行内边框。由于 CSS1 和 CSS2 没有定义这种行为，只有 CSS1 和 CSS2 的用户代理可以实现这种替代模型，并且仍然声称符合 CSS 2.2 的这一部分。这不适用于本规范发布后开发的用户代理。

在解析引用它的百分数值时，匿名块盒子会被忽略：会使用最接近的非匿名的祖先盒子。例如，如果上面 DIV 内的匿名块盒子的子盒子需要知道其包含块的高度来解决百分数高度，那么它将使用 DIV 形成的包含块的高度，而不是匿名块盒子的高度。

### 7.2.2. 行内级元素和行内盒子

**行内级元素** 是源文档中那些不形成新的内容块的元素；内容分布在行中(例如，段落中的强调文本，行内图像，等等)。下列 "display" 属性的值使元素成为行内级："inline"、"inline-table" 和 "inline-block"。行内级元素产生 **行内级盒子**，这是参与行内格式化上下文的盒子。

一个 **行内盒子** 是一个既是行内级的，其内容又参与其包含的行内格式化上下文的盒子。一个 "display" 值为 "inline" 的非替换性元素会产生一个行内盒子。不是行内盒子的行内级盒子(如替换性行内级元素、inline-block 元素和inline-table 元素)被称为 **原子行内级盒子**，因为它们作为一个单一的不透明盒子参与其行内格式化上下文。

#### 7.2.2.1. 匿名行内盒子

任何直接包含在块容器元素内的文本(不在行内元素内)必须被视为匿名行内元素。

在一个具有这样的 HTML 标记的文档中:

```html
<p>
  一些
  <em>强调的</em>
  文本
</p>
```

`<p>` 产生了一个块盒子，里面有几个行内盒子。用来“强调”的盒子是由行内元素(`<em>`)生成的行内盒子，但其他的盒子("一些"和 "文本")是由块级元素(`<p>`)生成的行内盒子。后者被称为匿名行内盒子，因为它们没有一个相关的行内级元素。

这种匿名行内盒子从其父块盒子继承可继承的属性。非继承的属性有其初始值。在这个例子中，匿名行内盒子的颜色是从 P 中继承的，但背景是透明的。

根据'white-space'属性，随后会被折叠掉的空白不会产生任何匿名行内盒子。

如果从上下文中可以清楚地知道是指哪种类型的匿名盒子，匿名行内盒子和匿名块盒子在本规范中都被简单地称为匿名盒子。

在格式化表格时，还有更多类型的匿名盒子出现。

### 7.2.3. display 属性

| 属性名   | display  |
| -------- | -------- | ----- | --------- | ------------ | ----- | ------------ | --------------- | ------------------ | ------------------ | --------- | ------------------ | ------------ | ---------- | ------------- | ---- | -------- |
| 值       | `inline  | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit` |
| 初始值   | inline   |
| 适用元素 | 所有元素 |
| 可继承性 | 否       |
| 百分数值 | N/A      |
| 适用媒体 | 所有     |
| 计算值   | 参见本书 |

此属性的值有以下含义：

- **block**
  这个值会使一个元素产生一个主块盒子。

- **inline-block**
  这个值会使一个元素产生一个主要的行内块容器。(这个盒子的内部被格式化为一个块级，而元素本身被格式化为一个原子行内级盒子。)

- **inline**
  这个值使一个元素产生一个或多个行内盒子。

- **list-item**
  这个值使一个元素(例如 HTML 中的 LI)产生一个主块盒子和一个标记盒子。

- **none**
  这个值使一个元素不出现在格式化结构中(即在视觉媒体中，该元素不产生盒子，对布局没有影响)。后代元素也不产生任何盒子；该元素及其内容完全从格式化结构中移除。这种行为不能通过在子元素上设置 'display' 属性而被推翻。
  请注意，'none' 的显示并不创建一个不可见的盒子；它根本就不创建任何盒子。CSS 包括一些机制，使一个元素能够在格式化结构中生成影响格式化但本身不可见的盒子。详情请参考可见性一节。

- **table, inline-table, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, and table-caption**
  这些值使一个元素表现得像一个表格元素(受制于关于表格的章节中描述的限制)。

计算值与指定值相同，除了定位和浮动元素(见 display, position 和 float 之间的关系)和根元素。对于根元素来说，计算值会按照 display, position 和 float 之间的关系一节中的描述来改变。

注意，虽然 'display' 的初始值是 'inline'，但用户代理的默认样式表中的规则可能会覆盖这个值。

一些关于 display 属性的例子：

```css
p {
  display: block;
}
em {
  display: inline;
}
li {
  display: list-item;
}
img {
  display: none;
} /* 不会显示图片 */
```

## 7.3. 定位方案

在 CSS 2.2 中，一个盒子可以按照三种定位方案来放置。

1. **正常流**。在 CSS 2.2 中，正常流包括块级盒子的块格式化，行内级盒子的行内格式化，以及块级和行内级盒子的相对定位。

2. **浮动**。在浮动模型中，一个盒子首先按照正常流放置，然后从正常流中取出并尽可能向左或向右移动。内容可以沿着浮动的一侧流动。

3. **绝对定位**。在绝对定位模型中，一个盒子被完全从正常流中移除(它对后面的兄弟元素没有影响)，并相对于一个包含块分配一个位置。

如果一个元素是浮动的，绝对定位的，或者是根元素，它就被称为 **脱离正常流(out of flow)**。如果一个元素不是脱离正常流的，则称为在 **正常流中(正常流中的)**。一个元素 A 的流是由 A 和所有在正常流中元素组成的集合，这些元素的最近的脱离正常流的祖先元素是 A。

注意。CSS 2.2 的定位方案可以帮助作者使他们的文档更容易访问，因为他们可以避免用于布局效果的标记技巧(例如，看不见的图像)。

### 7.3.1. position 属性

'position' 和 'float' 属性决定了哪个 CSS 2.2 定位算法被用来计算一个盒子的位置。

| 属性名   | position |
| -------- | -------- | -------- | -------- | ----- | -------- |
| 值       | `static  | relative | absolute | fixed | inherit` |
| 初始值   | static   |
| 适用元素 | 所有元素 |
| 可继承性 | 否       |
| 百分数值 | N/A      |
| 适用媒体 | 视觉     |
| 计算值   | 参见规范 |

此属性的值有以下含义：

- **static**
  该盒子是一个正常的盒子，按照正常流放置。'top', 'bottom', 'left', 'right' 属性不适用。

- **relative**
  盒子的位置是根据正常流计算的(这被称为正常流中的位置)。然后盒子相对于它的正常位置进行偏移。当一个盒子 B 被相对定位时，后面的盒子的位置被计算出来，就像 B 没有被偏移一样。position:relative 对 table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-column、table-cell 和 table-caption 元素的影响未定义。

- **absolute**
  盒子的位置(可能还有大小)是用 'top', 'right', 'bottom' 和 'left' 属性指定的。这些属性指定了相对于盒子的包含块的偏移量。绝对定位的盒子被从正常流中取出。这意味着它们对后来的兄弟元素的布局没有影响。另外，尽管绝对定位盒子有外边距，但它们不会与任何其他外边距一起折叠。

- **fixed**
  盒子的位置是根据绝对模型计算的，但除此之外，盒子相对于某些参考物是固定的。与绝对模型一样，盒子的外边距不会与任何其他外边距一起折叠。在手持、投影、屏幕、TTY 和电视媒体类型的情况下，盒子相对于视口是固定的，滚动时不会移动。在打印媒体类型的情况下，盒子在每个页面上都被呈现，并且相对于页面盒子是固定的，即使页面是通过视口看到的(例如，在打印预览的情况下)。对于其他媒体类型，呈现方式是未定义的。作者可能希望以一种依赖于媒体的方式来指定 fixed。例如，作者可能希望一个盒子在屏幕上保持在视口的顶部，但在每个打印页的顶部则不需要。这两种规格可以通过使用@media 规则来区分，如：

```css
@media screen {
  h1#first {
    position: fixed;
  }
}
@media print {
  h1#first {
    position: static;
  }
}
```

用户代理可以将根元素上的位置视为 'static'。

### 7.3.2. 盒子偏移

如果一个元素的'position'属性有一个'static'以外的值，那么它就被称为 **定位** 了。被定位的元素会产生被定位的盒子，根据四个属性来放置：

| 属性名   | top                                                                                 |
| -------- | ----------------------------------------------------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                                                           | <pencentage> | auto | inherit` |
| 初始值   | auto                                                                                |
| 适用元素 | 定位元素                                                                            |
| 可继承性 | 否                                                                                  |
| 百分数值 | 相对于包含块的高度                                                                  |
| 适用媒体 | 视觉                                                                                |
| 计算值   | 如果指定为长度，则为相应的绝对长度；如果指定为百分数值，则为指定值；否则为 'auto'。 |

这个属性指定了一个绝对定位的盒子的顶部边缘在该盒子的包含块的顶部边缘之下的偏移量。对于相对定位的盒子，偏移是相对于盒子本身的顶部边缘而言的(即，盒子在正常流中被赋予一个位置，然后根据这些属性从该位置偏移)。

| 属性名   | right                                                                               |
| -------- | ----------------------------------------------------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                                                           | <pencentage> | auto | inherit` |
| 初始值   | auto                                                                                |
| 适用元素 | 定位元素                                                                            |
| 可继承性 | 否                                                                                  |
| 百分数值 | 相对于包含块的宽度                                                                  |
| 适用媒体 | 视觉                                                                                |
| 计算值   | 如果指定为长度，则为相应的绝对长度；如果指定为百分数值，则为指定值；否则为 'auto'。 |

像'top'一样，但指定了一个盒子的右边缘向该盒子的包含块的右边缘的左边偏移的程度。对于相对位置的盒子，偏移是相对于盒子本身的右边缘而言的。

| 属性名   | bottom                                                                              |
| -------- | ----------------------------------------------------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                                                           | <pencentage> | auto | inherit` |
| 初始值   | auto                                                                                |
| 适用元素 | 定位元素                                                                            |
| 可继承性 | 否                                                                                  |
| 百分数值 | 相对于包含块的高度                                                                  |
| 适用媒体 | 视觉                                                                                |
| 计算值   | 如果指定为长度，则为相应的绝对长度；如果指定为百分数值，则为指定值；否则为 'auto'。 |

和'top'一样，但指定一个盒子的底部外边距边缘在该盒子包含块的底部以上偏移的程度。对于相对定位的盒子，偏移量是相对于盒子本身的底边而言的。

| 属性名   | left                                                                                |
| -------- | ----------------------------------------------------------------------------------- | ------------ | ---- | -------- |
| 值       | `<length>                                                                           | <pencentage> | auto | inherit` |
| 初始值   | auto                                                                                |
| 适用元素 | 定位元素                                                                            |
| 可继承性 | 否                                                                                  |
| 百分数值 | 相对于包含块的宽度                                                                  |
| 适用媒体 | 视觉                                                                                |
| 计算值   | 如果指定为长度，则为相应的绝对长度；如果指定为百分数值，则为指定值；否则为 'auto'。 |

和'top'一样，但指定一个盒子的左边距边缘偏移到该盒子所包含块的左边缘的右边有多远。对于相对位置的盒子，偏移是相对于盒子本身的左边缘而言的。

这四个属性的值有以下含义：

- `<length>`
  偏移量是与参考边缘的一个固定距离。允许使用负值。

- `<percentage>`
  偏移是包含块的宽度(对于 "'left' 或 'right')或高度(对于 'top' 和 "底")的百分数。允许使用负值。

- auto
  对于非替换的元素，这个值的效果取决于哪些相关属性的值也是'auto'。详见关于绝对定位的非替换元素的宽度和高度的章节。对于替换性元素，这个值的效果只取决于被替换内容的内在尺寸。详见绝对定位的被替换元素的宽度和高度部分。

## 7.4. 正常流

正常流的盒子属于一个格式化上下文，在 CSS 2.2 中可以是表格、块或行内。在未来的 CSS 级别中，将引入其他类型的格式化上下文。块级盒子属于块格式化上下文。行内级盒子参与到行内格式化上下文中。表格的格式化上下文在关于表格的章节中描述。

### 7.4.1. 块格式化上下文

浮动、绝对定位的元素、不是块盒子的块容器(如 inline-blocks、table-cell 和 table-captions)，以及 "overflow" 不是 "visible" 的块盒子(除非该值已被传播到视口)为其内容建立新的块格式化上下文。

在一个块格式化上下文中，盒子是一个接一个垂直排列的，从包含块的顶部开始。两个同级盒子之间的垂直距离由 "margin" 属性决定。在块格式化上下文中，相邻的块级盒子之间的垂直外边距会折叠。

在块格式化上下文中，每个盒子的左外边缘都会接触到包含块的左边缘(对于从右到左的格式化，右边缘会接触)。即使在有浮动的情况下也是如此(尽管一个盒子的行盒子可能会因为浮动而缩小)，除非该盒子建立了一个新的块格式化上下文(在这种情况下，盒子本身可能会因为浮动而变得更窄)。

### 7.4.2. 行内格式上下文

行内格式化上下文是由一个不包含块级盒子的块容器盒子建立的。在一个行内格式化上下文中，盒子是水平排列的，一个接一个，从包含块的顶部开始。这些盒子之间的水平外边距、边框和内边距都得到尊重。这些盒子可以用不同的方式在垂直方向上对齐：它们的底部或顶部可以对齐，或者它们内部的文本基线可以对齐。包含形成一行的盒子的矩形区域被称为 **行盒子**。

行盒子的宽度由包含块和浮动的存在决定。行盒子的高度由行高计算一节中给出的规则决定。

一个行盒子的高度总是足以容纳它所包含的所有行盒子。然而，它可能比它所包含的最高的盒子要高(例如，如果盒子被对齐，使基线排成一行)。当一个盒子 B 的高度小于包含它的行盒子的高度时，行盒子内 B 的垂直对齐由'vertical-align' 属性决定。当几个行内级的盒子不能在水平方向上适合于一个行盒子时，它们会被分配到两个或多个垂直堆叠的行盒子中。因此，一个段落是一个垂直堆叠的行盒子。行盒子的堆叠没有垂直分隔(除非在其他地方指定)，而且它们从不重叠。

一般来说，行盒子的左边缘触及其包含块的左边缘，右边缘触及其包含块的右边缘。然而，浮动盒子可能会出现在包含块边缘和行盒子边缘之间。因此，尽管同一行内格式的行盒子通常具有相同的宽度(即包含块的宽度)，但如果可用的水平空间因浮动而减少，它们的宽度就会不同。同一行内格式化上下文下的行盒子通常在高度上有所不同(例如，一行可能包含一个高的图像，而其他行只包含文本)。

当一行中的行内级盒子的总宽度小于包含它们的行盒子的宽度时，它们在行盒子中的水平分布由'text-align'属性决定。如果该属性的值为'justify'，则用户代理可能会将行内盒子(但不包括 inline-table 和 inline-block 盒子)中的空格和文字也拉伸。

当一个行内盒子超过一个行盒子的宽度时，它就会被分割成几个盒子，这些盒子被分布在几个行盒子中。如果一个行内盒子不能被分割(例如，如果行内盒子包含一个字符，或者语言的特定断字规则不允许在行内盒子内断字，或者行内盒子受到 nowrap 或 pre 的白空间值的影响)，那么行内盒子会溢出行盒子。

当一个行内盒子被分割时，边距、边框和填充在发生分割的地方(或在任何分割处，当有几个分割时)没有视觉效果。

由于双向文本处理，行内盒子也可能在同一行盒子内被分割成几个盒子。

行盒子是根据需要创建的，以便在行内格式化上下文下容纳行内级内容。不包含文本、不保留空白、不包含具有非 0 外边距、内边距或边框的行内元素，以及不包含其他行内内容(如图像、行内块或行内表)，并且不以保留的换行结束的行盒子必须被视为 0 高度的行盒子，以便确定其内部任何元素的位置，并且必须被视为不存在任何其他目的。

下面是一个行内盒子结构的例子。以下段落(由 HTML 块级元素 P 创建)包含匿名文本，其中穿插了元素 EM 和 STRONG：

```html
<p>
  几个
  <em>强调的词语</em>
  出现
  <strong>在这个</strong>
  句子中，伙计。
</p>
```

P 元素生成了一个块盒子，其中包含五个行内盒子，其中三个是匿名的：

- 匿名："几个"
- EM："强调的词语"
- 匿名："出现"
- STRONG："在这个"
- 匿名："句子中，伙计。"

为了格式化该段落，用户代理将五个盒子流入行盒子。在这个例子中，为 P 元素生成的盒子建立了行盒子的包含块。如果包含块足够宽，所有的行内盒子都可以放入一个行盒子中:

```
几个强调的词语出现在这个句子中，伙计。
```

如果不是，行内盒子将被拆开，分布在几个行盒子中。前面的段落可能会被分割如下：

```
有几个强调的词语出现在
在这个句子中，伙计。
```

或像这样:

```
有几个强调的
词语出现在这个
句子中，伙计。
```

在前面的例子中，EM 盒子被分割成两个 EM 盒子(称之为 "split1 "和 "split2")。在 split1 之后或 split2 之前，外边距、边框、内边距或文本装饰都没有可见效果。

### 7.4.3. 相对定位

一旦一个盒子按照正常流布局或浮动，它就可以相对于这个位置进行移动。这就是所谓的 **相对定位**。以这种方式偏移一个盒子(B1)，对后面的盒子(B2)没有影响。B2 的位置就像 B1 没有被偏移一样，在 B1 的偏移被应用后，B2 不会被重新定位。这意味着，相对定位可能会导致盒子重叠。然而，如果相对定位导致 "overflow: auto" 或 "overflow: scroll" 盒子有溢出，UA 必须允许用户访问这些内容(在其偏移位置)，通过创建滚动条，可能会影响布局。

一个相对定位的盒子会保持其正常流大小，包括换行和原来为其保留的空间。关于包含块的章节解释了相对定位的盒子何时建立一个新的包含块。

对于相对定位的元素，'left' 和 'right' 水平移动盒子，而不改变其大小。'left' 将盒子向右移动，而 'right' 将它们向左移动。因为盒子不会因为 'left' 或 'right' 而被分割或拉伸，所以使用的值总是：left = -right。

如果 'left' 和 'right' 都是 'auto'(它们的初始值)，使用的值是 '0'(也就是说，盒子保持在它们的原始位置)。

如果 'left' 是 'auto'，它的使用值是减去 'right' 的值(也就是说，盒子向左移动的值是 'right' 的值)。

如果 'right' 被指定为 'auto'，它的使用值是减去 'left' 的值。

如果 'left' 和 'right' 都不是 'auto'，位置就会被过度限制，其中一个必须被忽略。如果包含块的 'direction' 属性是 'ltr'，'left'的值就会赢，'right' 就会变成 -'left'。如果包含块的 'direction' 是 'rtl'，'right' 获胜，'left' 被忽略。

例子。以下三条规则是等价的:

```css
div.a8 {
  position: relative;
  direction: ltr;
  left: -1em;
  right: auto;
}

div.a8 {
  position: relative;
  direction: ltr;
  left: auto;
  right: 1em;
}

div.a8 {
  position: relative;
  direction: ltr;
  left: -1em;
  right: 5em;
}
```

top'和'bottom'属性将相对定位的元素向上或向下移动，而不改变其大小。顶部 "将盒子向下移动，而 'bottom' 将它们向上移动。因为盒子不会因为'top'或'bottom'而被分割或拉伸，所以使用的值总是：top = -bottom。如果两者都是'auto'，它们的使用值都是'0'。如果其中一个是 'auto'，它就成为另一个的负值。如果两者都不是 'auto'，'bottom' 就会被忽略(即 'bottom' 的使用值将减去 'top' 的值)。

注意。相对定位的盒子的动态移动可以在脚本环境中产生动画效果(另见 'visibility' 属性)。虽然相对定位可以作为上标和下标的一种形式，但行高不会自动调整以考虑到定位。更多信息请参见行高计算的描述。

在比较正常流、浮动和绝对定位的章节中提供了相对定位的例子。

## 7.5. 浮动

浮动是一个在当前行中向左或向右移动的盒子。浮动盒子的最有趣的特征是，内容可以沿其侧面流动(或被 'clear' 属性禁止这样做)。内容在左浮动盒子的右侧流动，在右浮动盒子的左侧流动。下面是关于浮动定位和内容流动的介绍；关于浮动行为的确切规则在 'float' 属性的描述中给出。

一个浮动盒子会向左或向右移动，直到它的外边缘接触到包含块的边缘或另一个浮动盒子的外边缘。如果有一个行盒子，浮动盒子的外顶部与当前行盒子的顶部对齐。

如果没有足够的水平空间容纳浮动，它将被向下移动，直到它适合或没有更多的浮动存在。

由于浮动不在流程中，在浮动盒子之前和之后创建的非定位块盒子垂直流动，就像浮动不存在一样。然而，在浮子旁边创建的当前和后续的行盒子会根据需要缩短，以便为浮子的边框腾出空间。

当存在一个满足所有这四个条件的垂直位置时，一个行盒子就在一个浮动的旁边。(a)在行盒子的顶部或下面，(b)在行盒子的底部或上面，(c)在浮动的顶部边缘以下，和(d)在浮动的底部边缘以上。

注意：这意味着外高为 0 或外高为负的浮动体不会缩短行盒子。

如果缩短后的行盒子太小，不能容纳任何内容，那么行盒子就会向下移动(并且重新计算其宽度)，直到有内容适合或者没有更多的浮子存在。在浮动盒子之前的当前行中的任何内容都会在浮动盒子的另一侧的同一行中回流。换句话说，如果在遇到适合剩余行盒子空间的左浮动之前，行内的行内盒子被放置在行内，左浮动被放置在该行，与行盒子的顶部对齐，然后已经在行内的行内盒子被相应地移动到浮动的右边(右边是左浮动的另一边)，反之，rtl 和右浮动也是如此。

表格的边框、替换性块级元素、或正常流中建立新的块格式化上下文的元素(比如 'overflow' 不是 'visible' 的元素)的边框不得与元素本身在同一块格式化上下文中的任何浮动重叠。如果有必要，实现者应该通过将其放置在任何前面的浮子下面来清除上述元素，但如果有足够的空间，可以将其放置在这些浮子的旁边。他们甚至可以使上述元素的边框比第 10.3.3 节所定义的更窄。CSS2 没有定义 UA 何时可以将所述元素放在浮动的旁边，也没有定义所述元素可以变窄多少。

### 7.5.1. float 属性

| 属性名   | float  |
| -------- | ------ | ----- | ---- | -------- |
| 值       | `left  | right | none | inherit` |
| 初始值   | none   |
| 适用元素 | 所有   |
| 可继承性 | 否     |
| 百分数值 | N/A    |
| 适用媒体 | 视觉   |
| 计算值   | 见规定 |

这个属性指定一个盒子是否应该向左、向右或根本不浮动。它可以为任何元素设置，但只适用于产生非绝对定位的盒子的元素。这个属性的值有以下含义：

- **left**
  该元素生成一个向左浮动的块状框。内容在盒子的右侧流动，从顶部开始(受'clear'属性限制)。
- **right**
  类似于'left'，除了盒子向右浮动，内容在盒子的左边流动，从顶部开始。
- **none**
  盒子没有被浮动。

用户代理可以将根元素上的浮动视为'none'。

下面是管理浮动行为的精确规则：

1. 左浮动盒子的左外边缘不能在其包含块的左边缘的左边。一个类似的规则适用于右浮动的元素。
2. 如果当前的盒子是左浮动的，并且在源文档中存在任何由早期元素生成的左浮动盒子，那么对于每个这样的早期盒子，要么当前盒子的左外边缘必须在早期盒子的右外边缘的右边，要么其顶部必须低于早期盒子的底部。类似的规则适用于右浮动的盒子。
3. 左浮动盒子的右外缘不能在它旁边的任何右浮动盒子的左外缘的右边。类似的规则适用于右浮动的元素。
4. 一个浮动盒子的外部顶部不得高于其包含块的顶部。当浮动盒子出现在两个塌陷的边缘之间时，浮动盒子的位置就像它有一个空的匿名块父本参与流动一样。这样一个父块的位置由边距折叠部分的规则来定义。
5. 浮动盒子的外顶不能高于源文档中较早的元素所产生的任何块或浮动盒子的外顶。
6. 一个元素的浮动盒子的外顶不能高于源文档中较早的一个元素所产生的任何包含框的线框的外顶。
7. 一个左浮动盒子的左边有另一个左浮动盒子，它的右外边缘不能在其包含块的右边缘的右边。(宽泛地说：一个左浮动盒子不能伸出右边缘，除非它已经尽可能地靠左了)。一个类似的规则适用于右浮动的元素。
8. 一个浮动的盒子必须被放在尽可能高的位置。
9. 左浮动的盒子必须尽可能地放在左边，右浮动的盒子尽可能地放在右边。相对于更靠左/靠右的位置，更高的位置是首选。

但在 CSS 2.2 中，如果在块格式化的上下文中，有一个正常流中的负垂直外边距，使得浮动的位置高于它在所有这些负外边距被设置为 0 时的位置，那么浮动的位置就没有被定义。

在这些规则中，对其他元素的引用仅指与浮动元素格式化上下文相同的其他元素。

这个 HTML 片段的结果是 b 浮动在右边:

```html
<p>
  a
  <span style="float: right">b</span>
</p>
```

如果 P 元素的宽度足够大，a 和 b 就会并排在一起。它可能看起来像这样：

![float-right](illustrations/float-right.png)

### 7.5.2. clear 属性

| 属性名   | clear    |
| -------- | -------- | ---- | ----- | ---- | -------- |
| 值       | `none    | left | right | both | inherit` |
| 初始值   | none     |
| 适用元素 | 块级元素 |
| 可继承性 | 否       |
| 百分数值 | N/A      |
| 适用媒体 | 视觉     |
| 计算值   | 见规定   |

这个属性表明一个元素的盒子的哪一边不能与先前的浮动盒子相邻。'clear' 属性不考虑元素本身或其他块格式化上下文下的浮动。

当应用于非浮动块级盒子时，其值具有以下含义：

- **left**
  要求盒子的顶部边界低于源文档中早期元素产生的任何左浮动盒子的底部外边缘。
- **right**
  要求盒子的顶部边界低于源文件中早期元素产生的任何右浮动盒子的底部外缘。
- **both**
  要求盒子的顶部边界低于源文件中早期元素产生的任何右浮动和左浮动盒子的底部外缘。
- **none**
  对盒子的浮动位置没有约束。

除了 'none' 以外的值可能会引入间隙。空隙抑制了边缘的折叠，并作为元素的边缘顶部的间隔。它被用来将元素垂直推过浮点。

计算一个设置了'clear'的元素的间隙，首先要确定该元素的上边界的假设位置。这个位置是如果元素的'clear'属性是'none'的话，实际的上边界会在哪里。

如果元素顶部边界的这个假设位置没有超过相关的浮动，那么就会引入间隙，并且根据 8.3.1 中的规则折叠边缘。

然后，间隙量被设置为以下两者中的较大者：

1. 将块的边框边缘与要清除的最低浮子的底部外边缘连在一起所需的量。
2. 将块的顶部边界置于其假设位置所需的量。

或者，间隙被精确地设置为将块的边界边缘与要清除的最低浮子的底部外边缘相平所需的量。

注意：这两种行为都是允许的，等待估值它们与现有网络内容的兼容性。未来的 CSS 规范将要求两者之一。

注意：间隙可以是负数或 0。

当该属性被设置在浮动元素上时，会导致对浮动元素定位规则的修改。一个额外的约束(#10)被添加。

浮动的顶部外缘必须低于所有早期的左浮动盒子的底部外缘(在 'clear: left' 的情况下)，或所有早期的右浮动盒子(在 'clear: right' 的情况下)，或两者('clear: both')。

注意。这个属性适用于 CSS1 中的所有元素。因此，实施方案可能在所有元素上都支持这个属性。在 CSS2 和 CSS2.2 中，'clear' 属性只适用于块级元素。因此，作者应该只在块级元素上使用这个属性。如果一个实现在行内元素上支持清除，而不是像上面解释的那样设置清除，该实现应该强制中断，并有效地插入一个或多个空行盒子(或者像第 9.5 节中描述的那样向下移动新的行盒子)，将清除的行内的行盒子顶部移动到各自的浮动盒子下面。

## 7.6. 绝对定位

在绝对定位模型中，一个盒子相对于其包含块是明确偏移的。它被完全从正常流中移除(它对后来的兄弟元素没有影响)。一个绝对定位的盒子为正常流的子代和绝对(但不是固定)定位的后代建立了一个新的包含块。然而，一个绝对定位的元素的内容并不在任何其他盒子周围流动。它们可能会掩盖另一个盒子的内容(或者自己被掩盖)，这取决于重叠的盒子的堆叠级别。

本规范中对 **绝对位置元素**(或其盒子)的引用意味着该元素的 'position' 属性值为 'absolute' 或 'fixed'。

### 7.6.1. 固定定位

固定定位是绝对定位的一个子类别。唯一的区别是，对于固定定位的盒子，包含块是由视口确定的。对于连续媒体，固定盒子在文档滚动时不会移动。在这一点上，它们与固定的背景图像类似。对于分页媒体，具有固定位置的盒子在每一页都会重复出现。这对于在每一页的底部放置签名等非常有用。固定位置的盒子如果大于页面面积，就会被剪掉。固定位置的盒子中在初始包含块中不可见的部分将不会被打印。

## 7.7. display, position 和 float 之间的关系

影响盒子生成和布局的三个属性：'display'、'position'和'float'--交互作用如下：

1. 如果'display'的值是'none'，那么'position'和'float'就不适用。在这种情况下，该元素不会生成任何盒子。
2. 否则，如果'position'的值是'absolute'或'fixed'，盒子就会被绝对定位，'float'的计算值是'none'，而 display 则根据下表设置。盒子的位置将由'top'、'right'、'bottom'和'left'属性以及盒子的包含块决定。
3. 否则，如果'float'的值不是'none'，盒子就会被浮动，'display'将按照下表设置。
4. 否则，如果该元素是根元素，'display'将根据下表进行设置，只是在 CSS 2.2 中没有定义'list-item'的指定值是否成为'block'或'list-item'的计算值。
5. 否则，其余的'display'属性值按规定适用。

| 指定值                                                                                                                                                  | 计算值     |
| ------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| inline-table                                                                                                                                            | table      |
| `inline, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block` | block      |
| 其他                                                                                                                                                    | 和规定相同 |

## 7.8. 对比正常流，浮动和绝对定位

为了说明正常流、相对定位、浮动和绝对定位之间的区别，我们根据以下 HTML 提供了一系列的例子：

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
  <head>
    <title>定位方案的对比</title>
  </head>
  <body>
    <p>
      body 内容的开头
      <span id="outer">
        外层内容的开头
        <span id="inner">内部内容</span>
        外层内容的结束
      </span>
      body 内容的结束
    </p>
  </body>
</html>
```

在本文档中，我们假设以下规则：

```css
body {
  display: block;
  font-size: 12px;
  line-height: 200%;
  width: 400px;
  height: 400px;
}

p {
  display: block;
}

span {
  display: inline;
}
```

在每个例子中，由外部和内部元素产生的盒子的最终位置是不同的。在每个插图中，插图左边的数字表示双倍行距(为清晰起见)的正常流动位置。

注意。本节中的图表是说明性的，不按比例。它们旨在强调 CSS 2.2 中各种定位方案之间的差异，而不打算作为所举例子的参考效果。

### 7.8.1. 正常流

请考虑以下不改变盒子正常流的外层和内层的 CSS 声明：

```css
#outer {
  color: red;
}

#inner {
  color: blue;
}
```

P 元素包含所有行内内容：匿名行内文本和两个 SPAN 元素。因此，所有的内容都将在一个行内格式化的背景下，在由 P 元素建立的包含块中布置出来，产生类似的效果：

### 7.8.2. 相对定位

为了看到相对定位的效果，我们指定。

```css
#outer {
  position: relative;
  top: -12px;
  color: red;
}
#inner {
  position: relative;
  top: 12px;
  color: blue;
}
```

文本正常地流向外部元素。然后，外部文本在第 1 行的末尾被流向其正常的流动位置和尺寸。然后，包含文本的行内盒子(分布在三行)作为一个单位被移位 '-12px'(向上)。

inner 的内容，作为 outer 的一个子项，通常会在 "of outer contents"(在第 1.5 行)之后流动。然而，内部内容本身相对于外部内容偏移了'12px'(向下)，回到了它们在第 2 行的原始位置。

请注意，outer 后面的内容不受外层相对位置的影响。

### 7.8.3. 浮动

现在考虑通过以下规则将内部元素的文本浮动到右边的效果。

```css
#outer {
  color: red;
}
#inner {
  float: right;
  width: 130px;
  color: blue;
}
```

文本正常流向 inner 盒子，inner 盒子被拉出流向并浮动到右边的空白处(其 'width' 已被明确分配)。浮动左边的线框被缩短，而文档中的剩余文本则流向它们。

### 7.8.4. 绝对定位

最后，我们考虑一下绝对定位的效果。考虑一下下面的外层和内层的 CSS 声明。

#outer {
position: absolute;
top: 200px; left: 200px;
宽度：200px。
颜色：红色。
}
#inner { color: blue }
导致外框的顶部相对于其包含块被定位。一个被定位的盒子的包含块是由最近的被定位的祖先建立的(或者，如果没有的话，就像我们的例子一样，初始包含块)。外围框的顶部在包含块的顶部以下'200px'，左侧在左侧的'200px'。outer 的子框相对于它的父框来说是正常流动的。

下面的例子显示了一个绝对定位的盒子，它是一个相对定位的盒子的孩子。尽管父元素的 outerbox 实际上没有偏移，但将其 'position' 属性设置为 'relative' 意味着它的 box 可以作为定位的后代的包含块。由于外框是一个被分割成几行的行内盒子，第一个行内盒子的顶部和左侧边缘(在下图中用粗虚线描述)作为 "顶部 "和 "左侧" 偏移的参考。

#outer {
位置：相对。
颜色：红色
}
#inner {
位置：绝对。
顶部：200px；左侧：-100px。
高度：130px；宽度：130px。
颜色：蓝色。
}

## 7.9. 分层显示

### 7.9.1. z-index 属性

| 属性名   | z-index  |
| -------- | -------- | --------- | -------- |
| 值       | `auto    | <integer> | inherit` |
| 初始值   | auto     |
| 适用元素 | 定位元素 |
| 可继承性 | 否       |
| 百分数值 | N/A      |
| 适用媒体 | 视觉     |
| 计算值   | 见规定   |

对于一个定位的盒子，'z-index'属性指定。

盒子在当前堆叠上下文中的堆叠级别。
盒子是否建立了一个堆叠上下文。
值有以下含义。

- `<integer>`
  这个整数是生成的盒子在当前堆叠上下文中的堆叠级别。盒子也会建立一个新的堆叠上下文。
- auto
  生成的盒子在当前堆叠上下文中的堆叠级别为 0。如果盒子有'position: fixed'或者它是根，它也建立一个新的堆叠上下文。

在本节中，"在前面" 的表述是指在用户面对屏幕时离用户更近。

在 CSS 2.2 中，每个盒子都有一个三维的位置。除了它们的水平和垂直位置外，盒子还位于 "Z 轴" 上，并被格式化为一个在另一个之上。当盒子在视觉上重叠时，Z 轴的位置尤其重要。本节讨论了盒子如何沿 Z 轴定位的问题。

渲染树在画布上的顺序是用堆叠上下文来描述的。堆叠上下文可以包含进一步的堆叠上下文。从其父元素堆叠上下文的角度来看，一个堆叠上下文是原子性的；其他堆叠上下文中的盒子不能出现在其任何盒子之间。

每个盒子属于一个堆叠上下文。在一个给定的堆叠上下文中，每个定位的盒子都有一个整数的堆叠级别，这是它在 Z 轴上相对于同一堆叠上下文中其他堆叠级别的位置。具有较大堆积层的盒子总是排在具有较低堆积层的盒子前面。盒子可以有负的堆叠级别。在一个堆叠上下文中具有相同堆叠级别的盒子按照文档树的顺序从后往前堆叠。

根元素形成根堆叠上下文。其他的堆叠上下文是由任何有 "z-index "计算值而不是 "auto "的定位元素(包括相对定位的元素)产生的。堆叠上下文不一定与包含块有关。在未来的 CSS 级别中，其他属性可能会引入堆叠上下文，例如 "不透明度"[CSS3COLOR]。

在每个堆叠上下文中，以下各层是按从后到前的顺序绘制的。

1. 形成堆叠上下文的元素的背景和边框。
2. 具有负的堆积层的子堆积上下文(最负的先)。
3. 正常流的、非行内级别的、非定位的子元素。
4. 非定位的浮子。
5. 正常流、行内级的、非定位的子代，包括行内表和行内块。
6. 堆栈级别为 0 的子堆栈上下文和堆栈级别为 0 的定位后裔。
7. 具有正的堆叠级别的子堆叠上下文(最少的正的先)。

在每个堆叠上下文中，堆叠级别为 0 的定位元素(在第 6 层)、非定位浮子(第 4 层)、行内块(第 5 层)和行内表(第 5 层)被涂抹，就像这些元素本身产生了新的堆叠上下文一样，除了它们的定位后裔和任何可能的子堆叠上下文参与到当前的堆叠上下文。

这种涂抹顺序被递归地应用于每个堆叠上下文。这个关于堆叠上下文绘画顺序的描述构成了附录 E 中详细规范性定义的概述。
