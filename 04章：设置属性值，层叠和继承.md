**目录：**

- [3. 设置属性值，层叠和继承](#3-设置属性值层叠和继承)
  - [3.1. 指定值，计算值和实际值](#31-指定值计算值和实际值)
    - [3.1.1. 指定值](#311-指定值)
    - [3.1.2. 计算值](#312-计算值)
    - [3.1.3. 使用值](#313-使用值)
    - [3.1.4. 实际值](#314-实际值)
  - [3.2. 继承](#32-继承)
    - [3.2.1. inherit 值](#321-inherit-值)
  - [3.3. @import 规则](#33-import-规则)
  - [3.4. 层叠](#34-层叠)
    - [3.4.1. 层叠顺序](#341-层叠顺序)
    - [3.4.2. !important 规则](#342-important-规则)
    - [3.4.3. 特指度](#343-特指度)

# 3. 设置属性值，层叠和继承

## 3.1. 指定值，计算值和实际值

一旦用户代理解析了一个文档并构建了一个文档树，它必须为该树中的每个元素，为适用于目标媒体类型的每个属性分配一个值。

一个属性的最终值是四步计算的结果：该值通过规范确定（"指定值"），然后解析为一个用于继承的值（"计算值"），然后在必要时转换为一个绝对值（"使用值"），最后根据本地环境的限制进行转换（"实际值"）。

### 3.1.1. 指定值

用户代理必须首先根据以下机制（按优先顺序）为每个属性分配一个指定值。

1. 如果层叠的结果是一个值，就使用它。除非，如果该值是 "inherit"，指定值在下个章节 inherit 值中定义。
2. 否则，如果该属性是继承的，并且该元素不是文档树的根，使用父元素的计算值。
3. 否则就使用该属性的初始值。每个属性的初始值都在属性的定义中指出。

### 3.1.2. 计算值

在层叠过程中，指定值被解析为计算值；例如，URI 被转换为绝对 URI，'em'和'ex' 单位被计算为像素或绝对长度。计算一个值从来不需要用户代理渲染文档。

用户代理不能解析为绝对 URI 的 URI 计算值是指定值。

一个属性的计算值是由该属性定义中的计算值一行指定的。关于指定值为 "inherit" 时的计算值的定义，请参见继承部分。

即使属性不适用，计算值也存在。然而，一些属性可能定义一个元素的属性的计算值取决于该属性是否适用于该元素。

### 3.1.3. 使用值

计算值尽可能在不对文档进行格式化的情况下进行处理。然而，有些值只能在文档被排版时才能确定。例如，如果一个元素的宽度被设定为其包含块的某个百分比，那么在确定包含区块的宽度之前，宽度是无法确定的。使用值是将计算值和解决任何剩余的依赖关系的结果，变成一个绝对值。

### 3.1.4. 实际值

一个使用值原则上是用于渲染的值，但用户代理可能无法在给定的环境中利用这个值。例如，用户代理可能只能渲染整数像素宽度的边框，因此可能不得不近似计算出的宽度，或者用户代理可能被迫只使用黑白色调而不是全色。实际值是应用任何近似值后的使用值。

## 3.2. 继承

如上所述，有些值是由文档树中的元素的子元素继承的。每个属性都定义了它是否被继承。

假设有一个 h1 元素，里面有一个强调元素（em）。

```html
<h1>
  标题
  <em>是</em>
  重要的！
</h1>
。
```

如果没有给 em 元素分配颜色，em 元素将继承父元素的颜色，所以如果 h1 的颜色是蓝色，em 元素也将同样是蓝色。

当继承发生时，元素会继承计算值。父元素的计算值成为子元素上的指定值和计算值。

例如，给定下面的样式表。

```css
body {
  font-size: 10pt;
}

h1 {
  font-size: 130%;
}
```

和这个文档片段。

```html
<body>
  <body>
    <h1>
      一个
      <em>大的</em>
      标题
    </h1>
    。
  </body>
</body>
```

h1 元素的'font-size'属性将有一个计算值'13pt'（130%乘以 10pt，父元素的值）。由于'font-size'的计算值是继承的，em 元素也会有'13pt'的计算值。如果用户代理没有可用的 13pt 字体，h1 和 em 的'font-size'的实际值可能是，例如，'12pt'。

请注意，继承遵循文档树，不被匿名盒所截获。

### 3.2.1. inherit 值

每个属性也可以有一个 "inherit" 的层叠值，这意味着，对于一个给定的元素，该属性将该元素的父级计算值作为指定值。inherit 值可以用来强制继承值，它也可以用于通常不被继承的属性。

如果在根元素上设置了 "inherit" 值，该属性就会被分配其初始值。

在下面的例子中，"color" 和 "background" 属性被设置在 body 元素上。在所有其他元素上，"color" 值将被继承，背景将是透明的。如果这些规则是用户样式表的一部分，白色背景上的黑色文本将在整个文档中被强制执行。

```css
body {
  color: black !important;
  background: white !important;
}

* {
  color: inherit !important;
  background: transparent !important;
}
```

## 3.3. @import 规则

@import 规则允许用户从其他样式表中导入样式规则。在 CSS 2.2 中，任何@import 规则必须在所有其他规则之前（除了@charset 规则，如果存在的话）。'@import' 关键字后面必须有要包括的样式表的 URI。一个字符串也是允许的；它将被解释为如果它周围有 url(..)。

下面几行的意思是相同的，并说明了两种"@import" 语法（一种是 "url()"，另一种是裸字符串）。

```css
@import 'mystyle.css';
@import url('mystyle.css');
```

为了使用户代理能够避免检索不支持的媒体类型的资源，作者可以指定与媒体相关的@import 规则。这些有条件的导入在 URI 后面指定逗号分隔的媒体类型。

下面的规则说明了如何使@import 规则与媒体相关。

```css
@import url('fineprint.css') print;
@import url('bluish.css') projection, tv;
```

在没有任何媒体类型的情况下，导入是无条件的。为媒介指定 "all" 也有同样的效果。只有当目标媒体与媒体列表匹配时，导入才会生效。

如果媒体列表中的一个项目是目标媒体或 "all"，则目标媒体与媒体列表匹配。

当同一个样式表在多个地方被导入或链接到一个文档时，用户代理必须处理（或像处理一样）每个链接，就像链接到一个单独的样式表一样。

## 3.4. 层叠

样式表可能有三个不同的来源：作者、用户和用户代理。

- **作者**。作者根据文档语言的惯例为一个源文档指定样式表。例如，在 HTML 中，样式表可能被包含在文档中或从外部链接。
- **用户**：用户可能能够为一个特定的文档指定样式信息。例如，用户可以指定一个包含样式表的文件，或者用户代理可以提供一个生成用户样式表的界面（或者表现得像它一样）。
- **用户代理**。符合要求的用户代理必须应用一个默认的样式表（或者表现得像他们一样）。一个用户代理的默认样式表应该以满足文档语言的一般表现期望的方式来表现文档语言的元素（例如，对于视觉浏览器，HTML 中的 em 元素用斜体字来表现）。

注意，用户可以修改影响默认样式表的系统设置（例如，系统颜色）。然而，一些用户代理的实现使其无法改变默认样式表的值。

来自这三个源头的样式表在范围上会重叠，它们根据层叠进行交互。

CSS 层叠给每个样式规则分配了一个权重。当有几个规则适用时，具有最大权重的规则优先。

默认情况下，作者样式表中的规则比用户样式表中的规则具有更大的权重。然而，对于"!important"的规则，优先权是相反的。所有的用户和作者规则都比用户代理的默认样式表中的规则有更大的权重。

### 3.4.1. 层叠顺序

为了找到一个元素/属性组合，用户代理必须应用以下排列顺序：

1. 找到所有适用于有关元素和属性的声明，用于目标媒体类型。如果相关的选择器与查询元素相匹配，并且目标媒体与包含声明的所有@media 规则上的媒体列表以及到达样式表的路径上的所有链接相匹配，则声明适用。
2. 根据重要性（正常或重要）和来源（作者、用户或用户代理）排序。以升序的方式排列：
   1. 用户代理声明
   2. 用户正常声明
   3. 作者正常声明
   4. 作者重要声明
   5. 用户重要声明
3. 根据选择器的特指度对具有相同重要性和来源的规则进行排序：更具体的选择器将覆盖更一般的选择器。伪元素和伪类分别被算作正常元素和类。
4. 最后，按指定的顺序排列：如果两个声明具有相同的权重、来源和特指度，则指定的后者获胜。在导入的样式表中的声明被认为是在样式表本身的任何声明之前。

除了个别声明的"!important"设置外，这个策略给予作者的样式表比读者的样式表更高的权重。用户代理必须让用户有能力关闭特定作者样式表的影响，例如通过一个下拉菜单。

### 3.4.2. !important 规则

CSS 试图在作者和用户的样式表之间建立一种权力平衡。默认情况下，作者的样式表中的规则优先于用户的样式表中的规则。

然而，为了平衡，一个"!important"的声明（分隔符"!"和关键字 "important"跟在声明后面）优先于一个普通的声明。作者和用户的样式表都可以包含"!important"声明，而用户的"!important"规则优先于作者的"!important"规则。这个 CSS 特性通过给有特殊要求的用户（大字体、颜色组合等）对表现形式的控制来提高文档的可访问性。

将一个简写属性（例如，"background"）声明为"!important"，相当于将其所有的子属性声明为"!important"。

在下面的例子中，用户的样式表中的第一条规则包含一个"!important"的声明，它覆盖了作者样式表中的相应声明。第二个声明也会因为被标记为"!important"而获胜。然而，用户样式表中的第三条规则不是"!important"的，因此将输给作者样式表中的第二条规则（它恰好在一个简写属性上设置样式）。另外，第三个作者规则将输给第二个作者规则，因为第二个规则是"!important"的。这表明"!important"声明在作者样式表中也有作用。

```css
/* 来自用户的样式表 */
p {
  text-indent: 1em !important;
}
p {
  font-style: italic !important;
}
p {
  font-size: 18pt;
}

/* 来自作者的样式表 */
p {
  text-indent: 1.5em !important;
}
p {
  font: normal 12pt sans-serif !important;
}
p {
  font-size: 24pt;
}
```

### 3.4.3. 特指度

一个选择器的特指度的计算方法如下：

- 如果声明来自一个 "style" 属性而不是一个带有选择器的规则，则计数为 1，否则为 0（=a）（在 HTML 中，一个元素的 "style" 属性的值是样式表规则。这些规则没有选择器，所以 a=1，b=0，c=0，d=0）。
- 计算选择器中 ID 属性的数量(=b)
- 计算选择器中其他属性和伪类的数量(= c)
- 计算选择器中的元素名称和伪元素的数量(= d)

特指度只基于选择器的形式。特别是，形式为"[id=p33]"的选择器被算作一个属性选择器（a=0, b=0, c=1, d=0），即使 id 属性在源文档的 DTD 中被定义为 "ID"。

将 a-b-c-d 这四个数字串联起来就得到了特指度。

一些例子：

```css
 * {}  /* a=0 b=0 c=0 d=0 -> 特指度=0,0,0,0 */
 li {}  /* a=0 b=0 c=0 d=1 --> 特指度=0,0,0,1 */
 li::first-line {} /* a=0 b=0 c=0 d=2 -> 特指度=0,0,0,2 */
 ul li {}  /* a=0 b=0 c=0 d=2 --> 特指度 = 0,0,0,2 */
 ul ol+li {}  /* a=0 b=0 c=0 d=3 --> 特指度=0,0,0,3 */
 h1 + *[rel=up]{} /* a=0 b=0 c=1 d=1 --> 特指度=0,0,1,1 */
 ul ol li.red {}  /* a=0 b=0 c=1 d=3 --> 特指度 = 0,0,1,3 */
 li.red.level {}  /* a=0 b=0 c=2 d=1 --> 特指度=0,0,2,1 */
 #x34y {}  /* a=0 b=1 c=0 d=0 --> 特指度=0,1,0,0 */
 style="" /* a=1 b=0 c=0 d=0 --> 特指度 = 1,0,0,0 */
```

```html
<head>
  <style type="text/css">
    #x97z {
      color: red;
    }
  </style>
</head>
<body>
  <p id="x97z" style="color: green"></p>
</body>
```

在上面的例子中，P 元素的颜色将是绿色。由于层叠规则，"style" 属性中的声明将优先于 STYLE 元素中的声明，因为它具有更高的特指度。
