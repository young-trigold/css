**目录：**

- [3. 层叠与继承](#3-层叠与继承)
  - [3.1. 继承](#31-继承)
  - [3.2. 层叠](#32-层叠)
    - [3.2.1. 层叠顺序](#321-层叠顺序)
    - [3.2.2. !important 规则](#322-important-规则)
    - [3.2.3. 特指度](#323-特指度)

# 3. 层叠与继承

要想掌握CSS，弄清样式层叠和继承这两个概念是关键。

## 3.1. 继承

如果浏览器在直接相关的样式中找不到某个属性的值，就会求助于继承机制，使用父元素的这个样式属性值。

例如：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      p {
        color: white;
        background-color: black;
        border: 1px solid yellow;
      }
    </style>
    <title>Document</title>
  </head>
  <body>
    <p>
      I like
      <!--继承父元素 p 的前景色-->
      <span>apples</span>
      and oranges.
    </p>
  </body>
</html>
```

本例关注的是浏览器应用于 span 元素（其父元素为 p) 的样式。这个文档并没有在针对 span 元素的样式中设定 color 属性值，但是浏览器显示该元素的文字内容时却使用了前景色 white。这个值系由父元素 p 继承而来。

令人挠头的是，并非所有 CSS 属性均可继承。这方面有条经验可供参考：与元素外观（文字颜色、字体等）相关的样式会被继承；与元素在页面上的布局相关的样式不会被继承。在样式中使用 inherit 这个特别设立的值可以强行实施继承，明确指示浏览器在该属性上使用父元素样式中的值。

例如：

```css
span {
  border: inherit;
}
```

此例定义了一条用于 span 元素的样式，其 border 属性值继承自父元素。因此 apples 就会出现黄色边框。

## 3.2. 层叠

样式表可能有三个不同的来源：作者、用户和用户代理。

- **作者**。作者根据文档语言的惯例为一个源文档指定样式表。例如，在 HTML 中，样式表可能被包含在文档中或从外部链接。
- **用户**：用户可能能够为一个特定的文档指定样式信息。例如，用户可以指定一个包含样式表的文件，或者用户代理可以提供一个生成用户样式表的界面（或者表现得像它一样）。
- **用户代理**。符合要求的用户代理必须应用一个默认的样式表（或者表现得像他们一样）。一个用户代理的默认样式表应该以满足文档语言的一般表现期望的方式来表现文档语言的元素（例如，对于视觉浏览器，HTML 中的 EM 元素用斜体字来表现）。

注意，用户可以修改影响默认样式表的系统设置（例如，系统颜色）。然而，一些用户代理的实现使其无法改变默认样式表的值。

来自这三个源头的样式表在范围上会重叠，它们根据层叠进行交互。

CSS 层叠给每个样式规则分配了一个权重。当有几个规则适用时，具有最大权重的规则优先。

默认情况下，作者样式表中的规则比用户样式表中的规则具有更大的权重。然而，对于"!important"的规则，优先权是相反的。所有的用户和作者规则都比用户代理的默认样式表中的规则有更大的权重。

### 3.2.1. 层叠顺序

为了找到一个元素/属性组合，用户代理必须应用以下排列顺序：

1. 找到所有适用于有关元素和属性的声明，用于目标媒体类型。如果相关的选择器与查询元素相匹配，并且目标媒体与包含声明的所有@media规则上的媒体列表以及到达样式表的路径上的所有链接相匹配，则声明适用。
2. 根据重要性（正常或重要）和来源（作者、用户或用户代理）排序。以升序的方式排列：
   1. 用户代理声明
   2. 用户正常声明
   3. 作者正常声明
   4. 作者重要声明
   5. 用户重要声明
3. 根据选择器的特指度对具有相同重要性和来源的规则进行排序：更具体的选择器将覆盖更一般的选择器。伪元素和伪类分别被算作正常元素和类。
4. 最后，按指定的顺序排列：如果两个声明具有相同的权重、来源和特指度，则指定的后者获胜。在导入的样式表中的声明被认为是在样式表本身的任何声明之前。

除了个别声明的"!important"设置外，这个策略给予作者的样式表比读者的样式表更高的权重。用户代理必须让用户有能力关闭特定作者样式表的影响，例如通过一个下拉菜单。

### 3.2.2. !important 规则

CSS 试图在作者和用户的样式表之间建立一种权力平衡。默认情况下，作者的样式表中的规则优先于用户的样式表中的规则。

然而，为了平衡，一个"!important"的声明（分隔符"!"和关键字 "important"跟在声明后面）优先于一个普通的声明。作者和用户的样式表都可以包含"!important"声明，而用户的"!important"规则优先于作者的"!important"规则。这个 CSS 特性通过给有特殊要求的用户（大字体、颜色组合等）对表现形式的控制来提高文档的可访问性。

将一个简写属性（例如，"background"）声明为"!important"，相当于将其所有的子属性声明为"!important"。

在下面的例子中，用户的样式表中的第一条规则包含一个"!important"的声明，它覆盖了作者样式表中的相应声明。第二个声明也会因为被标记为"!important"而获胜。然而，用户样式表中的第三条规则不是"!important"的，因此将输给作者样式表中的第二条规则（它恰好在一个简写属性上设置样式）。另外，第三个作者规则将输给第二个作者规则，因为第二个规则是"!important"的。这表明"!important"声明在作者样式表中也有作用。

```css
/* 来自用户的样式表 */
p {
  text-indent: 1em !important;
}
p {
  font-style: italic !important;
}
p {
  font-size: 18pt;
}

/* 来自作者的样式表 */
p {
  text-indent: 1.5em !important;
}
p {
  font: normal 12pt sans-serif !important;
}
p {
  font-size: 24pt;
}
```

### 3.2.3. 特指度

一个选择器的特指度的计算方法如下：

- 如果声明来自一个 "style" 属性而不是一个带有选择器的规则，则计数为 1，否则为 0（=a）（在 HTML 中，一个元素的 "style" 属性的值是样式表规则。这些规则没有选择器，所以 a=1，b=0，c=0，d=0）。
- 计算选择器中 ID 属性的数量(=b)
- 计算选择器中其他属性和伪类的数量(= c)
- 计算选择器中的元素名称和伪元素的数量(= d)

特指度只基于选择器的形式。特别是，形式为"[id=p33]"的选择器被算作一个属性选择器（a=0, b=0, c=1, d=0），即使 id 属性在源文档的 DTD 中被定义为 "ID"。

将 a-b-c-d 这四个数字串联起来就得到了特指度。

一些例子：

```css
 * {}  /* a=0 b=0 c=0 d=0 -> 特指度=0,0,0,0 */
 li {}  /* a=0 b=0 c=0 d=1 --> 特指度=0,0,0,1 */
 li::first-line {} /* a=0 b=0 c=0 d=2 -> 特指度=0,0,0,2 */
 ul li {}  /* a=0 b=0 c=0 d=2 --> 特指度 = 0,0,0,2 */
 ul ol+li {}  /* a=0 b=0 c=0 d=3 --> 特指度=0,0,0,3 */
 h1 + *[rel=up]{} /* a=0 b=0 c=1 d=1 --> 特指度=0,0,1,1 */
 ul ol li.red {}  /* a=0 b=0 c=1 d=3 --> 特指度 = 0,0,1,3 */
 li.red.level {}  /* a=0 b=0 c=2 d=1 --> 特指度=0,0,2,1 */
 #x34y {}  /* a=0 b=1 c=0 d=0 --> 特指度=0,1,0,0 */
 style="" /* a=1 b=0 c=0 d=0 --> 特指度 = 1,0,0,0 */
```

```html
<head>
  <style type="text/css">
    #x97z {
      color: red;
    }
  </style>
</head>
<body>
  <p id="x97z" style="color: green"></p>
</body>
```

在上面的例子中，P 元素的颜色将是绿色。由于层叠规则，"style" 属性中的声明将优先于 STYLE 元素中的声明，因为它具有更高的特指度。
