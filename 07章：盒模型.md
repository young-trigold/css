**目录：**

- [7. 盒模型](#7-盒模型)
  - [7.1. 盒模型基础](#71-盒模型基础)
    - [7.1.1. 重要概念](#711-重要概念)
    - [7.1.2. 包含盒子](#712-包含盒子)
  - [7.2. 盒子的类型和尺寸](#72-盒子的类型和尺寸)
    - [7.2.1. 改变显示类型](#721-改变显示类型)
    - [7.2.2. 改变尺寸](#722-改变尺寸)
  - [7.3. 块级盒子](#73-块级盒子)
    - [7.3.1. 横向格式化](#731-横向格式化)
      - [7.3.1.1. 1 个 auto](#7311-1-个-auto)
      - [7.3.1.2. 多个 auto](#7312-多个-auto)
    - [7.3.2. 替换性块级元素](#732-替换性块级元素)
    - [7.3.3. 纵向格式化](#733-纵向格式化)
  - [7.4. 行内盒子](#74-行内盒子)
  - [7.5. 行内块级盒子](#75-行内块级盒子)

# 7. 盒模型

本章全面阐述 CSS 视觉渲染理论。

## 7.1. 盒模型基础

对于任何 HTML 元素，CSS 都会在逻辑上生成一个对元素层层包围的盒子。这个盒子从中心到外围依次是：内容区，内边距，边框，外边距。内边距，边框，外边距都有针对每一条边的属性，例如：border-bottom, margin-left, padding-right 等等。
默认情况下，内容区的背景出现在内边距范围内。外边距始终是不可见的。

### 7.1.1. 重要概念

下面简要说明一下要讨论的不同显示方式的盒子，以及一些术语。

- 常规流动

常规流动是指 HTML 元素从上往下，从左往右的布局方式。除非元素浮动，定位，放入弹性盒子或采用网格布局了，不然 HTML 元素都采用常规流动。

- 块级盒子

块级盒子是指块级元素生成的盒子。块级盒子在常规流动下，前后都会换行，因此是纵向排列的。常见的生成 块级盒子的 HTML 元素有：div，p，h1-h6。

- 行内盒子

行内盒子是指行内元素生成的盒子。这种盒子在常规流动下前后不换行。常用的生成 行内盒子的 HTML 元素有：span, strong。

- 行内块级盒子

这种盒子外部特征像行内盒子，内部像块级盒子。这种盒子的行为和替换性元素相似。

### 7.1.2. 包含盒子

还有一种盒子需要深入说明：包含盒子。

每个元素的盒子相对上都有其包含盒子，包含盒子也叫元素盒子的布局上下文。

在采用常规流动方式渲染的文本中，包含盒子一般是元素的父元素，而且 display 属性为 block。

## 7.2. 盒子的类型和尺寸

HTML 元素几乎都有 display 属性。可以取值：none, inline, block, flex, grid, table 等一系列值。

### 7.2.1. 改变显示类型

假设 nav 元素中有一系列链接，而我们相纵向布局，为此我们可以将 a 元素的 display 属性改为 block。

```html
<nav>
  <a href="http://www.google.com/">google</a>
  <a href="http://www.baidu.com/">baidu</a>
  <a href="http://www.github.com/">github</a>
  <a href="http://www.stackoverflow.com/">stackoverflow</a>
</nav>
```

### 7.2.2. 改变尺寸

默认情况下生成 块级盒子的元素的大小(width，或者 height)等于内容区的大小。这是由于 box-sizing 默认为 content-box。

在这种情况下，我们给元素设置的大小只是给内容区设置的。如果加上内边距的话，总的可见区域的大小就是内边距和内容区大小的合并。因此比较麻烦。

我们通常设置 box-sizing 为 border-box，这表示你给元素设置的大小等于内容区，内边距和边框的大小的合并，因此我们就不用时刻关注一个元素的内边距。

```css
* {
  box-sizing: border-box;
}
```

## 7.3. 块级盒子

### 7.3.1. 横向格式化

横向格式化比较复杂。

常规流动下，块级盒子的整个宽度等于包含盒子的宽度。

假设，box-sizing 为 border-box。现在 1 个 div 元素中有 2 个 p 元素。div 元素的宽度为 30em，那么每个 p 元素的 width 属性值和外边距之和就等于 30em。

横向格式化属性有 7 个：除了 width 属性之外。还有内边距，边框，外边距对应的横向属性。

这 7 个属性的值加在一起等于包含盒子的宽度。而这一宽度通常为块级元素父元素的 width 值（块级元素的父元素几乎都是块级元素）。

#### 7.3.1.1. 1 个 auto

在这 7 个属性中，只有 3 个属性的值能设置为 auto：width, margin-left, margin-right。剩下的几个值要么使用默认值 0，要么使用具体的值。

如果把这 3 个属性都设置为具体的值，用 CSS 术语来说就是过约束了，在这种情况下，margin-right 将被设置为 auto，即补全值。

例如，给定 box-sizing 为 border-box，p 元素的父元素 width 为 500px，且给定 p 的 width, margin-left, margin-right 都为 100px，那么实际情况可能不是我们所想的那样。实际上，p 的 margin-left 属性和 width 属性不会改变，而 margin-right 会被设置为 auto，即补全值 300px。

在这 3 个属性中，如果 1 个属性被设为 auto，其他属性被设为具体的值，那么这个 auto 值就会被计算为补全的宽度值。

例如，如果左右外边距都设为具体的值，且 width 设置为 auto 或者不设置，那么 width 就是补全值。上个例子中，margin-left 和 margin-right 设置为 100px，那么 width 就是 300px。

#### 7.3.1.2. 多个 auto

如果左右边距都设置为 auto，width 设置为具体的值，那么这种情况显示效果就是：可见区域（内容区+内边距+边框）居中显示，其长度就是设置的具体值，而左右外边距的宽度相等，其值是补全值的一半。

例如，width 被设置为 300px，那么 margin-left 和 margin-right 都是 100px。

在常规流动下，这种方式可以使得元素可见区域在父元素盒子中居中显示。

如果一个边距被设置为具体值，另一个边距被设置为 auto，且 width 也被设置为 auto，那么在这种情况下，被设置为 auto 的那个外边距的宽度为 0，width 值就是补全值。

如果三个属性都被设置为 auto 呢？答案是外边距被设置为 0，width 为补全值，即父元素的宽度。实际上这和默认情况是一样的：外边距和 width 都没有显式声明，那么 块级盒子的 width 值就是父元素的宽度。

### 7.3.2. 替换性块级元素

到目前为止，我们都在讨论常规流动下非替换性元素生成的 块级盒子的横向格式化。对于替换性元素生成的 块级盒子处理就要简答一些。前面所讲的规则都成立，不过有个例外是 width 为 auto 时，元素的 width 等于替换内容自身的宽度。

不过，我们可以显式指定这个 width 值，就会覆盖默认的替换性内容宽度。当我们明确设置 width 值时，其 height 会根据比例放缩，单独设置 height 也是一样的。除非我们将 width 和 height 都明确设置。

### 7.3.3. 纵向格式化

块级盒子的纵向格式化与横向格式化类似，但也有一些不同。元素的默认 height 值是元素内容的高度，而不是像 width 是其父元素的 width 值。

与横向格式化一样，纵向格式化也涉及 7 个属性。这 7 个属性中能设置为 auto 的属性和横向格式化类似：margin-top, margin-bottom, height。

在 margin-top 和 margin-bottom 都设置为 auto，且 height 为具体值的情况下，和横向格式化不同，marign-top 和 margin-bottom 都将设置为 0。

纵向格式化还有一点不同的是，纵向的外边距会发生折叠。

例如：

```css
ul > li {
  margin-top: 10px;
  margin-bottom: 15px;
}
```

这个例子中，每个项目列表都有 10px 的上外边距和 15px 的下外边距，然而多个列表项目之间的边距不是 25px，而是 15px。这是因为，相邻的外边距在纵轴上折叠的，较小的外边距被较大的覆盖了。

## 7.4. 行内盒子

除了块级元素之外，行内元素是最为常见的。常见的非替换性行内元素有：em, a。替换性元素：img。

## 7.5. 行内块级盒子
