**目录：**

- [4. 层叠和继承](#4-层叠和继承)
  - [4.1. @import 规则](#41-import-规则)
    - [4.1.1. 条件 @import 规则](#411-条件-import-规则)
  - [4.2. 值处理](#42-值处理)
    - [4.2.1. 声明值](#421-声明值)
    - [4.2.2. 层叠值](#422-层叠值)
    - [4.2.3. 指定值](#423-指定值)
    - [4.2.4. 计算值](#424-计算值)
    - [4.2.5. 使用值](#425-使用值)
    - [4.2.6. 实际值](#426-实际值)
  - [4.3. 层叠](#43-层叠)
    - [4.3.1. 层叠顺序](#431-层叠顺序)
    - [4.3.2. 层叠来源](#432-层叠来源)
    - [4.3.3. !important 声明](#433-important-声明)
    - [4.3.4. 特指度](#434-特指度)
  - [4.4. 缺省](#44-缺省)
    - [4.4.1. 初始值](#441-初始值)
    - [4.4.2. 继承](#442-继承)
    - [4.4.3. 显式缺省](#443-显式缺省)
      - [4.4.3.1. initial 关键字](#4431-initial-关键字)
      - [4.4.3.2. inherit 关键字](#4432-inherit-关键字)
      - [4.4.3.3. unset 关键字](#4433-unset-关键字)

# 4. 层叠和继承

CSS 的基本设计原则之一是层叠，它允许几个样式表影响一个文档的呈现。当不同的声明试图为相同的元素/属性组合设置一个值时，必须以某种方式解决这些冲突。

当没有声明试图为一个元素/属性组合设置一个值时，就会出现相反的问题。在这种情况下，可以通过继承的方式或通过查看属性的初始值来找到一个值。

层叠和缺省过程将一组声明作为输入，并为每个元素的每个属性输出一个指定值。

本规范中描述了为文档中所有元素上的所有属性寻找指定值的规则。在页面上下文及其外边距盒子中寻找指定值的规则在[css-page-3]中描述。

注意：本章为 [CSS Cascading and Inheritance Level 3](https://www.w3.org/TR/css-cascade-3/)。

## 4.1. @import 规则

@import 规则允许用户从其他样式表导入样式规则。如果一个@import 规则指的是一个有效的样式表，用户代理必须把该样式表的内容当作是代替@import 规则而写的，但有两个例外：

- 如果一个特性（如@namespace 规则）明确地定义了它只适用于一个特定的样式表，而不是任何导入的样式表，那么它就不适用于导入的样式表。

- 如果一个特性依赖于样式表中两个或多个结构体的相对排序（比如要求@namespace 规则前面不能有除@import 以外的任何其他规则），那么它只适用于同一样式表中的结构体之间。

例如，从导入的样式表中的声明与层叠交互，就像它们在@import 的地方被写进样式表一样。

任何@import 规则必须先于样式表中所有其他有效的 at-rules 和样式规则（忽略@charset），否则@import 规则是无效的。@import 的语法是:

```css
@import [ <url> | <string> ] <media-query-list>?;
```

其中`<url>`或`<string>`给出了要导入的样式表的 URL，而可选的`<media-query-list>`（导入条件）说明了它所适用的条件。

如果提供了一个`<string>`，它必须被解释为一个具有相同值的`<url>`。

下面几行的意思是相等的，并说明了两种@import 语法（一种是 url()，一种是裸字符串）。

```css
@import 'mystyle.css' @import url('mystyle.css');
```

### 4.1.1. 条件 @import 规则

条件导入允许取决于媒体的导入。在没有任何导入条件的情况下，导入是无条件的。(为`<media-query-list>`指定所有条件也有同样的效果。)如果导入条件不匹配，导入的样式表中的规则就不适用，就像导入的样式表被包裹在一个具有给定媒体查询的@media 块中一样。

下面的规则说明了如何使@import 规则依赖于媒体：

```css
@import url('fineprint.css') print;
@import url('bluish.css') projection, tv;
@import url('narrow.css') handheld and (max-width: 400px);
```

因此，只要媒体查询不匹配，用户代理可以避免获取一个依赖媒体的导入。

导入条件的估值和完整语法由媒体查询规范[MEDIAQ]定义。

## 4.2. 值处理

一旦用户代理解析了一个文档并构建了一个文档树，它就必须为文档树中的每个元素以及格式化结构中的每个盒子分配一个适用于目标媒体类型的属性值。

一个特定元素或盒子的 CSS 属性的最终值是一个多步骤计算的结果：

1. 首先，收集适用于一个元素的所有声明值，每个元素上的每个属性都是如此。适用于该元素的声明值可能是 0 或许多。
2. 层叠产生层叠值。每个元素的每个属性最多只有一个层叠值。
3. 缺省产生指定值。每个元素的每个属性正好有一个指定值。
4. 解决属性值的依赖会产生计算值。每个元素的每个属性正好有一个计算值。
5. 格式化文档会产生使用值。一个元素只有在一个给定的属性适用于该元素时才有一个使用值。
6. 最后，根据显示环境的限制，使用的值被转换为实际值。和使用值一样，一个元素上可能有也可能没有一个给定属性的实际值。

### 4.2.1. 声明值

每个应用于元素的属性声明都会为与该元素相关的该属性贡献一个声明值。

为了找到声明值，实现必须首先确定适用于每个元素的所有声明。一个声明适用于一个元素时，下列条件必须成立：

- 它属于一个当前适用于这个文档的样式表。
- 它没有被条件规则[CSS-CONDITIONAL-3]中的一个错误条件所限定。
- 它属于一个样式规则，其选择器与该元素相匹配。[SELECT]
- 它在语法上是有效的：声明的属性是一个已知的属性名，而且声明值与该属性的语法相符。

适用的声明值，对于每个元素上的每个属性，形成一个声明值的列表。

层叠机制对这个列表进行优先级排序。以选择一个单一的“获胜值”。

### 4.2.2. 层叠值

层叠的值代表层叠的结果：它是赢得层叠的声明值（在层叠的输出中被排序在前）。如果层叠的输出是一个空列表，就没有层叠的值。

### 4.2.3. 指定值

指定的值是样式表作者为该元素设计的给定属性的值。它是把层叠的值通过默认过程的结果，保证每个元素上的每个属性都存在一个指定的值。

在许多情况下，指定的值是层叠的值。然而，如果根本就没有层叠值，指定的值就会被默认。当 CSS-wide 关键字是一个属性的层叠值时，会被特别处理，按照该关键字的要求设置指定的值，见§7.3 明确的默认。

### 4.2.4. 计算值

计算值是按照属性定义表的 "计算值 "一行中的定义对指定值进行解析的结果，通常是将其绝对化以准备继承。

注意：计算值是在继承过程中从父辈转移到子辈的值。由于历史原因，它不一定是 getComputedStyle()函数返回的值，该函数有时会返回使用的值。[CSSOM]此外，计算值是一个抽象的数据表示：它们的定义反映了该数据表示，而不是该数据如何被序列化。例如，序列化规则通常允许省略某些在解析过程中隐含的值；但这些值仍然是计算值的一部分。

一个指定的值可以是绝对值（即不相对于另一个值，如 red 或 2mm）或相对值（即相对于另一个值，如 auto，2em）。计算一个相对值通常会将其绝对化。
相对单位的值（em、ex、vh、vw）必须通过与适当的参考尺寸相乘而成为绝对值
某些关键词（例如，更小的，更粗的）必须根据其定义进行替换
某些属性的百分数必须乘以一个参考值（由属性定义）。
有效的相对 URL 必须被解析为绝对的。
见下表的例子（f）、（g）和（h）。

注意：一般来说，计算值尽可能地解决指定的值，而不需要铺设文档或执行其他昂贵的或难以并行的操作，如解决网络请求或从元素和它的父辈以外的地方检索值。

即使属性不适用时，计算值也存在。然而，一些属性可能会根据该属性是否适用于该元素而改变它们确定计算值的方式。

### 4.2.5. 使用值

使用值是将计算值和完成任何剩余计算的结果，使其成为文档格式化中使用的绝对理论值。

例如，在不知道该元素的祖先布局的情况下，width: auto 的声明不能被解析为一个长度，所以计算值是 auto，而使用值是一个绝对长度，例如 100px。[CSS2]

另一个例子是，一个`<div>`可能有一个计算的 break-before 值为 auto，但通过其第一个子元素的传播而获得一个使用的 break-before 值为 page。[css-break-3]

如果一个属性不适用于这个元素或盒子类型--如其 "适用于 "行中所指出的--那么它对该类型的盒子或元素没有直接的格式化效果，因此对该属性没有使用值。

例如，flex 属性对不是弹性子项目的元素没有使用价值。

注意：一些不适用于某些元素或盒子的属性仍然可能有间接的格式化效果：它们的计算值可能会在计算其他对元素或盒子有影响的属性或单元时被考虑进去；继承的属性也经常被设置在它们不适用于的元素上，以便让它们继承到它们适用的后代中，包括这些后代是匿名盒子的情况。

即使书写模式和文本方向不适用于表格行，在这样的盒子上设置它们仍然会影响字体相对单位的计算，例如 ch，因此可能会影响任何需要`<length>`的属性。

在 HTML p 元素（默认为 display: block）上设置 text-transform 会有影响，尽管 text-transform 只适用于行内盒子，因为该属性会继承到段落的匿名根行内盒子。

注意：一个定义为适用于 "所有元素" 的属性适用于所有元素和显示类型，但不一定适用于所有伪元素类型，因为伪元素通常有自己的特定渲染模型或其他限制。然而，::before 和::after 伪元素被定义为几乎完全像正常元素一样生成盒子，因此被定义为接受所有适用于 "所有元素 "的属性。关于伪元素的更多信息，请参见[CSS-PSEUDO-4]。

### 4.2.6. 实际值

一个用过的值原则上是可以使用的，但用户代理可能无法在特定的环境中使用这个值。例如，用户代理可能只能呈现整数像素宽度的边框，因此可能必须近似使用的宽度。另外，一个元素的字体大小可能需要根据字体的可用性或字体大小调整属性的值来调整。实际值是进行任何此类调整后的使用值。

注意：通过探测元素的实际值，可以了解到很多关于文档是如何布局的。然而，并非所有的信息都记录在实际值中。例如，page-break-after 属性的实际值并不反映该元素之后是否有分页符。同样地，孤儿的实际值并不反映某个元素中有多少个孤儿行。见下表的例子（j）和（k）。

## 4.3. 层叠

**层叠** 接收一个无序的列表，该列表是给定元素上给定属性的声明值，按照下面确定的声明优先级对它们进行排序，并输出一个单一的层叠值。

### 4.3.1. 层叠顺序

层叠会根据以下标准对声明进行排序，优先级由高到低排列：

- **来源和重要性**
  一个声明的来源是基于它的来源，而它的重要性是指它是否用 !important 声明（见下文）。各种来源的优先级是，按降序排列：

1. 过渡声明 [css-transitions-1]
2. 重要的用户代理声明
3. 重要的用户声明
4. 重要的作者声明
5. 动画声明 [css-animations-1]
6. 正常的作者声明
7. 正常的用户声明
8. 正常的用户代理声明

来自这个列表中较早来源的声明会覆盖自较晚来源的声明。

- **特指度**
  选择器模块[SELECT]描述了如何计算一个选择器的特指度。每个声明的特指度与它所出现的样式规则相同。在这一步中，不属于一个样式规则的声明（比如一个样式属性的内容）被认为具有比任何选择器更高的特指度。具有最高特指度的声明会被选择。

- **出现顺序**
  文档顺序中最后的声明获胜。为了这个目的。
  来自导入的样式表的声明被排序，就像它们的样式表被替换成了@import 规则一样。
  来自独立于原生文档的样式表的声明被视为以链接顺序连接起来的，由主文档语言决定。
  来自样式属性的声明是根据样式属性出现的元素的文档顺序来排序的，并且都放在任何样式表之后。

**层叠的输出** 是一个（可能是空的）排序的列表，其中包括每个元素上的每个属性的声明值。

### 4.3.2. 层叠来源

每个样式规则都有一个层叠来源，它决定了它在哪里进入层叠。CSS 定义了三个核心来源：

- **作者来源**
  作者根据文档语言的惯例为一个源文档指定样式表。例如，在 HTML 中，样式表可以包含在文档中，也可以从外部链接。

- **用户来源**
  用户可能能够为一个特定的文档指定样式信息。例如，用户可以指定一个包含样式表的文件，或者用户代理可以提供一个生成用户样式表的界面（或者表现得像它一样）。

- **用户代理来源**
  符合要求的用户代理必须应用一个默认的样式表（或者表现得像他们一样）。一个用户代理的默认样式表应该以满足文档语言的一般表现期望的方式呈现文档语言的元素（例如，对于视觉浏览器，HTML 中的 em 元素使用斜体字呈现）。例如，见 HTML 用户代理样式表。[HTML]

对 CSS 的扩展定义了以下额外的来源：

- **动画来源**
  CSS 动画[css-animations-1]在运行时产生代表其效果的 "虚拟" 规则。

- **过渡来源**
  与 CSS 动画一样，CSS 过渡[css-transitions-1]在运行时产生代表其效果的 "虚拟" 规则。

### 4.3.3. !important 声明

CSS 试图在作者和用户的样式表之间建立一种权力平衡。默认情况下，作者的样式表中的规则优先于用户的样式表中的规则，而用户的样式表又优先于用户代理的默认样式表中的规则。为了平衡这一点，一个声明可以被标记为重要的，这将增加它在层叠中的权重并颠倒优先顺序。

一条声明是 **重要的**，如果它有一个 !important 注解，也就是说，声明的值中的最后两个（非空格，非注释）符号是分隔符号 "!"，之后紧跟着是标识符符号 "impotant"。所有其他的声明称为 **正常的**。

```css
[hidden] {
  display: none !important;
}
```

一个重要的声明优先于一个正常的声明。作者和用户的样式表可以包含重要声明，而用户的重要声明优先于作者的重要声明。这个 CSS 特性通过给有特殊要求的用户（大字体、颜色组合等）对表现形式的控制来提高文档的可访问性。

所有来源的重要声明都优先于动画的声明。这允许作者在重要情况下覆盖动画值。(动画值通常优先于所有其他规则。) [css-animations-1] 。

用户代理样式表也可能包含重要的声明。这些声明覆盖了所有作者和用户的声明。

在下面的例子中，用户样式表的第一条规则包含一个!important 声明，它覆盖了作者样式表的相应声明。第二条规则中的声明也会因为被标记为!important 而获胜。然而，用户样式表中的第三个声明不是!important 的，因此会输给作者样式表中的第二条规则（它恰好在一个简写属性上设置样式）。另外，第三个作者规则将输给第二个作者规则，因为第二个声明是!important 的。这表明!important 声明在作者样式表中也有作用。

```css
/* 来自用户代理样式表 */
p {
  text-indent: 1em !important;
}
p {
  font-style: italic !important;
}
p {
  font-size: 18pt;
}

/* 来自作者样式表 */
p {
  text-indent: 1.5em !important;
}
p {
  font: normal 12pt sans-serif !important;
}
p {
  font-size: 24pt;
}
```

| 属性        | 获胜值     |
| ----------- | ---------- |
| text-indent | 1em        |
| font-style  | italic     |
| font-size   | 12pt       |
| font-family | sans-serif |

### 4.3.4. 特指度

一个选择器的特指度计算如下：

- 计算选择器中 ID 选择器的数量(= a)
- 计算选择器中的类选择器、属性选择器和伪类的数量(= b)
- 计算选择器中类型选择器和伪元素的数量(=c)
- 忽略通用选择器

否定伪类里面的选择器和其他的选择器一样被计算，但是否定本身并不作为一个伪类计算。

将 a-b-c 这三个数字串联起来（在一个有大基数的数字系统中），就可以得到特指度。

例如：

```css
*  /* a=0 b=0 c=0 -> 特指度=0 */
LI /* a=0 b=0 c=1 -> 特指度=1 */
UL LI /* a=0 b=0 c=2 --> 特指度=2 */
UL OL+LI /* a=0 b=0 c=3 --> 特指度=3 */
H1 + _[REL=up] /* a=0 b=1 c=1 -> 特指度=11 */
UL OL LI.red /* a=0 b=1 c=3 -> 特指度=13 */
LI.red.level /* a=0 b=2 c=1 -> 特指度=21 */
#x34y /* a=1 b=0 c=0 -> 特指度=100 */
#s12:not(FOO) /* a=1 b=0 c=1 -> 特指度=101 \*/
```

注意：同一简单选择器的重复出现是允许的，并且确实增加了特指度。

注意：样式属性中的声明适用于该属性所属的元素。在层叠中，这些声明被认为具有作者的来源和比任何选择器更高的特定性。CSS2.1 定义了样式表和样式属性是如何层叠的。

## 4.4. 缺省

当层叠不产生一个值时，必须以其他方式找到指定的值。继承的属性通过继承从它们的父元素中获取它们的默认值；所有其它的属性都采取它们的初始值。作者可以通过 inherit 和 initial 关键字明确要求继承或初始化。

### 4.4.1. 初始值

每个属性都有一个初始值，在该属性的定义表中定义。如果该属性不是一个继承的属性，并且层叠没有产生一个值，那么该属性的指定值就是其初始值。

### 4.4.2. 继承

继承将属性值从父元素传播到它们的子元素。一个元素上的属性的继承值是该元素的父元素上的属性的计算值。对于根元素，它没有父元素，继承值是属性的初始值。

伪元素根据为每个伪元素描述的虚构的标签序列来继承。[SELECT]

有些属性是继承的属性，这在其属性定义表中有定义。这意味着，除非层叠的结果是一个值，否则该值将由继承来决定。

一个属性也可以明确地被继承。参见继承关键字。

注意：继承遵循文档树，不被匿名框拦截，也不被框树的操作所影响。

### 4.4.3. 显式缺省

下面定义了几个 CSS 范围内的属性值；声明一个属性拥有这些值，明确地指定了一个特定的默认行为。正如 CSS 值和单位级别 3[css-values-3]中所规定的，所有的 CSS 属性都可以接受这些值。

#### 4.4.3.1. initial 关键字

如果一个属性的层叠值是 initial 关键字，那么该属性的指定值就是其初始值。

#### 4.4.3.2. inherit 关键字

如果一个属性的层叠值是 inherit 关键字，那么该属性的指定值和计算值就是继承值。

#### 4.4.3.3. unset 关键字

如果一个属性的层叠值是 unset 关键字，那么如果它是一个继承的属性，这将被视为继承值，如果它不是，这将被视为初始值。这个关键字有效地抹去了在层叠中较早出现的所有声明的值，正确地继承或不继承都适合于该属性（或一个简写的所有长文）。
