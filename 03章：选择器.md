**目录：**

- [3. 选择器](#3-选择器)
  - [3.1. 选择器简介](#31-选择器简介)
  - [3.2. 选择器语法](#32-选择器语法)
  - [3.3. 选择器组](#33-选择器组)
  - [3.4. 简单选择器](#34-简单选择器)
    - [3.4.1. 类型选择器](#341-类型选择器)
      - [3.4.1.1. 类型选择器和命名空间](#3411-类型选择器和命名空间)
    - [3.4.2. 通用选择器](#342-通用选择器)
      - [3.4.2.1. 通用选择器和命名空间](#3421-通用选择器和命名空间)
    - [3.4.3. 属性选择器](#343-属性选择器)
      - [3.4.3.1. 属性存在和值选择器](#3431-属性存在和值选择器)
      - [3.4.3.2. 子串匹配属性选择器](#3432-子串匹配属性选择器)
      - [3.4.3.3. 属性选择器和命名空间](#3433-属性选择器和命名空间)
      - [3.4.3.4. DTD 中的默认属性值](#3434-dtd-中的默认属性值)
    - [3.4.4. 类选择器](#344-类选择器)
    - [3.4.5. ID 选择器](#345-id-选择器)
    - [3.4.6. 伪类](#346-伪类)
      - [3.4.6.1. 动态伪类](#3461-动态伪类)
      - [3.4.6.2. :target](#3462-target)
      - [3.4.6.3. :lang](#3463-lang)
      - [3.4.6.4. UI 元素状态伪类](#3464-ui-元素状态伪类)
      - [3.4.6.5. 结构性伪类](#3465-结构性伪类)
    - [3.4.7. 否定伪类](#347-否定伪类)
  - [3.5. 伪元素](#35-伪元素)
    - [3.5.1. ::first-line 伪元素](#351-first-line-伪元素)
      - [3.5.1.1. 第一个格式化行定义](#3511-第一个格式化行定义)
    - [3.5.2. ::first-letter 伪元素](#352-first-letter-伪元素)
    - [3.5.3. ::before 和 ::after 伪元素](#353-before-和-after-伪元素)
  - [3.6. 组合符](#36-组合符)
    - [3.6.1. 后代元素组合符](#361-后代元素组合符)
    - [3.6.2. 子元素组合符](#362-子元素组合符)
    - [3.6.3. 兄弟元素组合符](#363-兄弟元素组合符)
      - [3.6.3.1. 下一个兄弟元素组合符](#3631-下一个兄弟元素组合符)
      - [3.6.3.2. 后续兄弟元素组合符](#3632-后续兄弟元素组合符)

# 3. 选择器

注意：本章为 [Selectors Level 3](https://www.w3.org/TR/selectors-3/)。

## 3.1. 选择器简介

一个选择器代表一个结构。这个结构可以作为一个条件（例如在 CSS 规则中），决定选择器在文档树中匹配哪些元素，或者作为对应于该结构的 HTML 或 XML 片段的平面描述。

选择器的范围可以从简单的元素名称到丰富的上下文表示。

下表总结了选择器的语法：

| 模式                           | 代表元素                                                                         | 描述                                                                           | 级别       |
| ------------------------------ | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ---------- | --- |
| \*                             | 任何元素                                                                         | 通用选择器                                                                     | 2          |
| E                              | 一个 E 类型的元素                                                                | 类型选择器                                                                     | 1          |
| E[foo]                         | 一个具有 "foo" 属性的 E 元素                                                     | 属性选择器                                                                     | 2          |
| E[foo="bar"]                   | 一个 E 元素，其 "foo" 属性值正好等于 "bar"                                       | 属性选择器                                                                     | 2          |
| E[foo~="bar"]                  | 一个 E 元素，其 "foo" 属性值是一个以空白分隔的值，其中一个正好等于 "bar"         | 属性选择器                                                                     | 2          |
| E[foo^="bar"]                  | 一个 E 元素，它的 "foo" 属性值正好以字符串 "bar" 开始                            | 属性选择器                                                                     | 3          |
| E[foo$="bar"]                  | 一个 E 元素，其 "foo" 属性值正好以字符串 "bar" 结束                              | 属性选择器                                                                     | 3          |
| E[foo*="bar"]                  | 一个 E 元素，其 "foo" 属性值包含子串 "bar"                                       | 属性选择器                                                                     | 3          |
| E[foo                          | ="en"]                                                                           | 一个 E 元素，其 "foo" 属性有一个以 "en" 开头的连字符分隔的值列表（从左边开始） | 属性选择器 | 2   |
| E:root                         | 一个 E 元素，文档的根结构                                                        | 伪类                                                                           | 3          |
| E:nth-child(n)                 | 一个 E 元素，是其父元素的第 n 个子元素                                           | 结构性伪类                                                                     | 3          |
| E:nth-last-child(n)            | 一个 E 元素，是其父元素的第 n 个子元素，从最后一个开始计算                       | 结构性伪类                                                                     | 3          |
| E:nth-of-type(n)               | 一个 E 元素，是其类型的第 n 个兄弟元素                                           | 结构性伪类                                                                     | 3          |
| E:nth-last-of-type(n)          | 一个 E 元素，它的类型的第 n 个兄弟元素，从最后一个开始计算                       | 结构性伪类                                                                     | 3          |
| E:first-child                  | 一个 E 元素，是其父元素的第一个子元素                                            | 结构性伪类                                                                     | 2          |
| E:last-child                   | 一个 E 元素，是其父元素的最后一个子元素                                          | 结构性伪类                                                                     | 3          |
| E:first-of-type                | 一个 E 元素，其类型的第一个兄弟元素                                              | 结构化伪类                                                                     | 3          |
| E:last-of-type                 | 一个 E 元素，其类型的最后一个兄弟元素                                            | 结构性伪类                                                                     | 3          |
| E:only-child                   | 一个 E 元素，是其父元素的唯一子元素                                              | 结构性伪类                                                                     | 3          |
| E:only-of-type                 | 一个 E 元素，是其类型的唯一兄弟元素                                              | 结构性伪类                                                                     | 3          |
| E:empty                        | 一个 E 元素，没有子节点（包括文本节点）                                          | 结构性伪类                                                                     | 3          |
| E:link 和 E:visited            | 一个 E 元素是一个超链接的锚点，其目标尚未被访问（:link）或已经被访问（:visited） | 链接伪类                                                                       | 1          |
| E:active 和 E:hover 和 E:focus | 在某些用户操作期间的一个 E 元素                                                  | 用户操作伪类                                                                   | 1 和 2     |
| E:target                       | 一个 E 元素，是引用 URI 的目标                                                   | target 伪类                                                                    | 3          |
| E:lang(fr)                     | 一个语言为 "fr" 的 E 类型元素（文件语言指定如何确定语言）                        | :lang 伪类                                                                     | 2          |
| E:enabled 和 E:disabled        | 一个用户界面元素 E，它被启用或禁用                                               | UI 元素状态伪类                                                                | 3          |
| E:checked                      | 一个被选中的用户界面元素 E（例如一个单选按钮或复选框）                           | UI 元素说明伪类                                                                | 3          |
| E::first-line                  | 一个 E 元素的第一个格式化行                                                      | ::first-line 伪元素                                                            | 1          |
| E::first-letter                | 一个 E 元素的第一个格式化的字母                                                  | ::first-letter 伪元素                                                          | 1          |
| E::before                      | 在 E 元素之前生成的内容                                                          | ::before 伪元素                                                                | 2          |
| E::after                       | 在一个 E 元素之后生成的内容                                                      | ::after 伪元素                                                                 | 2          |
| E.warning                      | 一个 E 元素，它的类是 "warning"（文档语言指定类是如何确定的）                    | 类选择器                                                                       | 1          |
| E#myid                         | 一个 E 元素，ID 等于 "myid"                                                      | ID 选择器                                                                      | 1          |
| E:not(s)                       | 一个 E 元素，不符合简单选择器 s                                                  | 否定伪类                                                                       | 3          |
| E F                            | 一个 E 元素的 F 元素的后代元素                                                   | 后代元素组合符                                                                 | 1          |
| E > F                          | 一个 E 元素的 F 元素的子元素                                                     | 子元素组合符                                                                   | 2          |
| E + F                          | 一个 F 元素紧挨着一个 E 元素的后置元素                                           | 下一个下一个兄弟元素组合符                                                     | 2          |
| E ~ F                          | 一个 F 元素前面有一个 E 元素                                                     | 后续兄弟元素组合符                                                             | 3          |

## 3.2. 选择器语法

一个 **选择器** 是由组合符分隔的一个或多个简单选择器序列组成的链条。一个伪元素可以被附加到一个选择器中最后一个简单选择器序列上。

一个 **简单选择器序列** 是一个没有被组合符分开的简单选择器链。它总是以一个类型选择器或一个通用选择器开始。在这个序列中不允许有其他类型选择器或通用选择器。

一个简单的选择器是一个类型选择器、通用选择器、属性选择器、类选择器、ID 选择器或伪类。

组合符是：空白、"大于号"（U+003E，>）、"加号"（U+002B，+）和 "倾斜号"（U+007E，~）。在组合符和它周围的简单选择器之间可以出现空白。只有 "空格"（U+0020）、"制表"（U+0009）、"换行"（U+000A）、"回车"（U+000D）和 "换页"（U+000C）这些字符可以出现在空白处。其他类似空格的字符，如 "em-space"（U+2003）和 "ideographic space"（U+3000），从来不是空白的一部分。

一个选择器所代表的文档树的元素是 **选择器的对象**。一个由简单选择器的单一序列组成的选择器代表任何满足其要求的元素。将另一个简单选择器序列和一个组合符预置到一个序列中，会施加额外的匹配约束，所以选择器的主体总是最后一个简单选择器序列所代表的元素的一个子集。

一个空的选择器，不包含任何简单选择器序列和伪元素，是一个无效的选择器。

根据与 CSS 相同的转义规则，选择器中的字符可以用反斜杠转义。[CSS21].

某些选择器支持命名空间前缀。命名空间前缀的声明机制应该由使用选择器的语言来指定。如果该语言没有指定命名空间前缀的声明机制，那么就不会声明前缀。在 CSS 中，命名空间前缀是用@namespace 规则声明的。[css3namespace]

## 3.3. 选择器组

逗号分隔的选择器列表表示列表中每个单独的选择器所选择的所有元素的并集。(逗号是 U+002C。）例如，在 CSS 中，当几个选择器共享相同的声明时，它们可以被归入一个逗号分隔的列表。逗号之前和/或之后可以出现空白。

CSS 的例子：

在这个例子中，我们将三个具有相同声明的规则压缩为一个。因此：

```css
h1 {
  font-family: sans-serif;
}

h2 {
  font-family: sans-serif;
}

h3 {
  font-family: sans-serif;
}
```

相当于：

```css
h1,
h2,
h3 {
  font-family: sans-serif;
}
```

警告：在这个例子中，等价关系是真实的，因为所有的选择器都是有效的选择器。如果这些选择器中只有一个是无效的，那么整组选择器都将是无效的。这将使所有三个标题元素的规则失效，而在前一种情况下，只有三个单独的标题规则中的一个会被废止。

无效的 CSS 例子：

```css
h1 {
  font-family: sans-serif;
}

h2...foo {
  font-family: sans-serif;
}

h3 {
  font-family: sans-serif;
}
```

并不等同于:

```css
h1,
h2...foo,
h3 {
  font-family: sans-serif;
}
```

因为上面的选择器（h1, h2...foo, h3）是完全无效的，整个样式规则被放弃。(当选择器没有分组时，只有 h2...foo 的规则被放弃。)

## 3.4. 简单选择器

### 3.4.1. 类型选择器

**类型选择器** 是使用 CSS 限定名称[CSS3NAMESPACE]的语法编写的文档语言元素类型的名称。一个类型选择器代表文档树中元素类型的一个实例。

下面的选择器表示文档树中的 h1 元素：

```css
h1 {
}
```

#### 3.4.1.1. 类型选择器和命名空间

类型选择器允许一个可选的命名空间组件：先前已经声明的命名空间前缀可以被预加到元素名称中，由命名空间分隔符 "垂直条"（U+007C，|）分隔。(参见，例如，[XML-NAMES]，关于 XML 中命名空间的使用）。

命名空间组件可以留空（在命名空间分隔符前没有前缀），以表明选择器只代表没有命名空间的元素。

命名空间前缀可以使用星号，表示选择器代表任何命名空间的元素（包括没有命名空间的元素）。

没有命名空间组件（没有命名空间分隔符）的元素类型选择器代表元素，不考虑元素的命名空间（相当于 "\*|"），除非已经为命名空间选择器声明了一个默认的命名空间（例如，在 CSS 中，在样式表中）。如果已经声明了一个默认的命名空间，这样的选择器将只代表默认命名空间的元素。

含有命名空间前缀的类型选择器是一个无效的选择器，这个前缀之前没有为命名空间选择器声明。

在一个具有名字空间意识的客户端中，元素类型选择器的名字部分（名字空间分隔符之后的部分，如果它存在的话）将只与元素的限定名称的本地部分相匹配。

总而言之：

- `ns|E`
  命名空间 ns 中名称为 E 的元素

- `\*|E`
  在任何命名空间中具有 E 名称的元素，包括没有命名空间的元素

- `|E`
  名称为 E 的元素，没有命名空间

- `E`
  如果没有为选择器声明默认命名空间，这相当于\*|E。否则就等同于 ns|E，其中 ns 是默认命名空间。

```css
@namespace foo url(http://www.example.com);
foo|h1 {
  color: blue;
} /* 第一条 rule */

foo|* {
  color: yellow;
} /* 第2条 rule */

|h1 {
  color: red;
} /* ...*/

*|h1 {
  color: green;
}

h1 {
  color: green;
}
```

第一条规则（不算@namespace at-rule）将只匹配 "http://www.example.com "命名空间中的 h1 元素。

第二条规则将匹配 "http://www.example.com "命名空间中的所有元素。

第三条规则将只匹配没有命名空间的 h1 元素。

第四条规则将匹配任何命名空间的 h1 元素（包括没有任何命名空间的元素）。

最后一条规则等同于第四条规则，因为没有定义默认命名空间。

### 3.4.2. 通用选择器

**通用选择器** 用星号（`*` U+002A）作为名称，代表任何元素类型的限定名。如果没有为选择器指定默认的命名空间，它代表文档树中任何命名空间的任何单一元素（包括没有命名空间的元素）。如果指定了一个默认的命名空间，请看下面的通用选择器和命名空间。

如果一个由`*`代表的通用选择器（即没有命名空间前缀）不是简单选择器选择器序列的唯一组成部分，或者紧接着一个伪元素，那么`*`可以被省略，通用选择器的存在被暗示。

例如：

```css
*[hreflang|=en] 等同于 [hreflang|=en]
*.warning 等同于 .warning
*#myid 等同于 #myid
```

注意：建议不要省略`*`，因为它减少了诸如 `div :first-child` 和 `div:first-child` 之间的潜在混淆。这里，`div *:first-child` 更易读。

#### 3.4.2.1. 通用选择器和命名空间

通用选择器允许一个可选的命名空间组件。它的使用方法如下。

- `ns|*`
  命名空间 ns 中的所有元素

- `*|*`
  所有元素

- `|*`
  所有没有命名空间的元素

- `*`
  如果没有指定默认命名空间，这等同于`*|*`。否则，它等同于`ns|*`，其中 ns 是默认的命名空间。

包含先前未声明的命名空间前缀的通用选择器是一个无效的选择器。

### 3.4.3. 属性选择器

**属性选择器** 允许代表一个元素的属性。当一个选择器被用作表达式来匹配一个元素时，如果一个元素有一个与属性选择器所代表的属性相匹配的属性，那么属性选择器必须被认为是匹配该元素。

#### 3.4.3.1. 属性存在和值选择器

CSS2 引入了以下 4 种属性选择器：

- `[att］`
  代表一个带有 att 属性的元素，无论该属性的值是多少。

- `[att=val]`
  代表一个带有 att 属性的元素，其值正好是 val。

- [att~=val]
  代表一个带有 att 属性的元素，其值是一个用空格分隔的单词列表，其中一个正好是 val。如果 val 包含空格，它将永远不会代表任何东西（因为这些词是由空格分隔的）。同样，如果 val 是空字符串，它也不会代表任何东西。

- [att|=val]
  代表一个带有 att 属性的元素，其值要么正好是 val，要么以 val 开头，后面紧跟"-"（U+002D）。这主要是为了允许 BCP47（[BCP47]）或其后续版本中描述的语言子代码匹配（例如，HTML 中 a 元素的 hreflang 属性）。对于 lang（或 xml:lang）语言子代码的匹配，请参见:lang 伪类。

属性值必须是 CSS 标识符或字符串。[CSS21]选择器中的属性名称和值的大小写敏感性取决于文档语言。

下面的属性选择器表示一个携带 title 属性的 h1 元素，无论其值如何：

```css
h1[title]
```

在下面的例子中，该选择器代表一个 span 元素，其 class 属性的值正好是 "example"：

```css
span[class='example']
```

多属性选择器可以用来表示一个元素的几个属性，或同一属性的几个条件。这里，选择器表示一个 span 元素，其 hello 属性的值正好是 "Cleveland"，其 goodbye 属性的值正好是 "Columbus"：

```css
span[hello='Cleveland'][goodbye='Columbus']
```

下面的 CSS 规则说明了"="和"~="之间的区别。第一个选择器将匹配，例如，一个在 rel 属性上有 "copyright copyleft copyeditor" 值的 a 元素。第二个选择器将只匹配一个带有精确值 "http://www.w3.org/"的href属性的a元素：

```css
a[rel~='copyright']
a[href="http://www.w3.org/"]
```

下面的选择器表示一个 a 元素，其 hreflang 属性正好是 "fr"：

```css
a[hreflang='fr']
```

下面的选择器代表一个 a 元素，其 hreflang 属性的值以 "en" 开头，包括 "en"、"en-US "和 "en-scouse"。

```css
a[hreflang|='en']
```

下面的选择器代表 DIALOGUE 元素，只要它有两个不同的属性字符值之一：

```css
DIALOGUE[character='romeo']
DIALOGUE[character='juliet']
```

#### 3.4.3.2. 子串匹配属性选择器

三个额外的属性选择器可以用于匹配属性值中的子字符串：

- `[att^=val］`
  代表一个具有 att 属性的元素，其值以前缀 val 开始。如果 val 是空字符串，那么该选择器不代表任何东西。

- `[att$=val]`
  代表一个带有 att 属性的元素，其值以后缀 val 结束。如果 val 是空字符串，那么该选择器不代表任何东西。

- `[att*=val`
  代表一个具有 att 属性的元素，其值至少包含一个子串 val 的实例。如果 val 是空字符串，那么该选择器不代表任何东西。

属性值必须是 CSS 标识符或字符串。[CSS21] 选择器中的属性名称的大小写敏感度取决于文档语言。

下面的选择器表示一个 HTML 对象，引用一个图像：

```css
object[type^="image/"]
```

下面的选择器表示一个 HTML 锚点 a，其 href 属性的值以".html "结尾：

```css
a[href$=".html"]
```

下面的选择器表示一个 HTML 段落，其标题属性的值包含子串 "hello"：

```css
p[title*="hello"]
```

#### 3.4.3.3. 属性选择器和命名空间

属性选择器中的属性名是以 CSS 限定名的形式给出的：先前已声明的命名空间前缀可以预加到属性名中，并以命名空间分隔符 "竖条"（|）分隔。为了与 XML 中的命名空间建议保持一致，默认的命名空间并不适用于属性，因此没有命名空间成分的属性选择器只适用于没有命名空间的属性（相当于"|attr"）。名称空间前缀可以使用星号，表示选择器要匹配所有属性名称，而不考虑属性的名称空间。

一个属性选择器，其属性名包含一个先前未被声明的名称空间前缀，是一个无效的选择器。

```css
@namespace foo 'http://www.example.com';
[foo|att='val'] {
  color: blue;
}
[*|att] {
  color: yellow;
}
[|att] {
  color: green;
}
[att] {
  color: green;
}
```

第一条规则将只匹配在 "http://www.example.com "命名空间中具有 att 属性的元素，其值为 "val"。

第二条规则将只匹配具有 att 属性的元素，而不考虑该属性的命名空间（包括没有命名空间）。

最后两条规则是等价的，将只匹配具有 att 属性的元素，而该属性不在一个命名空间中。

#### 3.4.3.4. DTD 中的默认属性值

属性选择器代表文档树中的属性值。文档树是如何构建的，这不在选择器的范围之内。在一些文档格式中，默认的属性值可以在 DTD 或其他地方定义，但只有当它们出现在文档树中时才能被属性选择器选择。选择器应该被设计成无论默认值是否包括在文档树中，它们都能发挥作用。

例如，XML UA 可以（但不需要）读取 DTD 的 "外部子集"，但需要在文档的 "内部子集 "中寻找默认属性值。(例如，见[XML10]对这些子集的定义。)根据 UA，在 DTD 的外部子集中定义的缺省属性值可能出现在文档树中，也可能不出现。

识别 XML 命名空间的 UA 可以（但不需要）使用它对该命名空间的知识来处理缺省属性值，就像它们存在于文档中一样。(例如，XHTML UA 不需要使用它对 XHTML DTD 的内置知识。关于 XML 1.0 中命名空间的详情，请参见[XML-NAMES]）。

注意：通常情况下，实现者会选择忽略外部子集。这与 XML 规范所定义的非验证处理器的行为相对应。

考虑一个元素 EXAMPLE，它的属性 radix 的默认值是 "十进制"。DTD 片段可能是：

```xml
<!ATTLIST EXAMPLE radix (decimal,octal) "decimal">
```

如果样式表包含规则：

```css
EXAMPLE[radix='decimal'] {
  /*...默认属性设置 ...*/
}
EXAMPLE[radix='octal'] {
  /*...其他设置...*/
}
```

第一条规则可能无法匹配 radix 属性是默认设置的元素，即没有明确设置。为了抓住所有的情况，必须放弃默认值的属性选择器。

```css
EXAMPLE {
  /*...默认属性设置 ...*/
}
EXAMPLE[radix='octal'] {
  /*...其他设置...*/
}
```

在这里，因为选择器 EXAMPLE[radix=octal]比单独的类型选择器更具体，对于 radix 属性值为 "八进制 "的元素，第二条规则中的样式声明将覆盖第一条规则中的声明。必须注意的是，所有只适用于默认情况的属性声明在非默认情况的样式规则中被覆盖。

### 3.4.4. 类选择器

在使用 HTML 时，作者可以使用 "." 符号（U+002E，.）来替代~=符号来表示类属性。因此，对于 HTML 来说，div.value 和 div[class~=value]具有相同的含义。属性值必须紧跟在句号（.）之后。

如果 UA 具有特定于命名空间的知识，可以确定哪个属性是各自命名空间的 "class" 属性，那么 UA 可以在 XML 文档中应用使用句号（.）符号的选择器。命名空间特定知识的一个例子是特定命名空间规范中的散文（例如，SVG 1.1 [SVG11]描述了 SVG 类属性以及 UA 应该如何解释它，同样，MathML [MATHML3]描述了 MathML 类属性）。

我们可以给所有带有`class~="pastoral"`的元素分配样式信息，如下所示:

```css
*.pastoral {
  color: green;
} /*所有带有class~=pastoral的元素 */
```

或只是：

```css
.pastoral {
  color: green;
} /*所有具有class~=pastoral的元素 */
```

以下是只给`class~="pastoral"` 的 H1 元素分配样式：

```css
h1.pastoral {
  color: green;
} /* 具有class~=pastoral的H1元素 */
```

鉴于这些规则，下面的第一个 H1 实例不会有绿色文本，而第二个则会：

```html
<h1>不是绿色的</h1>
<h1 class="pastoral">绿色</h1>
```

下面的规则匹配任何 P 元素，该元素的 class 属性被分配了一个包括 pastoral 和 marine 的空白分隔值的列表：

```css
p.pastoral.marine {
  color: green;
}
```

这条规则在`class="pastoral blue aqua marine"`时匹配，但在`class="pastoral blue"`时不匹配。

注意：由于 CSS 给了 "class" 属性相当大的权力，作者可以设想在几乎没有相关表现形式的元素（如 HTML 中的 DIV 和 SPAN）基础上设计自己的 "文档语言"，并通过 "class" 属性分配样式信息。作者应该避免这种做法，因为文档语言的结构元素往往有公认的和接受的含义，而作者定义的类可能没有。

注意：如果一个元素有多个类属性，在搜索类之前，必须将它们的值连接起来，并在值之间加上空格。然而，到目前为止，工作组还不知道有什么方式可以达到这种情况，所以这种行为在本规范中是明确的非规范性的。

### 3.4.5. ID 选择器

文档语言可能包含被声明为 ID 类型的属性。ID 类型属性的特殊之处在于，在一个符合要求的文档中，没有两个这样的属性可以有相同的值，无论承载它们的元素是什么类型；无论文档语言是什么，一个 ID 类型的属性可以用来唯一地识别其元素。在 HTML 中，所有的 ID 属性都被命名为 "id"；XML 应用程序可以以不同的方式命名 ID 属性，但同样的限制也适用。

一个文档语言的 ID 类型的属性允许作者为文档树中的一个元素实例指定一个标识符。一个 ID 选择器包含一个 "#"（U+0023，#），紧接着是 ID 值，它必须是一个 CSS 标识符。一个 ID 选择器代表一个元素实例，它的标识符与 ID 选择器中的标识符相匹配。

选择器没有规定 UA 如何知道一个元素的 ID 类型的属性。UA 可以，例如，阅读文档的 DTD，有硬编码的信息或询问用户。

下面的 ID 选择器代表一个 h1 元素，其 ID 类型属性的值为 "chapter1"：

```css
h1#chapter1
```

下面的 ID 选择器代表任何 ID 属性值为 "chapter1 "的元素：

```css
#chapter1
```

下面的选择器代表任何元素，其 ID 属性的值为 "z98y"：

```css
*#z98y
```

注意：在 XML 1.0 [XML10]中，关于哪个属性包含一个元素的 ID 的信息是包含在 DTD 或模式中。当解析 XML 时，UA 并不总是阅读 DTD，因此可能不知道一个元素的 ID 是什么（尽管 UA 可能有特定命名空间的知识，允许它确定哪个属性是该命名空间的 ID 属性）。如果一个样式表作者知道或怀疑一个 UA 可能不知道一个元素的 ID 是什么，他应该使用正常的属性选择器来代替。[name=p371]而不是#p371。

如果一个元素有多个 ID 属性，为了 ID 选择器的目的，所有这些属性必须被视为该元素的 ID。这种情况可以使用 xml:id、DOM、XML DTD 和命名空间特定知识的混合物来达成。

### 3.4.6. 伪类

伪类概念的引入是为了允许根据文档树之外的信息或不能用其他简单选择器表达的信息进行选择。

伪类总是由一个 "冒号"（:）组成，后面是伪类的名称，也可以选择括号内的值。

伪类在一个选择器中包含的所有简单选择器序列中都是允许的。伪类允许出现在简单选择器序列的任何地方，在领先的类型选择器或通用选择器（可能省略）之后。伪类的名字是不区分大小写的。一些伪类是相互排斥的，而其他伪类可以同时应用于同一个元素。伪类可以是动态的，也就是说，当用户与文档交互时，一个元素可以获得或失去一个伪类。

#### 3.4.6.1. 动态伪类

动态伪类根据元素的名称、属性或内容以外的特征对其进行分类，原则上这些特征不能从文档树中推断出来。

动态伪类不会出现在文档源或文档树中。

1. **:link 和 :visted**

用户代理通常以不同的方式显示未访问的链接和先前访问的链接。选择器提供了 :link 和 :visited 的伪类来区分它们。

- :link 伪类适用于尚未被访问的链接。
- :visited 伪类适用于一旦被用户访问过的链接。

经过一段时间后，用户代理可以选择将已访问的链接返回到（未访问的）':link'状态。

这两种状态是相互排斥的。

例子。

下面的选择器表示携带外部类并且已经访问过的链接：

```css
a.external: visited;
```

注意：样式表作者有可能滥用:link 和:visited 伪类来确定用户在未经用户同意的情况下访问过哪些网站。

因此，UA 可以将所有链接视为未访问的链接，或实施其他措施来保护用户的隐私，同时以不同的方式呈现已访问和未访问的链接。

2. **:hover，:active 和 :focus**

交互式用户代理有时会根据用户的操作改变渲染。选择器提供了三个伪类来选择用户正在操作的元素。

- :hover 伪类在用户用指向性设备指定一个元素时适用，但不一定会激活它。例如，一个可视化的用户代理可以在光标（鼠标指针）悬停在一个由元素产生的盒子上时应用这个伪类。不支持交互式媒体的用户代理不需要支持这个伪类。一些支持交互式媒体的符合要求的用户代理可能无法支持这个伪类（例如，一个不检测悬停的笔设备）。
- 当一个元素被用户激活时，:active 伪类适用。例如，在用户按下鼠标按钮和释放它的时间之间。在有一个以上的鼠标按钮的系统中，:active 只适用于主要的或主要的激活按钮（通常是 "左 "鼠标按钮），以及其任何别名。
- 当一个元素拥有焦点（接受键盘或鼠标事件，或其他形式的输入）时，:focus 伪类适用。

在哪些元素可以成为:active 或获得:focus 时，可能会有文档语言或实施的特定限制。

这些伪类并不相互排斥。一个元素可以同时匹配几个伪类。

选择器并没有定义一个元素的父级是否也处于':active'或':hover'状态。

注意：如果':hover'状态适用于一个元素，因为它的子元素被一个指向性设备所指定，那么':hover'就有可能适用于一个不在指向性设备下面的元素：

```css
a:link /*未访问的链接 */
a:visited /* visited links */
a:hover /* 用户悬停 */
a:active /* 活动链接 */
```

一个结合动态伪类的例子：

```css
a:focus
a:focus:hover
```

最后一个选择器匹配处于伪类:focus 和伪类:hover 中的元素。

注意：一个元素可以同时是":visited "和":active"（或":link "和":active"）。

#### 3.4.6.2. :target

有些 URI 指的是资源中的一个位置。这种 URI 以一个 "数字符号"(#)结尾，后面是一个锚定标识符（称为片段标识符）。

带有片段标识符的 URI 链接到文档中的某个元素，称为 targte 元素。例如，这里是一个 URI，指向 HTML 文档中名为 section_2 的锚点：http://example.com/html/top.html#section_2。

一个目标元素可以用:target 伪类来表示。如果文档的 URI 没有片段标识符，那么该文档就没有 target 元素。

```css
p.note: target;
```

这个选择器表示一个 note 类的 p 元素，是引用 URI 的 target 元素。

这里，:target 伪类被用来使目标元素变成红色，并在它前面放置一个图像，如果有的话：

```css
*:target {
  color: red;
}

*:target::before {
  content: url(target.png);
}
```

#### 3.4.6.3. :lang

如果文档语言规定了如何确定一个元素的人类语言，那么就有可能根据元素的语言来编写表示该元素的选择器。例如，在 HTML[HTML401]中，语言是由 lang 属性和可能来自元元素或协议（如 HTTP 头文件）的信息共同决定的。XML 使用一个叫做 xml:lang 的属性，也可能有其他针对文档语言的方法来确定语言。

:lang(C)这个伪类代表了一个使用 C 语言的元素。一个元素是否被:lang()选择器所代表，完全基于该元素的语言值（必要时规范化为 BCP 47 语法）等于标识符 C，或者以标识符 C 紧跟"-"（U+002D）开始。在 ASCII 范围内，C 与元素的语言值的匹配是不分大小写的。标识符 C 不一定是一个有效的语言名称。

C 必须是一个有效的 CSS 标识符[CSS21]，而且不能是空的。(否则，选择器是无效的）。

注意：建议文档和协议使用 BCP47[BCP47]或其后续版本的代码来指示语言，如果是基于 XML 的文档，则使用 "xml:lang "属性[XML10]。见 "常见问题。双字母或三字母语言代码"。

下面两个选择器代表一个比利时法语或德语的 HTML 文档。接下来的两个选择器代表比利时法语或德语的任意元素中的 q 引号：

```css
html:lang(fr-be)
html:lang(de)
:lang(fr-be) > q
:lang(de) > q
```

`:lang(C)` 和 `'|='` 操作符之间的区别是，`'|='` 操作符只对元素上的特定属性进行比较，而 `:lang(C)` 伪类使用 UA 对文档语义的了解来进行比较。

在这个 HTML 例子中，只有 BODY 匹配[lang|=fr]（因为它有一个 LANG 属性），但 BODY 和 P 都匹配 :lang(fr) （因为两者都是法语）。P 不匹配[lang|=fr]，因为它没有一个 LANG 属性：

```html
<body lang="fr">
  <p>Je suis français.</p>
</body>
```

#### 3.4.6.4. UI 元素状态伪类

1. **:enabled 和 :disabled**

:enabled 伪类代表处于启用状态的用户界面元素；这样的元素有一个相应的禁用状态。

反之，:disabled 伪类代表处于禁用状态的用户界面元素；这样的元素有一个相应的启用状态。

构成启用状态、禁用状态和用户界面元素的内容是依赖于语言的。在一个典型的文档中，大多数元素既不是:enabled 也不是:disabled。

注意：可能会影响用户与一个给定的用户界面元素互动的 CSS 属性并不影响它是否符合:enabled 或:disabled；例如，显示和可见性属性对一个元素的启用/禁用状态没有影响。

2. **:checked**

单选和复选框元素可以由用户来切换。一些菜单项在用户选择它们时被 "选中"。当这些元素被切换为 "开启" 时，:checked 伪类就会被应用。虽然:checked 伪类在本质上是动态的，并且可以通过用户的操作而改变，因为它也可以基于文档中语义属性的存在，它适用于所有的媒体。例如，:checked 伪类最初适用于 HTML4 第 17.2.1 节中描述的具有 HTML4 选择和检查属性的元素，当然，用户可以切换 "关闭 "这些元素，这样的话，:checked 伪类就不再适用了。

#### 3.4.6.5. 结构性伪类

选择器引入了结构性伪类的概念，允许根据位于文档树中但不能由其他简单选择器或组合符表示的额外信息进行选择。

在计算一个元素在其兄弟元素列表中的位置时，独立的文本和其他非元素节点不被计算在内；索引的编号从 1 开始。

1. **:root 伪类**

:root 伪类代表一个元素，它是文档的根。在 HTML 4 中，这总是 HTML 元素。

2. **:nth-child() 伪类**

:nth-child(an+b)伪类符号表示一个元素在文档树中有 an+b-1 个兄弟元素，对于任何正整数或零值的 n，它不需要有一个父元素。对于 a 和 b 的值大于零，这有效地将元素的子代分为 a 元素组（最后一组取余数），并选择每组中的第 b 个元素。例如，这允许选择器处理表格中的每一行，并可用于在四个循环中交替使用段落文本的颜色。a 和 b 的值必须是整数（正、负或零）。一个元素的第一个子元素的索引是 1。

除此之外，:nth-child()可以接受'odd'和'even'作为参数来代替。"odd" 的含义与 2n+1 相同，而 "even" 的含义与 2n 相同。

:nth-child()的参数必须符合下面的语法，其中 INTEGER 匹配标记[0-9]+，其余的标记化由 10.2 节中的词汇扫描器给出。

```
nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;
```

```css
tr:nth-child(2n+1) /*代表HTML表格的每一个奇数行 */
tr:nth-child(odd) /*相同 */
tr:nth-child(2n+0) /*代表HTML表格中的每一条偶数行 */
tr:nth-child(even) /*相同 */

/* 在CSS中替代段落的颜色 */
p:nth-child(4n+1) {
  color: navy;
}

p:nth-child(4n + 2) {
  color: green;
}

p:nth-child(4n + 3) {
  color: maroon;
}

p:nth-child(4n + 4) {
  color: purple;
}
```

当值 b 前面有一个负号时，表达式中的 "+"字符必须被删除（它实际上被表示 b 的负值的"-"字符取代）。

```css
:nth-child(10n-1) /*代表第9、19、29等元素 */
:nth-child(10n+9) /*相同 */
:nth-child(10n+1) /*语法上无效，会被忽略 */
```

当 a=0 时，an 部分不需要包含（除非 b 部分已经省略）。当 an 不包括在内且 b 为非负数时，b 前面的+号（当允许时）也可以省略。在这种情况下，语法简化为:nth-child(b)。

```css

foo:nth-child(0n+5) /*表示一个元素foo是其父元素的第5个子元素*/
foo:nth-child(5) /*相同 */
```

当 a=1，或 a=-1 时，规则中的 1 可以省略。因此，下面的选择器是等同的:

```css
bar:nth-child(1n+0) /*代表所有bar元素，特指度（0,1,1） */
bar:nth-child(n+0) /*相同 */
bar:nth-child(n) /*相同 */
bar /*相同，但特指度较低（0,0,1） */
```

如果 b=0，那么每一个第 a 个元素都会被选中。在这种情况下，+b（或-b）部分可以省略，除非 a 部分已经被省略了。

```css
tr:nth-child(2n+0) /*代表一个HTML表格的每一个偶数行 */
tr:nth-child(2n) /*相同 */
```

在"("之后，") "之前，以及在分隔 an 和 b 部分的 "+"或"-"的两侧，如果都存在的话，允许留白：

有空白的有效例子：

```css
:nth-child( 3n + 1 )
:nth-child( +3n - 2 )
:nth-child( -n+ 6)
:nth-child( +6 )
```

有空白的无效例子：

```css
:nth-child(3 n)
:nth-child(+ 2n)
:nth-child(+2)
```

如果 a 和 b 都等于 0，则该伪类在文档树中不代表任何元素。

a 的值可以是负的，但是只有 an+b 的正值，对于 n>=0，才可以代表文档树中的一个元素。

```css
html|tr: nth-child(-n + 6); /*代表XHTML表格的第6行 */
```

3. **:nth-last-child()伪类**

:nth-last-child(an+b)伪类符号表示一个元素在文档树中有一个+b-1 个兄弟元素，对于任何正整数或零值的 n，它不需要有一个父级。它的参数语法见:nth-child() 伪类。它也接受 "even" 和 "odd" 值作为参数。

例子：

```css
tr:nth-last-child(-n+2) /*代表HTML表格的最后两行 */

foo:nth-last-child(odd) /*代表其父元素中所有奇数的foo元素。
                              从最后一个开始计算 */
```

4. **:nth-of-type() 伪类**

:nth-of-type(an+b)伪类符号表示一个元素在文档树中有一个+b-1 个具有相同扩展元素名称的兄弟元素，对于任何零或正整数值的 n，它不需要有一个父级。关于其参数的语法，请参见:nth-child() 伪类。它也接受 "even" 和 "odd" 值。

这允许作者交替使用浮动图像的位置：

```css
img:nth-of-type(2n + 1) {
  float: right;
}
img:nth-of-type(2n) {
  float: left;
}
```

5. **:nth-last-of-type() 伪类**

:nth-last-of-type(an+b)伪类符号表示一个元素在文档树中有一个+b-1 个具有相同扩展元素名称的兄弟元素，对于任何零或正整数值的 n，它不需要有一个父级。它的参数语法见:nth-child() 伪类。它也接受 "偶数 "和 "奇数 "值。

要表示一个 XHTML 主体的所有 h2 子节点，除了第一个和最后一个，可以使用下面的选择器：

```css
body > h2:nth-of-type(n+2):nth-last-of-type(n+2)
```

在这种情况下，我们也可以使用:not()，尽管选择器最终会变得一样长:

```css
body > h2:not(:first-of-type):not(:last-of-type)
```

6. **:first-child 伪类**

与 :nth-child(1)相同。:first-child 伪类表示一个元素在一个兄弟元素的列表中是第一个。

下面的选择器表示一个 p 元素是一个 div 元素的第一个子元素：

```
div > p:first-child
```

这个选择器可以代表下面片段的 div 里面的 p:

```html
<p>注释前的最后一个P。</p>
<div class="note">
  <p>注释里面的第一个P。</p>
</div>
```

但不能代表下面片段中的第二个 P：

```html
<p>音符前的最后一个P。</p>
<div class="note">
  <h2>注释</h2>
  <p>注释里面的第一个P。</p>
</div>
```

以下两个选择器通常是等同的：

```css
*> a:first-child /* a是任何元素的第一个子元素 */
a:first-child /*相同（假设a不是根元素） */
```

7. **:last-child 伪类**

与 :nth-last-child(1)相同。:last-child 伪类表示一个元素在兄弟元素的列表中是最后一个。

下面的选择器表示一个列表项 li 是一个有序列表 ol 的最后一个子元素：

```css
ol > li:last-child
```

8. **:first-of-type 伪类**

与 :nth-of-type(1)相同。:first-of-type 伪类表示一个元素是其类型的第一个兄弟元素。

下面的选择器表示一个定义列表 dl 内的定义标题 dt，这个 dt 是其父元素的子列表中的第一个类型。

```css
dl dt:first-of-type
```

在下面的例子中，它对前两个 dt 元素的描述是有效的，但对第三个 dt 元素的描述是无效的：

```html
<dl>
  <dt>gigogne</dt>
  <dd>
    <dl>
      <dt>fusée</dt>
      <dd>多级火箭</dd>
      <dt>表</dt>
      <dd>嵌套表</dd>
      。
    </dl>
  </dd>
</dl>
```

9. **:last-of-type 伪类**

与 :nth-last-of-type(1)相同。:last-of-type 伪类表示一个元素是其类型的最后一个兄弟元素。

下面的选择器代表一个表格行 tr 的最后一个数据单元 td:

```css
tr > td:last-of-type
```

10. **:only-child 伪类**

:only-child 伪类代表一个没有兄弟元素的元素。与 :first-child:last-child 或 :nth-child(1):nth-last-child(1)相同，但特指度较低。

11. **:only-of-type 伪类**

:only-of-type 伪类代表一个没有相同扩展元素名的同级元素。与 :first-of-type:last-of-type 或 :nth-of-type(1):nth-last-of-type(1)相同，但特指度较低。

12. **:empty 伪类**

:empty 伪类代表一个完全没有子元素的元素。就文档树而言，只有元素节点和内容节点（如 DOM [DOM-LEVEL-3-CORE] 文本节点、CDATA 节点和实体引用）的数据具有非零长度，必须被视为影响空性；注释、处理指令和其他节点不得影响元素是否被视为空。

p:empty 是下面这个片段的有效表示：

```css
<p></p>
```

foo:empty 不是以下片段的有效表示：

```html
<foo>bar</foo>
<foo><bar>bla</bar></foo>
<foo>
  这不是
  <bar>:empty</bar>
</foo>
```

### 3.4.7. 否定伪类

否定伪类，`:not(X)`，是一个函数记法，以一个简单的选择器（不包括否定伪类本身）作为参数。它表示一个不被其参数所代表的元素。

否定不能被嵌套；`:not(:not(...))`是无效的。还要注意的是，由于伪元素不是简单的选择器，它们不是 `:not()` 的有效参数。

下面的选择器可以匹配一个 HTML 文档中所有没有被禁用的按钮元素：

```css
button: not([DISABLED]);
```

下面的选择器表示除了 FOO 元素以外的所有元素：

```css
*: not(FOO);
```

下面这组选择器代表除链接以外的所有 HTML 元素：

```css
html|*:not(:link):not(:visited)
```

默认的命名空间声明并不影响否定伪类的参数，除非该参数是一个通用选择器或一个类型选择器。

假设默认命名空间被绑定为 "http://example.com/"，下面的选择器代表所有不在该命名空间中的元素。

```css
*|*: not(*);
```

下面的选择器匹配任何没有被悬停的元素，无论其命名空间如何。特别是，它不限于只匹配默认命名空间中没有被悬停的元素，不在默认命名空间中的元素在被悬停时也不匹配该规则。

```css
*|*: not(: hover);
```

注意： :not() 伪类允许编写无用的选择器。例如`:not(*|*)`，表示没有任何元素，或者`foo:not(bar)`，等同于`foo`，但有更高的特指度。

## 3.5. 伪元素

伪元素创造了关于文档树的抽象，超出了文档语言所规定的内容。例如，文档语言不提供访问一个元素内容的第一个字母或第一行的机制。伪元素允许作者参考这些本来无法访问的信息。伪元素还可以为作者提供一种方法来引用源文件中不存在的内容（例如，::before 和::after 的伪元素可以访问生成的内容）。

伪元素是由两个冒号（::）组成，后面是伪元素的名称。

这个::的符号是由当前的文件引入的，目的是在伪类和伪元素之间建立一个区分。为了与现有的样式表兼容，用户代理也必须接受以前在 CSS 第 1 和第 2 级中引入的伪元素的单引号符号（即:第一行、:第一字母、:前和:后）。对于本规范中引入的新的伪元素，这种兼容性是不允许的。

每个选择器只能出现一个伪元素，如果出现，它必须出现在代表选择器主体的简单选择器序列之后。注意：本规范的未来版本可能允许每个选择器出现多个伪元素。

### 3.5.1. ::first-line 伪元素

::first-line 伪元素描述了一个元素的第一行格式化的内容。

```css
p::first-line {
  text-transform: uppercase;
}
```

上述规则意味着 "将每个 p 元素的第一行的字母改为大写"。

选择器`p::first-line`并不匹配任何真正的文档元素。它确实匹配一个伪元素，符合要求的用户代理会在每个 p 元素的开头插入这个伪元素。

请注意，第一行的长度取决于许多因素，包括页面的宽度、字体大小等等。因此，一个普通的 HTML 段落，如：

```html
<p>
  This is a somewhat long HTML paragraph that will be broken into several lines.
  The first line will be identified by a fictional tag sequence. The other lines
  will be treated as ordinary lines in the paragraph.
</p>
```

它的行数恰好被打断，如下所示：

```
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag
sequence. The other lines will be treated as
ordinary lines in the paragraph.
```

这个段落可能被用户代理 "改写"，以包括::第一行的虚构标签序列。这个虚构的标签序列有助于显示属性是如何被继承的：

```html
<p>
  <P::first-line>This is a somewhat long HTML paragraph that</P::first-line>
  will be broken into several lines. The first line will be identified by a
  fictional tag sequence. The other lines will be treated as ordinary lines in
  the paragraph.
</p>
```

如果一个伪元素分割了一个真实的元素，所需要的效果通常可以通过一个虚构的标签序列来描述，这个标签序列关闭然后重新打开该元素。因此，如果我们用 span 元素来标记前面的段落：

```html
<p>
  <span class="test">
    This is a somewhat long HTML paragraph that will be broken into several
    lines.
  </span>
  The first line will be identified by a fictional tag sequence. The other lines
  will be treated as ordinary lines in the paragraph.
</p>
```

当为::first-line 插入虚构的标签序列时，用户代理可以模拟 span 的开始和结束标签：

```html
<p>
  <P::first-line>
    <span class="test">This is a somewhat long HTML paragraph that will</span>
  </P::first-line>
  <span class="test">be broken into several lines.</span>
  The first line will be identified by a fictional tag sequence. The other lines
  will be treated as ordinary lines in the paragraph.
</p>
```

#### 3.5.1.1. 第一个格式化行定义

在 CSS 中，::first-line 伪元素只有在连接到一个类似于块状的容器（如块状框、inline-block、table-caption 或 table-cell）时才能产生作用。在这种情况下，它指的是该容器的 **第一个格式化行**。

一个元素的第一个格式化行可能会出现在同一个流程中的块级下级中（即，一个没有因为浮动或定位而脱离流程的块级下级）。例如，`<DIV><P>This line...</P></DIV>` 中的 DIV 的第一行是 P 的第一行（假设 P 和 DIV 都是块级的）。

表格单元或 inline-block 的第一行不能是一个祖先元素的第一行格式。因此，在 `<DIV><P STYLE="display: inline-block">Hello<BR>Goodbye</P> etcetera</DIV>` 中，DIV 的第一个格式化行不是 "Hello "这一行。

注意：注意这个片段中 p 的第一行。`<p><br>First...`不包含任何字母（假设 HTML 4 中 br 的默认样式）。"First "这个词并不在第一行格式化的地方。

UA 应该像::第一行伪元素的虚构开始标签一样，正好嵌套在最内层的包围块级元素里面。(由于 CSS1 和 CSS2 对这种情况没有规定，作者不应该依赖这种行为）。例如，虚构的标签序列为：

```html
<div>
  <p>第一段</p>
  <p>第二段</p>
</div>
```

是：

```html
<DIV>
  <P><DIV::first-line><P::first-line>第一段</P::first-line><DIV::first-line></P>
  <P><P::first-line>第二段</P::first-line></P>。
</DIV>
```

::first-line 伪元素与内联级元素类似，但有某些限制。下列 CSS 属性适用于::第一行伪元素：字体属性、颜色属性、背景属性、"字间距"、"字母间距"、"文本装饰"、"文本变换"、"行高"。UA 也可以应用其他属性。

在 CSS 继承过程中，出现在第一行的子元素部分只从::第一行伪元素继承适用于::第一行伪元素的属性。对于所有其他的属性，都是从第一行伪元素的非伪元素父元素继承。(不出现在第一行的子元素的部分总是继承自该子元素的父元素)。

### 3.5.2. ::first-letter 伪元素

::first-letter 伪元素代表一个元素的第一个字母，如果它前面没有任何其他内容（如图像或内联表格）的话。::first-letter 伪元素可用于 "首字母大写 "和 "小写"，这是常见的排版效果。

标点符号（即 Unicode 中定义的 "开放"（Ps）、"关闭"（Pe）、"初始"（Pi）的字符。"最后"（Pf）和 "其他"（Po）的标点符号），在第一个字母之前或之后都应包括在内。[UNICODE]

在第一个字母之前的引号应被包括在内。

如果第一个字母实际上是一个数字，例如，"6700 万美元是很多钱 "中的 "6"，那么:第一字母也适用。

注意：在某些情况下，::first-letter 伪元素应该包括多于一行中的第一个非标点符号。例如，组合字符必须与它们的基本字符一起保留。此外，一些语言可能有关于如何处理某些字母组合的具体规则。UA 对::first-letter 的定义至少应包括 UAX29 所定义的默认字母群，并可根据情况包括更多。例如，在荷兰语中，如果字母组合 "ij "出现在一个元素的开头，那么这两个字母应该被认为是在::first-letter 伪元素中。[UAX29]

如果构成::第一个字母的字母不在同一个元素中，例如`<p>'<em>T...`中的`'T`，UA 可以从其中一个元素、两个元素中创建一个::第一个字母伪元素，或者干脆不创建伪元素。

同样，如果块的第一个字母不在行的开头（例如由于双向重新排序），那么 UA 不需要创建伪元素。

下面的 CSS 和 HTML 例子说明了重叠的伪元素如何交互。每个 P 元素的第一个字母将是绿色的，字体大小为 "24pt"。第一行格式化的其余部分将是'蓝色'，而该段的其余部分将是'红色'。

```css
p {
  color: red;
  font-size: 12pt;
}
p::first-letter {
  color: green;
  font-size: 200%;
}
p::first-line {
  color: blue;
}
```

```html
<p>一些结束于两行的文字</p>
```

假设在 "结束" 一词之前会有一个换行，这个片段的虚构标签序列可能是：

```html
<P>
<P::first-letter>
<P::first-letter>
S
</P::first-letter>ome text that
</P::first-line>
ends up on two lines
</P>
```

注意::first-letter 元素是在::first-line 元素里面。在::first-line 上设置的属性由::first-letter 继承，但如果在::first-letter 上设置了相同的属性，则会被覆盖。

第一个字母必须出现在第一个格式化的行上。例如，在这个 HTML 片段中。`<p><br>First...` 第一行不包含任何字母，并且::first-letter 不匹配任何东西（假设 HTML 4 中 br 的默认样式）。特别是，它不匹配 "First" 的 "F"。

### 3.5.3. ::before 和 ::after 伪元素

'::before'和'::after'伪元素可以用来在一个元素的内容之前或之后插入生成的内容。它们在生成文本部分有解释。

```css
h1::before {
  content: counter(chapno, upper-roman) '. ';
}
```

当 ::first-letter 和 ::first-line 伪元素被应用于一个有使用 ::before 和 ::after 生成的内容的元素时，它们适用于该元素的第一个字母或行，包括生成的内容。

```css
p.special::before {
  content: 'Special! ';
}
p.special::first-letter {
  color: #ffd800;
}
```

这将使 "Special！"的 "S"呈现为金色。

## 3.6. 组合符

组合使用不同的选择器可以匹配更特定的元素。有的组合选择器能将目标样式应用到更多元素，有的组合选择器则会锁定更少元素，总之会让你的选择非常具体。在接下来的几节中，我会为你展示组合使用选择器的各种方法。

### 3.6.1. 后代元素组合符

有时，作者可能希望选择器描述一个元素是文档树中另一个元素的后代元素（例如，"一个包含在 H1 元素中的 EM 元素"）。后代元素组合符表达了这样一种关系。后代元素组合符是分隔两个简单选择器序列的空白。一个 "A B "形式的选择器代表一个元素 B，它是某个祖先元素 A 的任意后代元素。

例如，考虑下面这个选择器:

```css
h1 em
```

它表示一个 em 元素是 h1 元素的后代元素。它是对以下片段的正确和有效的描述，但也是部分描述：

```css
<h1>这个<span class="myclass">标题
是<em>非常</em>重要的</span></h1>。
```

下面的选择器：

```css
div * p
```

代表一个 p 元素，它是 div 元素的孙子元素或后面的后代元素。注意 "\*" 两边的空白不是通用选择器的一部分；空白是一个组合符，表示 div 必须是某个元素的祖先元素，而该元素必须是 p 的祖先元素。

下面的选择器结合了后代元素组合符和属性选择器，表示一个元素：(1)设置了 href 属性；(2)位于本身位于 div 内的 p 内。

```css
div p *[href]
```

### 3.6.2. 子元素组合符

一个子元素组合符描述了两个元素之间的父子关系。子组合符由 "大于号"（U+003E，>）字符组成，并将两个简单选择器的序列分开。

下面的选择器表示一个 p 元素是 body 的子元素：

```css
body > p
```

下面的例子结合了后代元素组合符和子元素组合符：

```css
div ol>li p
```

它表示一个 p 元素是 li 元素的后代元素；li 元素必须是 ol 元素的子元素；ol 元素必须是 div 的后代元素。请注意，">"组合符周围的可选空白已经被省略。

关于选择一个元素的第一个子元素的信息，请看上面的 :first-child 伪类的部分。

### 3.6.3. 兄弟元素组合符

有两个不同的兄弟元素组合符：下一个兄弟元素组合符和后续兄弟元素组合符。在这两种情况下，在考虑元素的相邻关系时，非元素节点（如元素之间的文本）被忽略。

#### 3.6.3.1. 下一个兄弟元素组合符

下一个同族组合符是由 "加号"（U+002B，+）字符组成的，它将两个简单选择器的序列分开。这两个序列所代表的元素在文档树中共享同一个父级，第一个序列所代表的元素紧接在第二个序列所代表的元素之前。

下面的选择器表示一个 p 元素紧随一个数学元素之后：

```css
math + p
```

下面的选择器在概念上与前面的例子相似，只是它增加了一个属性选择器--它给 h1 元素增加了一个约束条件，即它必须有 class="opener"：

```css
h1.opener + h2
```

#### 3.6.3.2. 后续兄弟元素组合符

后续兄弟元素组合符是由 "tilde"（U+007E，~）字符组成的，它将两个简单选择器的序列分开。这两个序列所代表的元素在文档树中共享同一个父级，第一个序列所代表的元素在第二个序列所代表的元素之前（不一定马上）。

```css
h1 ~ pre
```

表示一个 pre 元素在 h1 之后。这是一个正确的、有效的、但部分的描述：

```html
<h1>函数a的定义</h1>
<p>函数a(x)必须应用于表格中的所有数字。</p>
<pre>函数a(x) = 12x/13.5</pre>
```
