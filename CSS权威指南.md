**目录：**

- [1. CSS 简介](#1-css-简介)
  - [1.1. CSS 历史](#11-css-历史)
  - [1.2. 惯例](#12-惯例)
    - [1.2.1. CSS 属性定义](#121-css-属性定义)
    - [1.2.2. 简写属性](#122-简写属性)
  - [1.3. 引入 CSS](#13-引入-css)
    - [1.3.1. 外部样式表](#131-外部样式表)
    - [1.3.2. 内部样式表](#132-内部样式表)
    - [1.3.3. 行内样式](#133-行内样式)
  - [1.4. CSS 处理模型](#14-css-处理模型)
  - [1.5. 重要概念](#15-重要概念)
  - [1.6. 媒体类型](#16-媒体类型)
    - [1.6.1. 媒体类型介绍](#161-媒体类型介绍)
    - [1.6.2. 指定媒体独立样式表](#162-指定媒体独立样式表)
      - [1.6.2.1. @media 规则](#1621-media-规则)
    - [1.6.3. 识别媒体类型](#163-识别媒体类型)
      - [1.6.3.1. 媒体组](#1631-媒体组)
- [2. 语法和基本数据类型](#2-语法和基本数据类型)
  - [2.1. 语法](#21-语法)
    - [2.1.1. 符号化](#211-符号化)
    - [2.1.2. 关键字](#212-关键字)
      - [2.1.2.1. 厂商前缀](#2121-厂商前缀)
    - [2.1.3. 字符和大小写](#213-字符和大小写)
  - [2.2. 语句](#22-语句)
  - [2.3. at 规则](#23-at-规则)
    - [2.3.1. 块](#231-块)
    - [2.3.2. 规则集，声明块和选择器](#232-规则集声明块和选择器)
    - [2.3.3. 声明和属性](#233-声明和属性)
    - [2.3.4. 注释](#234-注释)
  - [2.4. 值](#24-值)
    - [2.4.1. 整数和实数](#241-整数和实数)
    - [2.4.2. 长度](#242-长度)
      - [2.4.2.1. 绝对单位](#2421-绝对单位)
      - [2.4.2.2. 相对单位](#2422-相对单位)
    - [2.4.3. 百分数](#243-百分数)
    - [2.4.4. URL](#244-url)
    - [2.4.5. 颜色](#245-颜色)
    - [2.4.6. 字符串](#246-字符串)
    - [2.4.7. 角度](#247-角度)
    - [2.4.8. 时间](#248-时间)
- [3. 选择器](#3-选择器)
  - [3.1. 基本选择器](#31-基本选择器)
    - [3.1.1. 通用选择器](#311-通用选择器)
    - [3.1.2. 元素选择器](#312-元素选择器)
    - [3.1.3. 类选择器](#313-类选择器)
    - [3.1.4. id 选择器](#314-id-选择器)
    - [3.1.5. 属性选择器](#315-属性选择器)
  - [3.2. 组合选择器](#32-组合选择器)
    - [3.2.1. 后代选择器](#321-后代选择器)
    - [3.2.2. 直接后代选择器](#322-直接后代选择器)
    - [3.2.3. 兄弟选择器](#323-兄弟选择器)
    - [3.2.4. 相邻兄弟选择器](#324-相邻兄弟选择器)
  - [3.3. 伪元素选择器](#33-伪元素选择器)
    - [3.3.1. ::after](#331-after)
    - [3.3.2. ::before](#332-before)
    - [3.3.3. ::first-line](#333-first-line)
    - [3.3.4. ::first-letter](#334-first-letter)
    - [3.3.5. ::selection](#335-selection)
  - [3.4. 伪类选择器](#34-伪类选择器)
    - [3.4.1. 结构性伪类选择器](#341-结构性伪类选择器)
    - [3.4.2. UI 伪类选择器](#342-ui-伪类选择器)
    - [3.4.3. 动态伪类选择器](#343-动态伪类选择器)
    - [3.4.4. 其他伪类选择器](#344-其他伪类选择器)
  - [3.5. 并集选择器](#35-并集选择器)
- [4. 属性值，层叠和继承](#4-属性值层叠和继承)
  - [4.1. 指定值，计算值和实际值](#41-指定值计算值和实际值)
    - [4.1.1. 指定值](#411-指定值)
    - [4.1.2. 计算值](#412-计算值)
    - [4.1.3. 使用值](#413-使用值)
    - [4.1.4. 实际值](#414-实际值)
  - [4.2. 继承](#42-继承)
    - [4.2.1. inherit 值](#421-inherit-值)
  - [4.3. @import 规则](#43-import-规则)
  - [4.4. 层叠](#44-层叠)
    - [4.4.1. 层叠顺序](#441-层叠顺序)
    - [4.4.2. !important 规则](#442-important-规则)
    - [4.4.3. 特指度](#443-特指度)
- [5. 盒模型](#5-盒模型)
  - [5.1. 盒子尺寸](#51-盒子尺寸)
  - [5.2. 外边距长度](#52-外边距长度)
    - [5.2.1. 外边距折叠](#521-外边距折叠)
  - [5.3. 内边距长度](#53-内边距长度)
  - [5.4. 边框属性](#54-边框属性)
    - [5.4.1. 边框长度](#541-边框长度)
    - [5.4.2. 边框颜色](#542-边框颜色)
    - [5.4.3. 边框样式](#543-边框样式)
    - [5.4.4. 边框简写属性](#544-边框简写属性)
  - [5.5. 行内元素与 direction](#55-行内元素与-direction)
- [6. 视觉格式化模型](#6-视觉格式化模型)
  - [6.1. 视觉格式化模型简介](#61-视觉格式化模型简介)
    - [6.1.1. 视口](#611-视口)
    - [6.1.2. 包含块](#612-包含块)
  - [6.2. 控制盒子生成](#62-控制盒子生成)
    - [6.2.1. 块级元素和块级盒子](#621-块级元素和块级盒子)
      - [6.2.1.1. 匿名块盒子](#6211-匿名块盒子)
  - [6.3. 定位方案](#63-定位方案)
  - [6.4. 正常流](#64-正常流)
  - [6.5. 浮动](#65-浮动)
  - [6.6. 绝对定位](#66-绝对定位)
  - [6.7. display, position 和 float 之间的关系](#67-display-position-和-float-之间的关系)
  - [6.8. 对比正常流，浮动和绝对定位](#68-对比正常流浮动和绝对定位)
  - [6.9. 分层显示](#69-分层显示)
  - [6.10. 文本方向](#610-文本方向)
- [7. 格式化细节](#7-格式化细节)
  - [7.1. 包含块的定义](#71-包含块的定义)
  - [7.2. 内容宽度：width 属性](#72-内容宽度width-属性)
  - [7.3. 计算 width 和 margin](#73-计算-width-和-margin)
  - [7.4. 最小与最大宽度](#74-最小与最大宽度)
  - [7.5. 内容高度：height 属性](#75-内容高度height-属性)
  - [7.6. 计算 height 和 margin](#76-计算-height-和-margin)
  - [7.7. 最小与最大高度](#77-最小与最大高度)
  - [7.8. 行高的计算](#78-行高的计算)
- [8. 弹性盒子布局](#8-弹性盒子布局)
- [9. 网格布局](#9-网格布局)
- [10. 表格](#10-表格)
- [11. 生成内容和列表](#11-生成内容和列表)
- [12. 颜色，背景和渐变](#12-颜色背景和渐变)
  - [12.1. 颜色](#121-颜色)
  - [12.2. 背景](#122-背景)
  - [12.3. 渐变](#123-渐变)
- [13. 字体](#13-字体)
  - [13.1. font-family](#131-font-family)
  - [13.2. @font-face](#132-font-face)
  - [13.3. font-weight](#133-font-weight)
  - [13.4. font-size](#134-font-size)
    - [13.4.1. 绝对大小](#1341-绝对大小)
    - [13.4.2. 相对大小](#1342-相对大小)
    - [13.4.3. 长度单位](#1343-长度单位)
  - [13.5. font-style](#135-font-style)
  - [13.6. font-variant](#136-font-variant)
  - [13.7. font](#137-font)
- [14. 文本](#14-文本)
  - [14.1. 缩进与行内对齐](#141-缩进与行内对齐)
    - [14.1.1. text-indent](#1411-text-indent)
    - [14.1.2. text-align](#1412-text-align)
    - [14.1.3. text-align-last](#1413-text-align-last)
  - [14.2. 块级对齐](#142-块级对齐)
    - [14.2.1. line-height](#1421-line-height)
    - [14.2.2. vertical-align](#1422-vertical-align)
  - [14.3. 文本间距](#143-文本间距)
    - [14.3.1. wording-spacing](#1431-wording-spacing)
    - [14.3.2. letter-spacing](#1432-letter-spacing)
  - [14.4. text-transform](#144-text-transform)
  - [14.5. text-decoration](#145-text-decoration)
  - [14.6. text-shadow](#146-text-shadow)
  - [14.7. 处理空白](#147-处理空白)
    - [14.7.1. white-space](#1471-white-space)
    - [14.7.2. tab-size](#1472-tab-size)
  - [14.8. 换行和断字](#148-换行和断字)
    - [14.8.1. word-break](#1481-word-break)
    - [14.8.2. line-break](#1482-line-break)
    - [14.8.3. overflow-wrap](#1483-overflow-wrap)
  - [14.9. 书写模式](#149-书写模式)
    - [14.9.1. writing-mode](#1491-writing-mode)
    - [14.9.2. text-orientation](#1492-text-orientation)

# 1. CSS 简介

## 1.1. CSS 历史

1994 年，正值 Web 开始广泛流行开来，CSS 的第一个提案发布了。那时，浏览器为用户提供了各种各样的定制功能。例如，用户在 Mosaic 的表现偏好设置中可以为单个元素设定字体族，字号和颜色。而文档的编写人员却做不到这一点，文档编写人员只能把内容标记称一个个段落，标题，预格式文本，或者一些其他类型的元素。如果用户愿意，可以把以及标题设为粉红色的小字，而把六级标题设为红色的大字。

CSS 就是在这样的背景下诞生的。它的目标是提供一个简单的声明式样式语言，而且具有一定的灵活性，能为文档编写人员和用户提供等同的样式化功能。层叠样式表中的“层叠”是指样式表可以结合起来使用，而且具有优先级，文档编写人员和用户都有话语权，不过最终的决策权在用户手中。

草案制定的速度很快，到 1996 年末，CSS1 完成了。此后，刚组建的 CSS 工作组开始着手制定 CSS2，而各个浏览器则相互协作，努力实现 CSS1。单独来看，CSS 的每一部分都很简单，但把各部分放在一起就变得已成复杂。而且早期的实现有些先天不足。例如，不同浏览器对盒模型(Box Model)的实现差异尤其为人诟病。这些问题直接影响到 CSS 的名声，幸好一些聪明人提出了变通方法，让浏览器的行为保持了一致。得益于一致性的提高和高调的开发活动，几年之间，CSS 逐渐开始流行。

不过，在此之前，CSS2 规范于 1998 年初定案。随后，CSS 工作组立即投身 CSS3 的制定工作，以及 CSS2 的修订工作。与以往不同的是，CSS3 有多个模块构成，而不是单独一个臃肿的规范。XHTML 规范受此启发，也采用了模块机制。

CSS3 分成多个模块的根本原因是各模块可以独立演进，尤其是模块可以按照 W3C 的规划向前推进，而不必受其他模块拖累。事实证明，这样做是对的。截至 2012 年初，有 3 个 CSS3 模块(CSS Color Level 3，CSS Namespace，Selectors Level 3) 变成了推荐状态，而有 7 个模块处于候选状态，还有 7 个模块处在不同的草案状态。如果采用以前的机制，要等到其他部分完成才能在一份完成的规范中发布颜色，选择器和命名控件的新条款。得益于模块化，我们无需等待。

但是，这样做也有缺点，CSS3 规范不能涵盖一切。即便其他模块在某一时刻到达了 Level 3，比如说 2016 年末（然而事实是没有），Selectors Level 4 也都开始制定了。那会不会有 CSS4？CSS3 那些尚未正式发布的新特性呢？还有 Grid Layout，它甚至还没到 Level 1！

可见，我们不能指着一摞厚厚的文件说，这就是 CSS3，而应该分模块学习不同的特性。模块的灵活性有时可以弥补语义不足。

## 1.2. 惯例

### 1.2.1. CSS 属性定义

每个 CSS 属性定义的开头都有一个关键信息的摘要，类似于以下内容：

| 属性名   | 属性的名字         |
| -------- | ------------------ |
| 属性值   | 合法值和语法       |
| 初始值   | 初始值             |
| 适用元素 | 该属性适用的元素   |
| 可继承性 | 该属性是否可被继承 |
| 百分数值 | 百分数值解释方式   |
| 适用媒体 | 该属性适用的媒体组 |
| 计算值   | 计算值的计算方式   |

- **属性值**

这一部分规定了属性值的有效值集。一个属性值可以有一个或多个组件。组件值的类型有几种指定方式：

- 关键字值（例如，auto, inherit 等）
- 基本数据类型，出现在"<"和">"之间（例如，`<length>`，`<percentage>`，等等）。
- 与同名属性具有相同取值范围的类型（例如，<'border-width'> <'background-attachment'>，等等）。在这种情况下，类型名称是"<"和">"之间的属性名称（完整的引号）（例如，<'border-width'>）。这样的类型不包括 'inherit' 这个值。
- 与属性不共享同一名称的非终结符。在这种情况下，非终结符出现在"<"和">"之间，如`<border-width>`。注意`<border-width>`和`<'border-width'>`之间的区别；后者是根据前者来定义的。

这些定义中的其他词语是关键词，必须按字面意思出现，不加引号（例如，red）。斜线（/）和逗号（,）也必须按字面意思出现。

组件值可按以下方式排列成属性值：

- 几个并列的词意味着它们都必须按照给定的顺序出现。
- 一个竖线(|)分隔了两个或更多的选项：其中必须有一个正好出现。
- 一个双竖线(||)分隔两个或多个选项：其中一个或多个必须以任何顺序出现。
- 一个双和号(&&)分隔两个或更多的组件，所有这些组件必须以任何顺序出现。
- 括号（[ ]）是用来分组的。

并列比双和号强，双和号比双竖线强，双竖线比竖线强。因此，以下 2 行是等同的：

```
a b | c || d && e f
[ a b ] | [ c || [ d && [ e f ]] ]
```

每个类型、关键字或括号内的组都可以在后面加上以下修饰语之一。

- 星号（\*）表示前面的类型、词或组出现了零次或多次。
- 加号（+）表示前面的类型、词或组出现一次或多次。
- 问号(?)表示前面的类型、词或组是可选的。
- 大括号中的一对数字（{A,B}）表示前面的类型、词或组至少出现 A 次，最多 B 次。

下面的例子说明了不同的值类型：

```css
属性值: N | NW | NE
属性值: [ <length> | thick | thin ]{1,4}
属性值: [<family-name> , ]* <family-name>
属性值: <uri>? <color> [ / <color> ]?
属性值: <uri> || <color>
属性值: inset? && [ <length>{2,4} && <color>? ]
```

属性值中的符号之间也可能出现空格。

注意：在许多情况下，为了将它们彼此区分开来，符号之间实际上需要空格。例如，值'1em2em'会被解析为一个带有数字'1'和标识符'em2em'的单一 DIMEN 符号，这是一个无效的单位。在这种情况下，需要在'2'前加一个空格，以便将其解析为两个长度的'1em'和'2em'。

- **初始值**

这一部分指定了属性的初始值。关于样式表指定的、继承的和初始属性值之间的交互信息，请参考 [层叠](#44-层叠) 部分。

- **适用元素**

这一部分列出了该属性所适用的元素。所有的元素都被认为拥有所有的属性，但有些属性对某些类型的元素没有渲染效果。例如，'clear' 属性只影响到块级元素。

- **可继承性**

这一部分表示该属性的值是否从祖先元素继承。关于样式表指定的、继承的和初始属性值之间的交互信息，请参考 [层叠](#44-层叠) 部分。

- **百分数值**

如果百分数值出现在属性的值中，这部分表明应如何解释百分数值。如果 "N/A" 出现在这里，这意味着该属性不接受百分数值。

- **适用媒体**

这一部分表示该属性所适用的媒体组。请参见 [媒体类型](#16-媒体类型) 部分。

- **计算值**

这一部分描述了该属性的计算值。关于此定义的使用方法，请参见 [计算值](#412-计算值) 部分。

### 1.2.2. 简写属性

有些属性是简写属性，意味着它们允许作者用一个属性来指定几个属性的值。

例如，'font' 属性是一个速记属性，可以同时设置 'font-style'、'font-variant'、'font-weight'、'font-size'、'line-height'和'font-family'。

当值从速记表格中省略时，每个“缺失”的属性都会被分配其初始值（见关于 [层叠](#44-层叠) 的部分）。

这个例子中的多个样式规则:

```css
h1 {
  font-weight: bold;
  font-size: 12pt;
  line-height: 14pt;
  font-family: Helvetica;
  font-variant: normal;
  font-style: normal;
}
```

可以用一个简写属性重写：

```css
h1 {
  font: bold 12pt/14pt Helvetica;
}
```

在这个例子中，'font-variant' 和 'font-style' 取其初始值。

## 1.3. 引入 CSS

在学习 CSS 之前，我们得首先在 HTML 关联 CSS，不然 CSS 就没法影响 HTML 文档。下面介绍 3 种引入 CSS 的方式。

### 1.3.1. 外部样式表

外部样式表式引入 CSS 最常用的方式。这种方式用到了 link 元素，例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>外部样式表</title>
    <link rel="stylesheet" href="style.css" media="screen" />
  </head>
  <body></body>
</html>
```

上述例子向 HTML 文档中引入了一个 style.css 外部样式表。

外部样式表中没有任何 HTML 标签。外部样式表保存为纯文本文件，文件扩展名是 .css。

- link 元素的属性

link 元素的 rel 属性表示链接资源和 HTML 文档的关系，对于 CSS 文档来说，就是“stylesheet”。

link 元素的 href 属性制定了链接资源的地址。

最后的 media 属性，它的值是一个或多个媒体描述符(media descriptor)，表示什么样的媒体应该使用这个 CSS 文档。例如：

```html
<link rel="stylesheet" href="style.css" media="screen, screen" />
```

多个媒体描述符用逗号分隔。媒体描述符本书后面会详细的介绍。

link 的 type 属性现在已经不常用了，它用来指定资源的 MIME 类型，不过对于 CSS 文档，浏览器默认为 "text/css"。

- @import

@import 指令可以出现在 CSS 文档中，它的作用是链接另外一个 CSS 文档。例如：

```css
@import url(basic.css);
```

@import 指令必需放在 CSS 规则之前，否则不会有效。

### 1.3.2. 内部样式表

另外一种引入 CSS 的方式是通过 style 元素。例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>内部样式表</title>
    <style>
      h1 {
        color: red;
      }

      h2 {
        color: maroon;
        background: black;
      }
    </style>
  </head>
  <body></body>
</html>
```

内部样式表的层叠优先级大于外部样式表。本书后面会详细讨论。

### 1.3.3. 行内样式

最后一种的方式是通过 HTML 元素的 style 全局属性。例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>行内样式</title>
  </head>
  <body>
    <p style="color: red;">一段文本。</p>
  </body>
</html>
```

这种方式应用的 CSS 样式层叠优先级最高。但是这种方式使用 CSS 不好管理。

## 1.4. CSS 处理模型

本节介绍了支持 CSS 的用户代理如何工作的一个可能模型。这只是一个概念性的模型；实际的实现可能会有所不同。

在这个模型中，用户代理通过以下步骤来处理一个源。

1. 解析源文档并创建一个文档树。
2. 识别目标媒体类型。
3. 检索所有与该文档相关的、为目标媒体类型指定的样式表。
4. 通过给适用于目标媒体类型的每个属性分配一个单一的值来注释文档树的每个元素。属性是根据层叠和继承一节中描述的机制来分配数值的。部分数值的计算取决于适合于目标媒体类型的格式化算法。例如，如果目标媒体是屏幕，用户代理会应用视觉格式化模型。
5. 从注释的文档树中，生成一个格式化结构。通常，格式化结构与文档树非常相似，但也可能有很大不同，特别是当作者使用伪元素和生成的内容时。首先，格式化结构根本不需要是 "树形 "的，结构的性质取决于实现。第二，格式化结构可能包含比文档树更多或更少的信息。例如，如果文档树中的一个元素的 "display "属性的值是 "none"，那么这个元素在格式化结构中就不会产生任何信息。另一方面，一个列表元素可能会在格式化结构中产生更多的信息：列表元素的内容和列表样式信息（例如，一个子弹头图像）。请注意，CSS 用户代理在这个阶段不会改变文档树。特别是，由于样式表产生的内容不会被反馈给文档语言处理器（例如，用于重新解析）。
6. 将格式化结构转移到目标媒体（例如，打印结果、在屏幕上显示、渲染成语音等）。

## 1.5. 重要概念

- **样式表**

一组指定文档表现形式的语句。
样式表可能有三个不同的来源：作者、用户、和用户代理。这些来源的交互在层叠和继承一节中描述。

- **有效样式表**

样式表的有效性取决于样式表所使用的 CSS 的级别。所有有效的 CSS1 样式表都是有效的 CSS2.2 样式表，但是 CSS1 的一些变化意味着一些 CSS1 样式表在 CSS2.2 中会有轻微的语义不同。CSS2 中的一些特性不是 CSS2.2 的一部分，所以不是所有的 CSS2 样式表都是有效的 CSS2.2 样式表。

一个有效的 CSS2.2 样式表必须按照 CSS2.2 的语法来写。此外，它必须只包含本规范中定义的 at-rules、属性名称和属性值。一个非法的（无效的）at-rule、属性名或属性值是无效的。

- **源文档**

一个或多个样式表所适用的文档。这是用某种语言编码的，它把文档表示为一棵元素树。每个元素由一个识别元素类型的名称、可选择的一些属性和一个（可能是空的）内容组成。例如，源文件可以是一个 XML 或 SGML 实例。

- **文档语言**

源文档的编码语言（例如，HTML、XHTML 或 SVG）。CSS 用于描述文档语言的表现形式，CSS 并不改变文档语言的基本语义。

- **元素**

文档语言的主要语法结构。大多数 CSS 样式表规则使用这些元素的名称（如 HTML 中的 P、TABLE 和 OL）来指定这些元素应该如何被呈现。

- **替换性元素**

一个内容不在 CSS 格式化模型范围内的元素，如图像、嵌入式文档或小程序。例如，HTML IMG 元素的内容经常被其 "src" 属性指定的图像所取代。被替换的元素通常有固有的尺寸：固有的宽度、固有的高度和固有的比例。例如，一个位图图像有一个以绝对单位指定的固有宽度和固有高度（固有尺寸比显然可以从这里确定）。另一方面，其他文档可能没有任何固有的尺寸（例如，一个空白的 HTML 文档）。

如果用户代理认为一个被替换的元素没有任何固有的尺寸，那么这些尺寸可能会向第三方泄露敏感信息。例如，如果一个 HTML 文档根据用户的银行余额改变了固有的尺寸，那么 UA 可能希望像该资源没有固有的尺寸一样行事。

被替换的元素的内容在 CSS 渲染模型中不被考虑。

- **固有尺寸**

由元素本身定义的宽度和高度，而不是由周围环境强加的。CSS 并没有定义如何找到固有尺寸。在 CSS 2.2 中，只有被替换的元素可以带有固有的尺寸。对于没有可靠分辨率信息的光栅图像，必须假定每个图像源像素的尺寸为 1px 单位。

- **属性**

一个与元素相关的值，由一个名称和一个相关的（文本）值组成。

- **内容**

在源文档中与一个元素相关的内容。有些元素没有内容，在这种情况下，它们被称为 **空元素**。一个元素的内容可能包括文本，也可能包括一些子元素，在这种情况下，该元素被称为这些子元素的父元素。

- **忽略**

这个术语在本规范中有两种略有不同的含义。首先，一个 CSS 解析器在发现样式表中的未知或非法语法时必须遵循某些规则。然后，解析器必须忽略样式表的某些部分。哪些部分必须被忽略的确切规则在这些章节（声明和属性、处理解析错误的规则、不支持的值）中描述，或者可以在术语 "忽略 "出现的文本中解释。第二，一个用户代理可以（而且在某些情况下必须）不理会样式表中的某些属性或值，即使语法是合法的。例如，表列元素不能影响表列的字体，所以字体属性必须被忽略。

- **渲染内容**

一个元素的内容在根据相关样式表适用于它的渲染后被应用。一个替换性元素的内容是如何被渲染的，本规范没有定义。渲染的内容也可以是一个元素的替代文本（例如，XHTML "alt" 属性的值），并可能包括由样式表隐含地或显式地插入的项目，如栏目、编号等。

- **文档树**
  在源文档中编码的元素树。这个树中的每个元素都有一个父元素，但根元素除外，它没有。

- **子元素**

当且仅当 B 是 A 的父元素时，一个元素 A 被称为元素 B 的子元素。

- **后代元素**

一个元素 A 被称为元素 B 的后代元素，如果(1)A 是 B 的一个子元素，或者(2)A 是某个元素 C 的子元素，而这个元素 C 是 B 的后代元素。

- **祖先元素**

当且仅当 B 是 A 的后代元素时，元素 A 被称为元素 B 的祖先元素。

- **兄弟元素**

一个元素 A 被称为元素 B 的兄弟元素，当且仅当 B 和 A 共享同一个父元素。如果元素 A 在文档树中排在元素 B 之前，它就是一个前级兄弟姐妹。如果元素 B 在文档树中排在 A 的后面，那么它就是一个跟随的兄弟姐妹。

- **前置元素**

当且仅当(1)A 是 B 的祖先或(2)A 是 B 的前面的兄弟元素时，一个元素 A 被称为元素 B 的前置元素。

- **后置元素**

当且仅当 B 是 A 的前面的元素时，一个元素 A 被称为 B 的后置元素。

- **作者**

作者是一个编写文档和相关样式表的人。编写工具是一个生成样式表的用户代理。

- **用户**

用户是与用户代理互动以查看、听取或以其他方式使用一个文件及其相关的样式表的人。用户可以提供一个编码个人偏好的个人样式表。

- **用户代理（UA）**

用户代理是任何解释以文档语言编写的文档并根据本规范的条款应用相关样式表的程序。一个用户代理可以显示一个文档，大声朗读它，使它被打印出来，把它转换成另一种格式，等等。

一个 HTML 用户代理是一个支持一个或多个 HTML 规范的用户代理。一个支持 XHTML[XHTML]，但不支持 HTML 的用户代理不被认为是一个符合本规范的 HTML 用户代理。

- **属性**

CSS 定义了一个有限的参数集，称为属性，用于指导文档的渲染。每个属性都有一个名称（例如，'color'、'font' 或 'border'）和一个值（例如，'red'、'12pt' 或 'dotted'）。属性通过特指度、层叠和继承等机制被附加到文档的各个部分和显示文档的页面上（见 "属性值、层叠和继承" 章节）。

## 1.6. 媒体类型

### 1.6.1. 媒体类型介绍

样式表的一个最重要的特点是，它们规定了一个文档在不同媒体上的呈现方式：在屏幕上、在纸上、用语音合成器、用盲文设备等等。

某些 CSS 属性只为某些媒体而设计（例如，'page-break-before' 属性只适用于分页媒体）。然而，有时候，不同媒体类型的样式表可能共享一个属性，但要求该属性的值不同。例如，'font-size' 属性对屏幕和印刷媒体都有用。这两种媒体类型是不同的，以至于需要为这个共同的属性取不同的值；一个文档在电脑屏幕上通常需要一个比纸上更大的字体。因此，有必要表达一个样式表，或一个样式表的某个部分，适用于某些媒体类型。

### 1.6.2. 指定媒体独立样式表

目前有两种方法来指定样式表的媒体依赖性：

- 用@media 或@import at-rules 从样式表中指定目标媒体。

```css
@import url('fancyfonts.css') screen;
@media print {
  /* 用于打印的样式表放在这里 */
}
```

- 在文档语言中指定目标媒体。例如，在 HTML 4（[HTML4]）中，LINK 元素上的 "media" 属性指定了一个外部样式表的目标媒体。

```css
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
   <HEAD>
      <TITLE>Link to a target medium</TITLE>
      <LINK REL="stylesheet" TYPE="text/css"
	 MEDIA="print, handheld" HREF="foo.css">
   </HEAD>
   <BODY>
      <P>The body...
   </BODY>
</HTML>
```

@import 规则在关于层叠的章节中定义。

#### 1.6.2.1. @media 规则

一个@media 规则指定了一组声明（以大括号为界）的目标媒体类型（以逗号分隔），无效的语句必须被忽略。@media 结构允许在同一个样式表中为各种媒体制定样式表规则。

@media 规则之外的样式规则适用于样式表所适用的所有媒体类型。在@media 里面的规则在 CSS 2.2 中是无效的。

### 1.6.3. 识别媒体类型

为 CSS 媒体类型选择的名称反映了相关属性对其有意义的目标设备。在下面的 CSS 媒体类型列表中，媒体类型的名称是规范性的，但描述是信息性的。同样地，每个属性描述中的 "Media" 字段也是信息性的。

- all
  适用于所有设备。

- braille
  适用于盲文触觉反馈设备。

- embossed
  打算用于分页盲文打印机。

- handheld
  适用于手持设备（通常是小屏幕，带宽有限）。

- print
  适用于分页材料和在屏幕上以打印预览模式查看的文件。

- projection
  适用于投影演示，例如投影仪。请查阅关于分页媒体的部分，了解分页媒体特有的格式问题。

- screen
  主要用于彩色计算机屏幕。

- speech
  适用于语音合成器。注意：CSS2 有一个类似的媒体类型，称为 "aural"，用于这一目的。

- tty
  用于使用固定间距字符网格的媒体（如电话机、终端或显示能力有限的便携式设备）。作者不应使用 "tty "媒体类型的像素单位。

- tv
  用于电视类型的设备（低分辨率、彩色、有限的可滚动屏幕，有声音）。
  媒体类型名称是不区分大小写的。

媒体类型是相互排斥的，即一个用户代理在渲染一个文件时只能支持一种媒体类型。然而，用户代理可以在不同的画布上使用不同的媒体类型。例如，一个文件可以（同时）在一个画布上以 "screen" 模式显示，在另一个画布上以 "print" 模式显示。

请注意，一个多模态媒体类型仍然只是一个媒体类型。例如，"tv" 媒体类型是一种多模态媒体类型，它在视觉和听觉上都呈现在一个画布上。

带有未知媒体类型（但仍是有效的标识符）的@media 和@import 规则被视为不存在未知媒体类型。如果一个@media/@import 规则包含一个错误的媒体类型（不是一个标识符），那么这个声明是无效的。

注意：媒体查询忽略了这种错误处理。

例如，在下面的片段中，P 元素上的规则适用于 "print" 模式（即使 "3D" 媒体类型不详）。

```css
@media screen, 3d {
  P {
    color: green;
  }
}
```

注意。未来的 CSS 更新可能会扩展媒体类型的列表。作者不应该依赖那些尚未被 CSS 规范定义的媒体类型名称。

#### 1.6.3.1. 媒体组

本节是信息性的，不是规范性的。

每个 CSS 属性定义都指定了该属性适用于哪些媒体类型。由于属性通常适用于几种媒体类型，每个属性定义的 "适用媒体" 部分列出了媒体组而不是单个媒体类型。每个属性都适用于其定义中所列媒体组中的所有媒体类型。

CSS 2.2 定义了以下媒体组。

- **连续** 或 **分页**。
- **视觉**、**音频**、**语音** 或 **触觉**。
- **网格**（用于字符网格设备），或 **位图**。
- **交互的**（用于允许用户交互的设备），或 **静态的**（用于不允许交互的设备）。
- **所有**（包括所有媒体类型）

下表显示了媒体组和媒体类型之间的关系。

| 媒体类型   | 连续/分页 | 视觉/音频/语音/触觉 | 网格/位图 | 交互的/静态的 |
| ---------- | --------- | ------------------- | --------- | ------------- |
| braille    | 连续      | 触觉                | 网格      | 都是          |
| embossed   | 分页      | 触觉                | 网格      | 静态          |
| handheld   | 都是      | 视觉，音频，语音    | 都是      | 都是          |
| print      | 分页      | 视觉                | 位图      | 静态          |
| projection | 分页      | 视觉                | 位图      | 交互          |
| screen     | 连续      | 视觉、音频          | 位图      | 都是          |
| speech     | 连续      | 语音                | N/A       | 都是          |
| tty        | 连续      | 视觉                | 网格      | 都是          |
| tv         | 都是      | 视觉，音频          | 位图      | 都是          |

# 2. 语法和基本数据类型

## 2.1. 语法

本节描述了任何级别的 CSS（包括 CSS 2.2）所共有的语法（以及向前兼容的解析规则）。未来的 CSS 更新将遵守这一核心语法，尽管它们可能会增加额外的语法约束。

这些描述是规范性的。

在本规范中，"紧接在前" 或 "紧接在后" 的表述是指没有中间的空白或注释。

### 2.1.1. 符号化

所有级别的 CSS--level 1、level 2 和任何未来的级别--都使用相同的核心语法。这使得用户代理能够解析（尽管不能完全理解）用 CSS 级别编写的样式表，而这些级别在用户代理创建时还不存在。设计师可以利用这一特点来创建适用于较早的用户代理的样式表，同时也可以利用最新级别的 CSS 的可能性。

在词法层面上，CSS 样式表由一连串的词法单元组成。CSS 的词法单元列表如下。这些定义使用 Lex 风格的正则表达式。八进制代码参考了 ISO 10646（[ISO10646]）。和 Lex 一样，在有多个匹配的情况下，最长的匹配决定了标记。

| 词法单元      | 定义                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------ | ---------------------- | ---------------------- | ---------------------- | ---------------------- | -------------- | ------------------------------- |
| IDENT         | `{ident}`                                                    |
| ATKEYWORD     | `@{ident}`                                                   |
| STRING        | `{string}`                                                   |
| BAD_STRING    | `{badstring}`                                                |
| BAD_URI       | `{baduri}`                                                   |
| BAD_COMMENT   | `{badcomment}`                                               |
| HASH          | `#{name}`                                                    |
| NUMBER        | `{num}`                                                      |
| PERCENTAGE    | `{num}%`                                                     |
| DIMENSION     | `{num}{ident}`                                               |
| URI           | `{U}{R}{L}\({w}{string}{w}\)                                 | {U}{R}{L}\({w}([!#$%&*-\[\]-~] | {nonascii}             | {escape})\*{w}\)`      |
| UNICODE-RANGE | `u\+[?]{1,6}                                                 | u\+[0-9a-f]{1}[?]{0,5}         | u\+[0-9a-f]{2}[?]{0,4} | u\+[0-9a-f]{3}[?]{0,3} | u\+[0-9a-f]{4}[?]{0,2} | u\+[0-9a-f]{5}[?]{0,1} | u\+[0-9a-f]{6} | u\+[0-9a-f]{1,6}-[0-9a-f]{1,6}` |
| CDO           | `<!--`                                                       |
| CDC           | `-->`                                                        |
| :             | `:`                                                          |
| ;             | `;`                                                          |
| {             | `\{`                                                         |
| }             | `\}`                                                         |
| (             | `\(`                                                         |
| )             | `\)`                                                         |
| [             | `\[`                                                         |
| ]             | `\]`                                                         |
| S             | `[ \t\r\n\f]+`                                               |
| COMMENT       | `\/\*[^*]*\*+([^/*][^*]*\*+)*\/`                             |
| FUNCTION      | `{ident}\(`                                                  |
| INCLUDES      | `~=`                                                         |
| DASHMATCH     | `                                                            | =`                             |
| DELIM         | 任何未被上述规则匹配的其他字符，并且既不是单引号也不是双引号 |

上面大括号（{}）中的宏定义如下:

| 宏          | 定义                           |
| ----------- | ------------------------------ | -------------------------------- | --------------- | ------------- | ---- |
| ident       | `[-]?{nmstart}{nmchar}*`       |
| name        | `{nmchar}+`                    |
| nmstart     | `[_a-z]                        | {nonascii}                       | {escape}`       |
| nonascii    | `[^\0-\177]`                   |
| unicode     | `\\[0-9a-f]{1,6}(\r\n          | [ \n\r\t\f])?`                   |
| escape      | `{unicode}                     | \\[^\n\r\f0-9a-f]`               |
| nmchar      | `[_a-z0-9-]                    | {nonascii}                       | {escape}`       |
| num         | `[+-]?([0-9]+                  | [0-9]\*\.[0-9]+)(e[+-]?[0-9]+)?` |
| string      | `{string1}                     | {string2}`                       |
| string1     | `\"([^\n\r\f\\"]               | \\{nl}                           | {escape})\*\"`  |
| string2     | `\'([^\n\r\f\\']               | \\{nl}                           | {escape})\*\'`  |
| badstring   | `{badstring1}                  | {badstring2}`                    |
| badstring1  | `\"([^\n\r\f\\"]               | \\{nl}                           | {escape})\*\\?` |
| badstring2  | `\'([^\n\r\f\\']               | \\{nl}                           | {escape})\*\\?` |
| badcomment  | `{badcomment1}                 | {badcomment2}`                   |
| badcomment1 | `\/\*[^*]*\*+([^/*][^*]*\*+)*` |
| badcomment2 | `\/\*[^*]*(\*+[^/*][^*]*)*`    |
| baduri      | `{baduri1}                     | {baduri2}                        | {baduri3}`      |
| baduri1     | `{U}{R}{L}\({w}([!#$%&*-~]     | {nonascii}                       | {escape})\*{w}` |
| baduri2     | `{U}{R}{L}\({w}{string}{w}`    |
| baduri3     | `{U}{R}{L}\({w}{badstring}`    |
| nl          | `\n                            | \r\n                             | \r              | \f`           |
| w           | `[ \t\r\n\f]*`                 |
| L           | `l                             | \\0{0,4}(4c                      | 6c)(\r\n        | [ \t\r\n\f])? | \\l` |
| R           | `r                             | \\0{0,4}(52                      | 72)(\r\n        | [ \t\r\n\f])? | \\r` |
| U           | `u                             | \\0{0,4}(55                      | 75)(\r\n        | [ \t\r\n\f])? | \\u` |

例如，最长匹配规则意味着 "red-->"被标记为 IDENT "red--"后面是 DELIM">"，而不是 IDENT 后面是 CDC。

下面是 CSS 的核心语法。接下来的章节描述了如何使用它。附录 G 描述了一个更严格的语法，它更接近于 CSS 2 级语言。样式表中可以根据这个语法解析的部分，但不能根据附录 G 中的语法解析的部分，根据处理解析错误的规则，将被忽略。

| 语法单元 | 定义                             |
| -------- | -------------------------------- | ---------------- | ----------------- | ------------------ | -------- | ----- | --- | ---- | ------------- | -------- | --------- | --- | ----------------- | ------------- | ------------ | ------------- | ------------ | ----------------- |
| 样式表   | `[ CDO                           | CDC              | S                 | 语句 ]\*`          |
| 语句     | `规则集                          | at 规则`         |
| at 规则  | `ATKEYWORD S* any* [ 块          | ';' S\* ]`       |
| 块       | `'{' S\* [ any                   | 块               | ATKEYWORD S\*     | ';' S* ]* '}' S\*` |
| 规则集   | `选择器? '{' S* 声明列表 '}' S*` |
| 声明列表 | `声明 [ ';' S* 声明列表 ]?       | at 规则 声明列表 | /_ empty _/`      |
| 选择器   |                                  | `any+`           |
| 声明     | `属性 S* ':' S* 值`              |
| 属性     | `IDENT`                          |
| 值       | `[ any                           | 块               | ATKEYWORD S\* ]+` |
| any      | `[ IDENT                         | NUMBER           | PERCENTAGE        | DIMENSION          | STRING   | DELIM | URI | HASH | UNICODE-RANGE | INCLUDES | DASHMATCH | ':' | FUNCTION S\* [any | unused]\* ')' | '(' S\* [any | unused]\* ')' | '[' S\* [any | unused]_ ']'] S_` |
| unused   | `块                              | ATKEYWORD S\*    | ';' S\*           | CDO S\*            | CDC S\*` |

在 CSS 中没有使用 "unused" 语法产生式，将来也不会被任何扩展使用。它被包括在这里只是为了帮助处理错误。

COMMENT（注释）标记没有出现在语法中（以保持其可读性），但是任何数量的这些标记都可以出现在其他标记之外的任何地方。（但是请注意，在@charset 规则之前或之内的注释会禁用@charset）。

上述语法中的标记 S 代表空白。只有 "空格"（U+0020）、"制表"（U+0009）、"换行"（U+000A）、"回车"（U+000D）和 "换页"（U+000C）这些字符可以出现在空白处。其他类似空间的字符，如 "em-space"（U+2003）和 "ideographic space"（U+3000），从来不是空白空间的一部分。

在 CSS 2.2 中没有定义不能被此法单元或解析的输入的含义。

### 2.1.2. 关键字

关键词具有标识符的形式。关键词不能放在引号（"... "或'...'）之间。因此。

red 是一个关键词，但 "red"不是。(它是一个字符串。) 其他非法的例子：

```css
width: 'auto';
border: 'none';
background: 'red';
```

#### 2.1.2.1. 厂商前缀

在 CSS 中，标识符可以以'-'（破折号）或 '\_'（下划线）开头。以'-'或 '\_' 开头的关键词和属性名称被保留给厂商特定的扩展。这种厂商特定的扩展应该有以下格式之一：

```
'-' + 厂商标识符 + '-' + 有意义的名称
'_' + 厂商标识符 + '-' + 有意义的名称
```

例如，如果 XYZ 组织添加了一个属性来描述显示器东侧边框的颜色，他们可能称之为 -xyz-border-east-color。

其他已知的例子：

```css
-moz-box-sizing
-moz-border-radius
-wap-accesskey
```

首字母破折号或下划线被保证永远不会被任何当前或未来级别的 CSS 使用在属性或关键字中。因此，典型的 CSS 实现可能无法识别这样的属性，并可能根据处理解析错误的规则而忽略它们。然而，由于最初的破折号或下划线是语法的一部分，CSS 2.2 的实现者应该总是能够使用符合 CSS 标准的解析器，无论他们是否支持任何厂商的特定扩展。

作者应该避免厂商的特定扩展。

下表总结了常见的厂商前缀。

| 浏览器            | 前缀     |
| ----------------- | -------- |
| Chrome, Safari    | -webkit- |
| Opera             | -o-      |
| Firefox           | -moz-    |
| Internet Explorer | -ms-     |

### 2.1.3. 字符和大小写

以下规则始终有效。

所有的 CSS 语法在 ASCII 范围内是不区分大小写的（即[a-z]和[A-Z]是等同的），但不在 CSS 控制范围内的部分除外。例如，HTML 属性 "id "和 "class "的值、字体名称和 URI 的大小写敏感性不在本规范的范围之内。特别要注意的是，元素名称在 HTML 中是不区分大小写的，但在 XML 中是区分大小写的。

在 CSS 中，标识符（包括选择器中的元素名、类和 ID）只能包含字符[a-zA-Z0-9]和 ISO 10646 字符 U+0080 及以上，加上连字符（-）和下划线（\_）；它们不能以数字、两个连字符或连字符后的数字开头。标识符也可以包含转义字符和任何作为数字代码的 ISO 10646 字符（见下一项）。例如，标识符 "B&W？"可以写成 "B\&W\？"或 "B\26 W\3F"。
请注意，Unicode 的编码与 ISO10646 相当（见[UNICODE]和[ISO10646]）。

在 CSS 2.2 中，反斜杠（\）字符可以表示三种类型的字符转义之一。在一个 CSS 注释中，反斜杠代表它自己，如果反斜杠紧跟在样式表的末尾，它也代表它自己（即 DELIM 标记）。

首先，在一个字符串内，一个反斜杠后面的换行被忽略（即，字符串被认为不包含反斜杠或换行）。在字符串外部，反斜线后的换行代表其本身（即 DELIM 后的换行）。

第二，它取消了特殊 CSS 字符的意义。任何字符（除了十六进制数字、换行、回车或换页）都可以用反斜杠转义，以消除其特殊含义。例如，"\"是一个由一个双引号组成的字符串。样式表预处理器不能从样式表中删除这些反斜线，因为那会改变样式表的含义。

第三，反斜杠转义允许作者参考他们不容易放在文档中的字符。在这种情况下，反斜杠后面最多有六个十六进制数字（0...9A...F），这些数字代表 ISO 10646（[ISO10646]）字符，这个数字不能是零。(在 CSS 2.2 中没有定义如果一个样式表确实包含一个 Unicode 代码点为 0 的字符会发生什么。) 如果在十六进制数字后面有一个范围为[0-9a-fA-F]的字符，那么这个数字的结尾需要明确。有两种方法可以做到这一点。

用一个空格（或其他空白字符）。"\26 b"（"&b"）。在这种情况下，用户代理应将 "CR/LF "对（U+000D/U+000A）视为一个白色空格字符。

通过提供正好 6 个十六进制数字。"\000026b" ("&b")。

事实上，这两种方法可以结合使用。在十六进制转义之后，只有一个空白字符被忽略。请注意，这意味着转义序列后的 "真实 "空格必须是双倍的。

如果数字超出了 Unicode 允许的范围（例如"\110000 "高于当前 Unicode 允许的最大 10FFFF），UA 可以用 "替换字符"（U+FFFD）替换转义。如果要显示该字符，UA 应该显示一个可见的符号，比如 "缺失字符 "字形（参见 15.2，第 5 点）。

注意：反斜线转义总是被认为是标识符或字符串的一部分（即"\7B" 不是标点符号，尽管 "{" 是，而"\32" 允许放在类名的开头，尽管 "2" 不是）。

标识符 "te/st "与 "test "是完全相同的标识符。

## 2.2. 语句

一个 CSS 样式表，对于任何级别的 CSS 来说，都是由一个语句列表组成的（见上面的语法）。有两种声明：at-rules 和规则集。语句周围可能有空白。

## 2.3. at 规则

at 规则的开头是一个'@'字符，后面紧跟一个标识符（例如，'@import'，'@page'）。

一个 at 规则由包括下一个分号（;）或下一个块（以先到者为准）在内的所有内容组成。

CSS 2.2 的用户代理必须忽略任何出现在块内的'@import'规则，或者出现在任何非忽略的语句（除@charset 或@import 规则外）之后。

例如，假设一个 CSS 2.2 解析器遇到了这个样式表：

```css
@import 'subs.css';
h1 {
  color: blue;
}
@import 'list.css';
```

根据 CSS 2.2，第二个'@import'是非法的。CSS 2.2 解析器忽略了整个 at 规则，有效地将样式表简化为：

```css
@import 'subs.css';
h1 {
  color: blue;
}
```

在下面的例子中，第二个"@import" 规则是无效的，因为它发生在 "@media" 块内:

```css
@import 'subs.css';
@media print {
  @import 'print-main.css';
  body {
    font-size: 10pt;
  }
}
h1 {
  color: blue;
}
```

相反，为了达到只为 "print" 媒体导入样式表的效果，使用带有媒体语法的@import 规则，例如：

```css
@import 'subs.css';
@import 'print-main.css' print;
@media print {
  body {
    font-size: 10pt;
  }
}
h1 {
  color: blue;
}
```

### 2.3.1. 块

一个块以左大括号（{）开始，以匹配的右大括号（}）结束。中间可以有任何标记，但小括号（（））、大括号（[ ]）和大括号（{ }）必须总是成对出现，并且可以嵌套。单引号（'）和双引号（"）也必须出现在匹配对中，它们之间的字符被解析为一个字符串。关于字符串的定义，见上面的符号化。

下面是一个块的例子。请注意，双引号之间的右括号与块的开头括号不一致，第二个单引号是一个转义字符，因此与第一个单引号不一致:

```css
 {
  causta: '}' + ({7} * "'");
}
```

请注意，上述规则不是有效的 CSS 2.2，但它仍然是上述定义的一个块。

### 2.3.2. 规则集，声明块和选择器

一个规则集（也叫 "规则"）由一个选择器和一个声明块组成。

一个声明块以左大括号（{）开始，以匹配的右大括号（}）结束。在这中间必须有一个零或更多的声明和 at 规则的列表。声明必须以分号（;）结束，除非它们是列表中的最后一个。

注意：CSS level 2 没有可能出现在规则集内的 at 规则，但这种 at 规则可能会在未来的级别中被定义。

选择器（参见选择器一节）由第一个左大括号（{）以下的所有内容组成（但不包括）。一个选择器总是和一个声明块一起出现。当用户代理不能解析选择器时（即它不是有效的 CSS 2.2），它必须忽略选择器和后面的声明块（如果有的话）。

CSS 2.2 对选择器中的逗号（,）赋予了特殊的含义。然而，由于不知道逗号在未来的 CSS 更新中是否会获得其他含义，如果选择器中的任何地方有错误，整个声明都应该被忽略，即使选择器的其他部分在 CSS 2.2 中看起来是合理的。

例如，由于"&"在 CSS 2.2 的选择器中不是一个有效的标记，所以 CSS 2.2 的用户代理必须忽略整个第二行，并且不能将 h3 的颜色设置为红色：

```css
h1,
h2 {
  color: green;
}
h3,
h4 & h5 {
  color: red;
}
h6 {
  color: black;
}
```

下面是一个更复杂的例子。前两对大括号在一个字符串内，并没有标记选择器的结束。这是一个有效的 CSS 2.2 规则:

```css
p[example='public class foo\
{\
    private int x;\
\
    foo(int x) {\
        this.x = x;\
    }\
\
}'] {
  color: red;
}
```

### 2.3.3. 声明和属性

一个声明要么是空的，要么是由一个属性名称组成，后面是冒号（:），然后是一个属性值。在每个属性的周围可能有空白。

由于选择器的工作方式，同一选择器的多个声明可以被组织成分号（;）分隔的组。

因此，以下规则：

```css
h1 {
  font-weight: bold;
}
h1 {
  font-size: 12px;
}
h1 {
  line-height: 14px;
}
h1 {
  font-family: Helvetica;
}
h1 {
  font-variant: normal;
}
h1 {
  font-style: normal;
}
```

相当于：

```css
h1 {
  font-weight: bold;
  font-size: 12px;
  line-height: 14px;
  font-family: Helvetica;
  font-variant: normal;
  font-style: normal;
}
```

一个属性名称是一个标识符。任何标记都可以出现在属性值中。小括号（"()"）、中括号（"[ ]"）、大括号（"{ }"）、单引号（'）和双引号（"）必须成对出现，而且不在字符串中的分号必须被转义。括号、大括号和小括号可以嵌套。在引号内，字符被解析为一个字符串。

值的语法是为每个属性单独指定的，但在任何情况下，值都是由标识符、字符串、数字、长度、百分比、URI、颜色等构建的。

用户代理必须忽略具有无效的属性名称或无效的值的声明。每个 CSS 属性对它所接受的值都有自己的语法和语义限制。

例如，假设一个 CSS 2.2 解析器遇到了这个样式表：

```css
h1 {
  color: red;
  font-style: 12pt;
} /* 无效值: 12pt */
p {
  color: blue;
  font-vendor: any; /* 无效属性.: font-vendor */
  font-variant: small-caps;
}
em em {
  font-style: normal;
}
```

第一行的第二个声明有一个无效的值 "12pt"。第二行的第二个声明包含一个未定义的属性 "font-vendor"。CSS 2.2 解析器将忽略这些声明，有效地将样式表简化为：

```css
h1 {
  color: red;
}
p {
  color: blue;
  font-variant: small-caps;
}
em em {
  font-style: normal;
}
```

### 2.3.4. 注释

注释以字符 "/\*" 开始，以字符 "\*/" 结束。它们可以出现在其他标记之外的任何地方，其内容对渲染没有影响。注释不能被嵌套。

CSS 也允许在语法定义的某些地方使用 SGML 注释定界符（"<！--"和"-->"），但它们并不能给 CSS 注释定界。允许它们是为了使出现在 HTML 源文档中的样式规则（在 STYLE 元素中）可以从 HTML 3.2 之前的用户代理那里隐藏起来。

## 2.4. 值

### 2.4.1. 整数和实数

一些值类型可能有整数值（用`<integer>`表示）或实数值（用`<number>`表示）。实数和整数仅以十进制符号指定。一个<整数>由一个或多个数字 "0 "到 "9 "组成。一个<数字>可以是一个<整数>，也可以是 0 个或多个数字，后面跟着一个点（.），再加上一个或多个数字。整数和实数前面都可以紧跟一个"-"或 "+"来表示符号。-0 相当于 0，不是一个负数。

请注意，许多允许整数或实数作为数值的属性实际上将数值限制在某些范围内，通常是限制在一个非负值。

### 2.4.2. 长度

长度指的是距离测量。

长度值的格式（在本规范中用`<length>`表示）是一个`<number>`（带或不带小数点），后面紧跟一个单位标识符（例如，px，em 等）。在一个零长度之后，单位标识符是可选的。

有些属性允许负的长度值，但这可能会使格式化模型复杂化，而且可能有特定的实施限制。如果不能支持负的长度值，它应该被转换为可以支持的最近的值。

如果一个负的长度值被设置在一个不允许负长度值的属性上，那么这个声明就会被忽略。

在使用的长度不能被支持的情况下，用户代理必须在实际值中对其进行近似。

有两种类型的长度单位：相对和绝对。相对长度单位指定一个相对于另一个长度属性的长度。使用相对单位的样式表可以更容易地从一个输出环境扩展到另一个。

#### 2.4.2.1. 绝对单位

绝对长度单位是固定的，用其中任何一个单位表示的长度都会显示为该尺寸。

绝对长度单位不建议在屏幕上使用，因为屏幕尺寸变化太大。然而，如果输出媒介是已知的，例如印刷品的排版，则可以使用它们。

下表列出了常见的绝对单位：

| 单位 | 描述                          |
| ---- | ----------------------------- |
| cm   | 厘米                          |
| mm   | 毫米                          |
| in   | 英寸 (1 英寸 = 96px = 2.54cm) |
| px   | CSS 像素 (1px = 1/96 英寸)    |
| pt   | 点 (1pt = 1/72 英寸)          |
| pc   | 12 点活字 (1pc = 12 pt)       |

像素（px）是相对于观看设备而言的。对于低 DPI 设备，1px 是显示器的一个设备像素（点）。对于打印机和高分辨率的屏幕，1px 意味着多个设备像素，实际上这个数字大概等于 window.devicePixelRatio。

一条样式中可以混合使用多种单位，包括混合使用绝对单位和相对单位。如果能预先知道内容的呈现方式（例如为供打印的文档设计样式）， 那么绝对单位很有用处。我设计 CSS 样式不怎么使用绝对单位。个人认为相对单位更灵活、更容易管理， 而且我也很少创作需要与现实世界度量挂钩的内容。

#### 2.4.2.2. 相对单位

相对长度的规定和实现都比绝对长度更复杂，需要以严密、精确的语言明确定义。相对单位的测量需要依托其他类型的单位。可惜 CSS 规范的语言还没那么精确（这个问题巳经困扰 CSS 多年）。因此尽管 CSS 规定了许多既有趣又有用的相对单位，但是其中一些单位还没有得到浏览器广泛、一致的支持，用户还无法使用。下表出了主流浏览器支持的一些 CSS 相对单位。

| 单位 | 描述                                                |
| ---- | --------------------------------------------------- |
| em   | 相对于元素的字体大小（2em 表示当前字体大小的 2 倍） |
| ex   | 相对于字符“x”的高度                                 |
| ch   | 相对于数字“0”的宽度                                 |
| rem  | 相对于根元素的字体大小                              |
| lh   | 相对于元素的 line-height                            |
| vw   | 相对于视口宽度的 1%                                 |
| vh   | 相对于视口高度的 1%                                 |
| vmin | 相对于视口小尺寸的 1%                               |
| vmax | 相对于视口大尺寸的 1%                               |

下表中的数字指定了完全支持长度单位的第一个浏览器版本。

| 长度单位                       | Chrome | Edge | FireFox | Safari | Opera |
| ------------------------------ | ------ | ---- | ------- | ------ | ----- |
| em, ex, px, cm, mm, in, pt, pc | 1.0    | 3.0  | 1.0     | 1.0    | 3.5   |
| ch                             | 27.0   | 9.0  | 1.0     | 7.0    | 20.0  |
| rem                            | 4.0    | 9.0  | 3.6     | 4.1    | 11.6  |
| vh, vw                         | 20.0   | 9.0  | 19.0    | 6.0    | 20.0  |
| vmin                           | 20.0   | 12.0 | 19.0    | 6.0    | 20.0  |
| vmax                           | 26.0   | 16.0 | 19.0    | 7.0    | 20.0  |

下面我们具体看一下这些相对单位。

1. **em 与 rem**

em 单位的使用有两种情况：

- em 作为本元素的非 font-size 属性。此时，em 的大小就是本元素的字号大小。
- em 作为本元素的 font-size 属性。此时，em 的大小为父元素的字号大小。

来看下面几个例子。

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      body {
        font-size: 20px;
        height: fit-content;
        border: 1px black solid;
        margin: 1em;
      }
    </style>
    <title>Document</title>
  </head>
  <body>
    一段文本
  </body>
</html>
```

这个例子中，我们改写了 body 的 margin 属性，这个属性的用户代理样式为 8px，现在改写为 1em。显然 margin 不是 font-size，因此它的大小就是 body 字体的大小，因此，我们可以看到这里的 1em = 20 px。当我们修改了本元素的字体时，margin 也会跟着变化。

再来看一个例子：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      body {
        font-size: 20px;
        margin: 0px;
      }

      span {
        font-size: 1em;
      }
    </style>
    <title>Document</title>
  </head>
  <body>
    <span>一段文本</span>
  </body>
</html>
```

这个例子中，span 元素最近的父元素为 body，span 元素的 font-size 属性值为 1em，因此这个大小就是父元素字号的大小：20px。

rem 则和 em 不同，它只相对于 html 元素（根元素）的字号大小。

来看这个例子：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      html {
        font-size: 20px;
      }
      body {
        font-size: 16px;
        margin: 0px;
      }
      span {
        font-size: 1rem;
      }
    </style>
    <title>Document</title>
  </head>
  <body>
    <span>一段文本</span>
  </body>
</html>
```

在这个例子中，span 的 font-size 属性被设置为 1rem，而 html 元素的 font-size 被设置为 20px。因此，这里的 1rem = 20px。而不是 16px。

2. **vw 与 vh**

1vw 代表视口宽度的 1%。而 1vh 表示视口高度的 1%。

视口 (viewport) 代表当前可见的计算机图形区域。在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI， 菜单栏等——即指你正在浏览的文档的那一部分。

文档，比如这篇文章，可能会非常长。你的 viewport 就是你现在所能见到的所有事物。值得注意的是“什么是视口区域”这个问题，页面中的一些导航菜单也包括在其中。Viewport 的大小取决于屏幕的大小，无论浏览器是否处于全屏模式，是否被用户缩放了。Viewport 外的区域，比如这个文档的 See Also 部分，可能需要滚动到其所在的区域才会出现在屏幕上。

- 在尺寸较大的设备中，在这些设备上，应用显示区域不一定是全屏的，viewport 是浏览器窗口的大小。
- 在大多数移动设备中，浏览器是全屏的，viewport 是整个屏幕的大小。
- 在全屏模式下，viewport 是设备屏幕的范围，窗口是浏览器窗口，浏览器窗口大小小于或等于视口的大小，并且文档是这个网站，文档的大小可比 viewport 长或宽。

概括地说，viewport 基本上是当前文档的可见部分。

在实测中，innerWidth 和 outerWidth 是相同的，但是 outerHeight 比 innerHeight 高 100px。这是因为 outerHeight 的测量包括浏览器框架在内，包括了地址栏和书签栏总共 100px 的高度，而浏览器没有左右边框。

innerHeight 和 innerWidth 所组成的区域通常被认为是布局视口 (layout viewport)。浏览器的框架不被认为是 viewport 的一部分。

Web 浏览器包含两个 viewport，**布局视口(layout viewport)** 和 **视觉视口(visual viewport)**。visual viewport 指当前浏览器中可见的部分，并且可以变化。当使用触屏双指缩放，当动态键盘在手机上弹出的时候，或者之前隐藏的地址栏变得可见的时候，visual viewport 缩小了，但是 layout viewport 却保持不变。

我们上面说到的固定的头部和尾部，固定在 layout viewport 的底部和顶部，所以当 visual viewport 缩小的时候,头部和尾部仍保留在视觉中。当你缩放页面时，布局视口可能不能被全部看到。如果你放大布局视口的中间部分，内容将在四个方向上扩展。如果你有一个固定的头部和底部，它们依然固定在布局视口的顶部和底部，因此它们可能会在设备屏幕的底部和顶部不可见-视觉视口。视觉视口是布局视口当前的可见部分如果你向下滚动，视觉视口的内容就会改变，并布局视口的底部就会滚动到可视区域。

视觉视口是屏幕的可视部分，不包括屏幕键盘，缩放外的区域。视觉视口比布局视口相同或者更小

对于一个包含框架，objects 或外部 svg 的页面，两者都有它们自己的 window 对象，只有最外层的 window 的视觉视口不同于布局视口。对于包含的文档，视觉视口与布局视口是相同的。

来看一个例子：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      body {
        width: 100vw;
        height: 100vh;
        margin: 0px;
        background-color: #eeffee;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20em;
        color: #ffeef8;
      }
    </style>
    <title>Document</title>
  </head>
  <body>
    <span>居中文字</span>
  </body>
</html>
```

这个例子中，我们将 body 的 width 设置为 100vw，高度设置为 100vh，margin 为 0px。这样 body 就占满了整个可见视口。接着我们将 body 设置为 flexbox，并居中字体。

vmin 和 vmax 和我们讲的上述单位很相似。但是也考虑到了屏幕旋转的影响。vmin 指的是可见视口中长度和宽度中较小的一个，vmax 则是较大的一个。

3. **cal()**

允许将 CSS 属性值设置为算式是 CSS3 定义的一个引人关注的特性。这种灵活手段在控制能力和精确程度方面都给样式设计工作提供了帮助。calc() 此 CSS 函数允许在声明 CSS 属性值时执行一些计算。它可以用在如下场合：`<length>`、`<frequency>`, `<angle>`、`<time>`、`<percentage>`、`<number>`、或 `<integer>`。

来看这个例子。

```css
/* property: calc(expression) */
width: calc(100% - 80px);
```

此 calc()函数用一个表达式作为它的参数，用这个表达式的结果作为值。这个表达式可以是任何如下操作符的组合，采用标准操作符处理法则的简单表达式。

+: 加法。
-: 减法。
\*: 乘法，乘数中至少有一个是 `<number>`。
/: 除法，除数（/ 右面的数）必须是 `<number>`。

表达式中的运算对象可以使用任意 `<length>` 值。如果你愿意，你可以在一个表达式中混用这类值的不同单位。在需要时，你还可以使用小括号来建立计算顺序。

### 2.4.3. 百分数

百分数的格式（在本规范中用`<percentage>`表示）是一个`<number>`，后面紧跟着'%'。

百分数总是相对于另一个值，例如长度。每个允许百分比的属性也定义了百分比所指向的值。这个值可能是同一元素的另一个属性，一个祖先元素的属性，或者是格式化上下文的一个值（例如，一个包含块的宽度）。当为根元素的一个属性设置百分数，并且百分比被定义为指某些属性的继承值时，结果值是百分比乘以该属性的初始值。

由于子元素（通常）继承其父元素的计算值，在下面的例子中，P 元素的子元素将继承 "line-height" 的值 12px，而不是百分数（120%）：

```css
p {
  font-size: 10px;
}
p {
  line-height: 120%;
} /* 'font-size' 的 120% */
```

### 2.4.4. URL

本规范中的 URI 值（统一资源标识符，见[RFC3986]，其中包括 URL、URN 等）用`<uri>`表示。在属性值中用于指定 URI 的功能符号是 "url()"，如：。

```css
body {
  background: url('http://www.example.com/pinkish.png');
}
```

URI 值的格式是 "url('后面是可选的空白，后面是可选的单引号（'）或双引号（"）字符，后面是 URI 本身，后面是可选的单引号（'）或双引号（"）字符，后面是可选的空白，后面是'）'。这两个引号字符必须是相同的。

一个没有引号的例子：

```css
li {
  list-style: url(http://www.example.com/redball.png) screen;
}
```

在未加引号的 URI 中出现的一些字符，如括号、空白字符、单引号（'）和双引号（"），必须用反斜杠转义，这样得到的 URI 值就是一个 URI 标记：'\(', '\)'。

根据 URI 的类型，也可以将上述字符写成 URI 转义（其中"（"=%28，"）"=%29，等等），如[RFC3986]中所述。

注意，COMMENT 标记不能出现在其他标记中：因此，"url(/_x_/pic.png) "表示 URI"/_x_/pic.png"，而不是 "pic.png"。

为了创建不依赖资源的绝对位置的模块化样式表，作者可以使用相对 URI。相对 URI（如[RFC3986]中的定义）使用一个基础 URI 被解析为完整 URI。RFC 3986 第 5 节定义了这个过程的规范性算法。对于 CSS 样式表，基 URI 是样式表的 URI，而不是源文档的 URI。

例如，假设有以下规则。

```css
body {
  background: url('yellow');
}
```

位于一个由 URI 指定的样式表中:http://www.example.org/style/basic.css。

源文档的 BODY 的背景将用 URI 指定的资源所描述的任何图像来拼接：http://www.example.org/style/yellow。

用户代理在处理无效的 URI 或指定不可用或不适用的资源的 URI 方面可能有所不同。

### 2.4.5. 颜色

颜色在网页中的作用非常重要。在 CSS 中设置颜色有好几种方法。最简单的办法是使用规定的颜色名称，或者设置红、绿、蓝三种颜色成分的值（十进制或十六进制）。设置颜色成分值时，十进制值以逗号分隔，十六进制值前面通常要加上一个`#`号（例如`#ffffff`，它代表白色）。你可以查看[MDN 参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value)查看各种颜色代码。

**更复杂的颜色**

颜色名称和简单的十六进制数不是表示颜色的唯一方式。CSS 中还可以用一些函数选择颜色。下表逐一介绍了这些函数。

| 函数             | 说明示例                                                                              |
| ---------------- | ------------------------------------------------------------------------------------- | -------------------------------- |
| rgb(r, g, b)     | 用 RGB 模型表示颜色 color: rgb(112, 128,144)                                          |
| rgba(r, g, b, a) | 用 RGB 模型表示颜色，外加一个用于表示透明度的 a 值（0 代表全透明， 1 代表完全不透明） | color: rgba(112, 128, 144, 0.4)  |
| hsl(h, s, l)     | 用 HSL 模型（色相(hue)、饱和度(saturation)和明度(Lightness)）表示颜色                 | color: hsl(120, 100%, 22%)       |
| hsla(h, s, l, a) | 与 HSL 模式类似， 只不过增加了一个表示透明度的 a 值                                   | color: hsla(120, 100%, 22%, 0.4) |

### 2.4.6. 字符串

字符串可以用双引号或单引号书写。双引号不能出现在双引号内，除非转义（例如，"\"或"\22"）。同样，单引号（例如，"\'"或"\27"）也是如此。

"this is a 'string'"
"this is a \"string\""
'this is a "string"' （这是一个字符串
'this is a \'string\'' 这是一个字符串。

一个字符串不能直接包含一个换行。要在一个字符串中包含换行，请使用代表 ISO-10646 中的换行字符（U+000A）的转义，例如"\A "或"\00000a"。这个字符代表了 CSS 中 "换行 "的一般概念。参见 "content "属性的例子。

出于审美或其他原因，可以将字符串分成几行，但在这种情况下，换行本身必须用反斜线（\）来转义。例如，以下两个选择器是完全一样的。

```css
a[title='a 是一个\
o 非常长的标题'] {
  /*...*/
}
a[title='一个不太长的标题'] {
  /*...*/
}
```

### 2.4.7. 角度

角度这种单位在旋转变换时可以用到。角度的表示方式是一个数字后跟一个单位，如 360deg。数字可以是负数，负数表示逆时针，而正数表示顺时针。

| 单位 | 说明                                                                                               |
| ---- | -------------------------------------------------------------------------------------------------- |
| deg  | 度。一个完整的圆是 360deg。例：0deg，90deg，14.23deg。                                             |
| grad | 百分度。一个完整的圆是 400grad。例：0grad，100grad，38.8grad。                                     |
| rad  | 弧度。一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180/π 度。例：0rad，1.0708rad，6.2832rad。 |
| turn | 圈数。一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn。                                         |

### 2.4.8. 时间

时间的单位可以在过渡中使用。时间单位包含秒（s）和毫秒（ms）。1 秒等于 1000 毫秒。

# 3. 选择器

在前面我们知道了，一个 CSS 规则中，选择器指定了应用样式的目标元素。本章我们来详细介绍选择器。

## 3.1. 基本选择器

有些选择器使用起来非常简单，我们把这部分选择器称为 **基本选择器(basic selector)**。开发人员可使用这类选择器在文档中进行比较宽泛的选择，也可以将其看做结合多种选择器进行特殊选择的基础（本章后面会介绍复合选择器）。接下来每节介绍一种基本选择器的用法。

### 3.1.1. 通用选择器

通用选择器（\*）匹配文档中的所有元素。它是最基本的选择器，不过使用很少，因为匹配过于广泛。一般不推荐使用这个选择器，它性能很低。

### 3.1.2. 元素选择器

CSS 元素选择器(也称为类型选择器)通过 node 节点名称匹配元素. 因此,在单独使用时,寻找特定类型的元素时,元素选择器都会匹配该文档中所有此类型的元素。

下面的例子展示了元素选择器的用法。

```css
body {
  margin: 0px;
  display: flex;
  flex-direction: column;
  flex-wrap: wrap;
}
```

### 3.1.3. 类选择器

在一个 HTML 文档中，CSS 类选择器会根据元素的类属性中的内容匹配元素。类属性被定义为一个以空格分隔的列表项，在这组类名中，必须有一项与类选择器中的类名完全匹配，此条样式声明才会生效。

类选择器有 3 种基本用法：

1. **.className**

这种用法选择所有具有 className 的元素。

2. **tagName.className**

这种用法选择所有 tagName 类型的元素中含有 className 的元素。

3. **.className1.className2**

这种用法选择所有同时具有 className1 和 className2 的元素。

当然你也可以组合产生更多用法。

下面展示了了一些用例。

```css
p.center.bold {
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}
```

### 3.1.4. id 选择器

在一个 HTML 文档中，CSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素，元素 ID 属性名必须与选择器中的 ID 属性名完全匹配，此条样式声明才会生效。

id 选择器既可以单独使用也可以紧跟在一个元素选择器后面：

```css
#nav-bar {
  display: flex;
}
```

```css
div#nav-bar {
  display: flex;
}
```

### 3.1.5. 属性选择器

CSS 属性选择器通过已经存在的属性名或属性值匹配元素。

1. **[attr]**

选取有 attr 属性的元素。

```css
input[required] {
  /* 选择input中带有 required 的元素。 */
}
```

2. **[attr=value]**

选取属性为特定值的元素

```css
a[target='_blank'] {
  /* 选取 target 属性为 "_blank" 的 a 元素 */
  background-color: yellow;
}
```

3. **[attr~=value]**

[attr~=value] 选择器选取属性值包含指定词的元素。

```css
[title~='flower'] {
  border: 5px solid yellow;
}
```

上面的例子会匹配以下属性的元素：title="flower"、title="summer flower" 以及 title="flower new"，但不匹配：title="my-flower" 或 title="flowers"。

4. **[attr|=value]**

[attr|=value] 选择器用于选取指定属性以指定值开头的元素。

```css
[class|='top'] {
  background: yellow;
}
```

上例选取 class 属性以 "top" 开头的所有元素，而且值必须是完整或单独的单词，比如 class="top" 或者后跟连字符的，比如 class="top-text"。

5. **[attr^=value]**

[attr^=value] 选择器用于选取指定属性以指定值开头的元素。

```css
[class^='top'] {
  background: yellow;
}
```

上例选取 class 属性以 "top" 开头的所有元素，但值不必是完整单词！

6. **[attr$=value]**

[attre$=value] 选择器用于选取指定属性以指定值结尾的元素。

```css
[class$='wrapper'] {
  background-color: yellow;
}
```

上例选取 class 属性以 "test" 结尾的所有元素，但值不必是完整单词。

7. **[attr*=value]**

[attr*=value] 选择器选取属性值包含指定词的元素。

```css
[class*='te'] {
  background: yellow;
}
```

上例选取 class 属性包含 "te" 的所有元素，但值不必是完整单词！

## 3.2. 组合选择器

组合使用不同的选择器可以匹配更特定的元素。有的组合选择器能将目标样式应用到更多元素，有的组合选择器则会锁定更少元素，总之会让你的选择非常具体。在接下来的几节中，我会为你展示组合使用选择器的各种方法。

### 3.2.1. 后代选择器

后代组合器（通常用单个空格（ ）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称为后代选择器。

从技术上讲，后代组合器是两个选择器之间的一个或多个 CSS 空格字符-空格字符和/或四个控制字符之一：回车，换页，换行和制表符在没有其他组合器的情况下。此外，组成组合器的空白字符可以包含任意数量的 CSS 注释。

```css
h1 em {
  color: red;
}
```

这个例子中，选择了 h1 元素中的所有 em 元素。

### 3.2.2. 直接后代选择器

如果您不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的子元素，请使用子元素选择器（Child selector）。例如，如果您希望选择只作为 h1 元素子元素的 strong 元素，可以这样写：

```css
h1 > strong {
  color: red;
}
```

这个规则会把第一个 h1 下面的两个 strong 元素变为红色，但是第二个 h1 中的 strong 不受影响：

```html
<h1>
  This is
  <strong>very</strong>
  <strong>very</strong>
  important.
</h1>
<h1>
  This is
  <em>
    really
    <strong>very</strong>
  </em>
  important.
</h1>
```

### 3.2.3. 兄弟选择器

兄弟选择符，位置无须紧邻，只须同层级，A~B 选择 A 元素之后所有同层级 B 元素。

```css
p ~ span {
  color: red;
}
```

```html
<span>This is not red.</span>
<p>Here is a paragraph.</p>
<code>Here is some code.</code>
<span>And here is a span.</span>
```

这样，只有最后一个 span 元素会被选中。

### 3.2.4. 相邻兄弟选择器

相邻兄弟选择器 (+) 介于两个选择器之间，当第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父元素的子元素，则第二个元素将被选中。

```css
li + li {
  font-weight: bold;
}
```

```html
<div>
  <ul>
    <li>List item 1</li>
    <li>List item 2</li>
    <li>List item 3</li>
  </ul>
  <ol>
    <li>List item 1</li>
    <li>List item 2</li>
    <li>List item 3</li>
  </ol>
</div>
```

上面这个选择器只会把列表中的第二个和第三个列表项变为粗体。第一个列表项不受影响。

## 3.3. 伪元素选择器

目前为止， 我们已经学习了如何使用 HTML 文档中定义的元素选择文档内容。CSS 中还定义了伪选择器(pseudo-selector)， 它们提供了更复杂的功能，但并非直接对应 HTML 文档定义的元素。伪选择器分两种：伪元素和伪类。本节将介绍和演示伪元素选择器。顾名思义，伪元素实际上并不存在，它们是 CSS 提供的额外“福利”，为了方便你选中文档内容。

### 3.3.1. ::after

CSS 伪元素::after 用来创建一个伪元素，作为已选中元素的最后一个子元素。通常会配合 content 属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。

```css
/* Add an arrow after links */
a::after {
  content: '<-';
}
```

### 3.3.2. ::before

CSS 伪元素::before 用来创建一个伪元素，作为已选中元素的第一个一个子元素。通常会配合 content 属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。

```css
/* Add an arrow before links */
a::after {
  content: '->';
}
```

### 3.3.3. ::first-line

::first-line 选择器匹配文本块的首行。

```css
::first-line {
  background-color: grey;
  color: white;
}
```

### 3.3.4. ::first-letter

CSS 伪元素 ::first-letter 会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。

```css
p::first-letter {
  font-weight: bold;
  color: red;
}
```

### 3.3.5. ::selection

::selection CSS 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。

```css
::selection {
  background-color: cyan;
}
```

只有一小部分 CSS 属性可以用于::selection 选择器：

color
background-color
cursor
caret-color
outline and its longhands
text-decoration and its associated properties
text-emphasis-color (en-US)
text-shadow

## 3.4. 伪类选择器

伪类跟伪元素一样，并不是直接针对文档元素的，而是为你基于某些共同特征选择元素提供方便。

### 3.4.1. 结构性伪类选择器

使用结构性伪类选择器能够根据元素在文档中的位置选择元素。这类选择器都有一个冒号字符前缀（:）， 例如： empty。它们可以单独使用，也可以跟其他选择器组合使用，如 p:empty。

- **:root**

:root 选择器匹配文档中的根元素。它可能是用得最少的一个伪类选择器，因为总是返回 html 元素。

```css
:root {
  background: yellow;
}
```

- **子元素伪类**

使用子元素伪类匹配直接包含在其他元素中的单个元素。

1. **:first-child**

:first-child 伪类表示在一组兄弟元素中的第一个元素。

```html
<div>
  <p>This text is selected!</p>
  <p>This text isn't selected.</p>
</div>

<div>
  <h2>This text isn't selected: it's not a `p`.</h2>
  <p>This text isn't selected.</p>
</div>
```

```css
p:first-child {
  color: lime;
  background-color: black;
  padding: 5px;
}
```

这个例子中，只会选择第一个 p 元素。

2. **:last-child**

:lst-child 伪类表示在一组兄弟元素中的最后一个元素。

```html
<ul>
  <li>此元素背景色不是lime</li>
  <li>我的也不是lime。</li>
  <li>我的才是lime！ :)</li>
</ul>
```

```css
li:last-child {
  background-color: lime;
}
```

在这个例子中，只有最后一个 li 元素被选择。

4. **:nth-child(n)**

:nth-child(n) 伪类选择器选择一组兄弟元素中顺序地第 n 个。

```html
<ul>
  <li>此元素背景色不是lime</li>
  <li>我的也不是lime。</li>
  <li>我的才是lime！ :)</li>
</ul>
```

```css
li:nth-child(2) {
  background-color: blue;
}
```

这个例子中，只有第 2 个 li 元素会被选中。

5. **:nth-last-child(n)**

这个伪类选择器和 :nth-child(n) 非常类似，只不过这个选择器的顺序是逆序。

```html
<ul>
  <li>此元素背景色不是lime</li>
  <li>我的也不是lime。</li>
  <li>我的才是lime！ :)</li>
</ul>
```

```css
li:nth-last-child(1) {
  background-color: blue;
}
```

这个例子中，最后一个 li 元素被选中。

6. **:only-child**

:only-child 匹配没有任何兄弟元素的元素。

```html
<ol>
  <li>
    First
    <ul>
      <li>This list has just one element.</li>
    </ul>
  </li>
  <li>
    Second
    <ul>
      <li>This list has three elements.</li>
      <li>This list has three elements.</li>
      <li>This list has three elements.</li>
    </ul>
  </li>
</ol>
```

```css
li li {
  list-style-type: disc;
}
li:only-child {
  color: red;
  list-style-type: square;
}
```

这个例子中 "This list has just one element." 内容的 li 元素会被选中。

7. **:only-of-type**

:only-of-type 代表了任意一个元素，这个元素没有其他相同类型的兄弟元素。

<main>
  <div>I am `div` #1.</div>
  <p>I am the only `p` among my siblings.</p>
  <div>I am `div` #2.</div>
  <div>I am `div` #3.
    <i>I am the only `i` child.</i>
    <em>I am `em` #1.</em>
    <em>I am `em` #2.</em>
  </div>
</main>

```css
main :only-of-type {
  color: red;
}
```

上面的例子中只会选中 p 元素。

6. **:nth-of-type(n)**

:nth-of-type() 这个 CSS 伪类是针对具有一组兄弟节点的标签, 用 n 来筛选出在一组兄弟节点的位置。

```html
<div>
  <div>这段不参与计数。</div>
  <p>这是第一段。</p>
  <p>这是第二段。</p>
  <div>这段不参与计数。</div>
  <p>这是第三段。</p>
  <p>这是第四段。</p>
</div>
```

```css
/* 奇数段 */
p:nth-of-type(2n + 1) {
  color: red;
}

/* 偶数段 */
p:nth-of-type(2n) {
  color: blue;
}

/* 第一段 */
p:nth-of-type(1) {
  font-weight: bold;
}
```

7. **:nth-last-of-type(n)**

:nth-last-of-type(n) 和 :nth-of-type(n) 类型，不过顺序相反。

### 3.4.2. UI 伪类选择器

1. **:enabled 和 :disabled**

有些元素有启用或者禁用状态，这些元素一般是用来收集用户输入的。:enabled 和 :disabled 选择器不会匹配没有禁用状态的元素。

2. **:checked**

使用:checked 选择器可以选中由 checked 属性或者用户勾选的单选按钮或者复选框。

3. **:valid 和 :invalid**

:valid 和:invalid 选择器分别匹配符合和不符合它们的输入验证要求的 input 元素。

4. **:required 和 :optional**

:required 选择器匹配具有 required 属性的 input 元素，这能够确保用户必需输入与 input 元素相关的值才能提交表单。:optional 选择器匹配没有 required 属性的 input 元素。

5. **:in-range 和 :out-of-range**

关于输入验证的一种具体程度更高的变体是选择值限于指定范围的 input 元素。:in-range 选择器匹配位于指定范围内的 input 元素，:out-of-range 选择器匹配位千指定范围之外的 input 元素。

### 3.4.3. 动态伪类选择器

之所以称为动态伪类选择器，是因为它们根据条件的改变匹配元素，是相对于文档的固定状态来说的。随着 JavaScript 广泛用于修改文档内容和元素状态，动态选择器和静态选择器之间的界限线越来越模糊，不过，动态伪类选择器仍然是一类比较特别的选择器。

1. **:link**

:link 选择器匹配超级链接。

2. **:visited**

:visited 选择器匹配用户已访问的超级链接。

3. **:hover**

:hover 选择器匹配用户鼠标悬停在其上的任意元素。鼠标在 HTML 页面内移动时，选中的元素样式会发生改变。

4. **:active**

:active 选择器匹配当前被用户激活的元素。浏览器依然可以自行决定如何诠释激活，但多数浏览器会在鼠标点击（在触摸屏上是手指按压）的情况下使用这个选择器。

5. **:focus**

最后一个动态伪类选择器是 :focus 选择器，它匹配当前获得焦点的元素。

### 3.4.4. 其他伪类选择器

1. **:not()**

CSS 伪类 :not() 用来匹配不符合一组选择器的元素。由于它的作用是防止特定的元素被选中，它也被称为反选伪类。

```css
/* 选择所有不是段落（p）的元素 */
:not(p) {
  color: blue;
}
```

2. **:empty**

:empty 选择器匹配没有定义任何子元素的元素。

3. **:lang()**

:lang 选择器匹配基于 lang 全局属性值的元素。如：:lang(zh-CN)。

3. **:target**

:target CSS 伪类代表一个唯一的页面元素(目标元素)，其 id 与当前 URL 片段匹配。

```css
/* 选择一个ID与当前URL片段匹配的元素*/
:target {
  border: 2px solid black;
}
```

## 3.5. 并集选择器

创建由逗号分隔的多个选择器可以将样式应用到单个选择器匹配的所有元素。

如：

```css
h1,
h2,
h3 {
}
```

# 4. 属性值，层叠和继承

## 4.1. 指定值，计算值和实际值

一旦用户代理解析了一个文档并构建了一个文档树，它必须为该树中的每个元素，为适用于目标媒体类型的每个属性分配一个值。

一个属性的最终值是四步计算的结果：该值通过规范确定（"指定值"），然后解析为一个用于继承的值（"计算值"），然后在必要时转换为一个绝对值（"使用值"），最后根据本地环境的限制进行转换（"实际值"）。

### 4.1.1. 指定值

用户代理必须首先根据以下机制（按优先顺序）为每个属性分配一个指定值。

1. 如果层叠的结果是一个值，就使用它。除非，如果该值是 "inherit"，指定值在下个章节 inherit 值中定义。
2. 否则，如果该属性是继承的，并且该元素不是文档树的根，使用父元素的计算值。
3. 否则就使用该属性的初始值。每个属性的初始值都在属性的定义中指出。

### 4.1.2. 计算值

在层叠过程中，指定值被解析为计算值；例如，URI 被转换为绝对 URI，'em'和'ex' 单位被计算为像素或绝对长度。计算一个值从来不需要用户代理渲染文档。

用户代理不能解析为绝对 URI 的 URI 计算值是指定值。

一个属性的计算值是由该属性定义中的计算值一行指定的。关于指定值为 "inherit" 时的计算值的定义，请参见继承部分。

即使属性不适用，计算值也存在。然而，一些属性可能定义一个元素的属性的计算值取决于该属性是否适用于该元素。

### 4.1.3. 使用值

计算值尽可能在不对文档进行格式化的情况下进行处理。然而，有些值只能在文档被排版时才能确定。例如，如果一个元素的宽度被设定为其包含块的某个百分比，那么在确定包含区块的宽度之前，宽度是无法确定的。使用值是将计算值和解决任何剩余的依赖关系的结果，变成一个绝对值。

### 4.1.4. 实际值

一个使用值原则上是用于渲染的值，但用户代理可能无法在给定的环境中利用这个值。例如，用户代理可能只能渲染整数像素宽度的边框，因此可能不得不近似计算出的宽度，或者用户代理可能被迫只使用黑白色调而不是全色。实际值是应用任何近似值后的使用值。

## 4.2. 继承

如上所述，有些值是由文档树中的元素的子元素继承的。每个属性都定义了它是否被继承。

假设有一个 h1 元素，里面有一个强调元素（em）。

```html
<h1>
  标题
  <em>是</em>
  重要的！
</h1>
。
```

如果没有给 em 元素分配颜色，em 元素将继承父元素的颜色，所以如果 h1 的颜色是蓝色，em 元素也将同样是蓝色。

当继承发生时，元素会继承计算值。父元素的计算值成为子元素上的指定值和计算值。

例如，给定下面的样式表。

```css
body {
  font-size: 10pt;
}

h1 {
  font-size: 130%;
}
```

和这个文档片段。

```html
<body>
  <body>
    <h1>
      一个
      <em>大的</em>
      标题
    </h1>
    。
  </body>
</body>
```

h1 元素的'font-size'属性将有一个计算值'13pt'（130%乘以 10pt，父元素的值）。由于'font-size'的计算值是继承的，em 元素也会有'13pt'的计算值。如果用户代理没有可用的 13pt 字体，h1 和 em 的'font-size'的实际值可能是，例如，'12pt'。

请注意，继承遵循文档树，不被匿名盒所截获。

### 4.2.1. inherit 值

每个属性也可以有一个 "inherit" 的层叠值，这意味着，对于一个给定的元素，该属性将该元素的父级计算值作为指定值。inherit 值可以用来强制继承值，它也可以用于通常不被继承的属性。

如果在根元素上设置了 "inherit" 值，该属性就会被分配其初始值。

在下面的例子中，"color" 和 "background" 属性被设置在 body 元素上。在所有其他元素上，"color" 值将被继承，背景将是透明的。如果这些规则是用户样式表的一部分，白色背景上的黑色文本将在整个文档中被强制执行。

```css
body {
  color: black !important;
  background: white !important;
}

* {
  color: inherit !important;
  background: transparent !important;
}
```

## 4.3. @import 规则

@import 规则允许用户从其他样式表中导入样式规则。在 CSS 2.2 中，任何@import 规则必须在所有其他规则之前（除了@charset 规则，如果存在的话）。'@import' 关键字后面必须有要包括的样式表的 URI。一个字符串也是允许的；它将被解释为如果它周围有 url(..)。

下面几行的意思是相同的，并说明了两种"@import" 语法（一种是 "url()"，另一种是裸字符串）。

```css
@import 'mystyle.css';
@import url('mystyle.css');
```

为了使用户代理能够避免检索不支持的媒体类型的资源，作者可以指定与媒体相关的@import 规则。这些有条件的导入在 URI 后面指定逗号分隔的媒体类型。

下面的规则说明了如何使@import 规则与媒体相关。

```css
@import url('fineprint.css') print;
@import url('bluish.css') projection, tv;
```

在没有任何媒体类型的情况下，导入是无条件的。为媒介指定 "all" 也有同样的效果。只有当目标媒体与媒体列表匹配时，导入才会生效。

如果媒体列表中的一个项目是目标媒体或 "all"，则目标媒体与媒体列表匹配。

当同一个样式表在多个地方被导入或链接到一个文档时，用户代理必须处理（或像处理一样）每个链接，就像链接到一个单独的样式表一样。

## 4.4. 层叠

样式表可能有三个不同的来源：作者、用户和用户代理。

- **作者**。作者根据文档语言的惯例为一个源文档指定样式表。例如，在 HTML 中，样式表可能被包含在文档中或从外部链接。
- **用户**：用户可能能够为一个特定的文档指定样式信息。例如，用户可以指定一个包含样式表的文件，或者用户代理可以提供一个生成用户样式表的界面（或者表现得像它一样）。
- **用户代理**。符合要求的用户代理必须应用一个默认的样式表（或者表现得像他们一样）。一个用户代理的默认样式表应该以满足文档语言的一般表现期望的方式来表现文档语言的元素（例如，对于视觉浏览器，HTML 中的 em 元素用斜体字来表现）。

注意，用户可以修改影响默认样式表的系统设置（例如，系统颜色）。然而，一些用户代理的实现使其无法改变默认样式表的值。

来自这三个源头的样式表在范围上会重叠，它们根据层叠进行交互。

CSS 层叠给每个样式规则分配了一个权重。当有几个规则适用时，具有最大权重的规则优先。

默认情况下，作者样式表中的规则比用户样式表中的规则具有更大的权重。然而，对于"!important"的规则，优先权是相反的。所有的用户和作者规则都比用户代理的默认样式表中的规则有更大的权重。

### 4.4.1. 层叠顺序

为了找到一个元素/属性组合，用户代理必须应用以下排列顺序：

1. 找到所有适用于有关元素和属性的声明，用于目标媒体类型。如果相关的选择器与查询元素相匹配，并且目标媒体与包含声明的所有@media 规则上的媒体列表以及到达样式表的路径上的所有链接相匹配，则声明适用。
2. 根据重要性（正常或重要）和来源（作者、用户或用户代理）排序。以升序的方式排列：
   1. 用户代理声明
   2. 用户正常声明
   3. 作者正常声明
   4. 作者重要声明
   5. 用户重要声明
3. 根据选择器的特指度对具有相同重要性和来源的规则进行排序：更具体的选择器将覆盖更一般的选择器。伪元素和伪类分别被算作正常元素和类。
4. 最后，按指定的顺序排列：如果两个声明具有相同的权重、来源和特指度，则指定的后者获胜。在导入的样式表中的声明被认为是在样式表本身的任何声明之前。

除了个别声明的"!important"设置外，这个策略给予作者的样式表比读者的样式表更高的权重。用户代理必须让用户有能力关闭特定作者样式表的影响，例如通过一个下拉菜单。

### 4.4.2. !important 规则

CSS 试图在作者和用户的样式表之间建立一种权力平衡。默认情况下，作者的样式表中的规则优先于用户的样式表中的规则。

然而，为了平衡，一个"!important"的声明（分隔符"!"和关键字 "important"跟在声明后面）优先于一个普通的声明。作者和用户的样式表都可以包含"!important"声明，而用户的"!important"规则优先于作者的"!important"规则。这个 CSS 特性通过给有特殊要求的用户（大字体、颜色组合等）对表现形式的控制来提高文档的可访问性。

将一个简写属性（例如，"background"）声明为"!important"，相当于将其所有的子属性声明为"!important"。

在下面的例子中，用户的样式表中的第一条规则包含一个"!important"的声明，它覆盖了作者样式表中的相应声明。第二个声明也会因为被标记为"!important"而获胜。然而，用户样式表中的第三条规则不是"!important"的，因此将输给作者样式表中的第二条规则（它恰好在一个简写属性上设置样式）。另外，第三个作者规则将输给第二个作者规则，因为第二个规则是"!important"的。这表明"!important"声明在作者样式表中也有作用。

```css
/* 来自用户的样式表 */
p {
  text-indent: 1em !important;
}
p {
  font-style: italic !important;
}
p {
  font-size: 18pt;
}

/* 来自作者的样式表 */
p {
  text-indent: 1.5em !important;
}
p {
  font: normal 12pt sans-serif !important;
}
p {
  font-size: 24pt;
}
```

### 4.4.3. 特指度

一个选择器的特指度的计算方法如下：

- 如果声明来自一个 "style" 属性而不是一个带有选择器的规则，则计数为 1，否则为 0（=a）（在 HTML 中，一个元素的 "style" 属性的值是样式表规则。这些规则没有选择器，所以 a=1，b=0，c=0，d=0）。
- 计算选择器中 ID 属性的数量(=b)
- 计算选择器中其他属性和伪类的数量(= c)
- 计算选择器中的元素名称和伪元素的数量(= d)

特指度只基于选择器的形式。特别是，形式为"[id=p33]"的选择器被算作一个属性选择器（a=0, b=0, c=1, d=0），即使 id 属性在源文档的 DTD 中被定义为 "ID"。

将 a-b-c-d 这四个数字串联起来就得到了特指度。

一些例子：

```css
 * {}  /* a=0 b=0 c=0 d=0 -> 特指度=0,0,0,0 */
 li {}  /* a=0 b=0 c=0 d=1 --> 特指度=0,0,0,1 */
 li::first-line {} /* a=0 b=0 c=0 d=2 -> 特指度=0,0,0,2 */
 ul li {}  /* a=0 b=0 c=0 d=2 --> 特指度 = 0,0,0,2 */
 ul ol+li {}  /* a=0 b=0 c=0 d=3 --> 特指度=0,0,0,3 */
 h1 + *[rel=up]{} /* a=0 b=0 c=1 d=1 --> 特指度=0,0,1,1 */
 ul ol li.red {}  /* a=0 b=0 c=1 d=3 --> 特指度 = 0,0,1,3 */
 li.red.level {}  /* a=0 b=0 c=2 d=1 --> 特指度=0,0,2,1 */
 #x34y {}  /* a=0 b=1 c=0 d=0 --> 特指度=0,1,0,0 */
 style="" /* a=1 b=0 c=0 d=0 --> 特指度 = 1,0,0,0 */
```

```html
<head>
  <style type="text/css">
    #x97z {
      color: red;
    }
  </style>
</head>
<body>
  <p id="x97z" style="color: green"></p>
</body>
```

在上面的例子中，P 元素的颜色将是绿色。由于层叠规则，"style" 属性中的声明将优先于 STYLE 元素中的声明，因为它具有更高的特指度。

# 5. 盒模型

本章阐述盒模型。CSS 盒模型描述了文档树中的元素生成的矩形框，并根据视觉格式化模型进行布局。

## 5.1. 盒子尺寸

每个盒子都有一个内容区（如文本、图像等）和可选的内边距、边框和外边距。每个区域的大小由下面定义的属性指定。下图显示了这些区域的关系，以及用来指代这些区域的术语。

![盒模型](illustrations/box_model.svg)

外边距、边框和内边距可以细分为上、右、下、左四个部分（例如，在图中，"LM" 表示左外边距，"RP" 表示右内边距，"TB" 表示上边框，等等）。

四个区域（内容、内边距、边框和外边距）中的每个区域的周长被称为 "边缘"，因此每个盒子都有四个边缘。

- **内容边缘或内边**
  内容边缘围绕着盒子的宽度和高度所给出的矩形，这往往取决于元素的渲染内容。四条内容边缘定义了盒子的 **内容盒**。
- **内边距边缘**
  内边距边缘围绕着盒子的内边距。如果内边距的宽度为 0，则内边距边缘与内容边缘相同。四个内边距边缘定义了盒子的 **内边距盒**。
- **边框边缘**
  边框边缘围绕着盒子的边框。如果边框的宽度为 0，则边框边缘与内边距边缘相同。四条边框边缘定义了盒子的 **边框盒子**。
- **边距边或外边**
  外边距边缘围绕着盒子的外边距。如果外边距的宽度为 0，那么外边距边缘与边框边缘相同。四条外边距边缘定义了盒子的 **外边距盒子**。

每种边缘都可以细分为上、右、下、左四个边缘。

盒子的内容区的尺寸--内容宽度和内容高度--取决于几个因素：生成盒子的元素是否设置了 "width" 或 "height"属性，盒子是否包含文本或其他盒子，盒子是否是一个表格，等等。盒子的宽度和高度将在视觉格式化模型章节中讨论。

盒子的内容、内边距和边框区域的背景样式由生成元素的 "background" 属性指定。外边距的背景总是透明的。

## 5.2. 外边距长度

外边距属性指定一个盒子的外边距区域的宽度。margin 简写属性设置了所有四边的外边距，而其他的外边距属性只设置了各自的边。这些属性适用于所有元素，但垂直外边距不会对非替换的内联元素产生任何影响。

本节中定义的属性指的是 `<margin-width>` 值类型，它可以取以下值之一。

`<margin-width>` 的值类型，它可以采取以下值之一：

- `<length>`
  指定一个固定的宽度。

- `<percentage>`
  该百分比是相对于生成盒的包含块的宽度计算的。注意，这对 'margin-top' 和 'margin-bottom' 也是如此。

- auto
  参见第 7 章的 "计算宽度和外边距行为" 部分。

margin 属性的负值是允许的，但可能有特定的实施限制。

| 属性名   | margin-top, margin-bottom                                                            |
| -------- | ------------------------------------------------------------------------------------ | -------- |
| 值       | `<margin-width>                                                                      | inherit` |
| 初始值   | 0                                                                                    |
| 适用元素 | 所有元素，但具有除 table-caption、table 和 inline-table 以外的表格显示类型的元素除外 |
| 可继承   | 否                                                                                   |
| 百分数   | 相对于包含块的 width 属性值                                                          |
| 计算值   | 指定的百分数或绝对长度                                                               |

这些属性对非替换性行内元素没有效果：

| 属性名   | margin-left, margin-right                                                            |
| -------- | ------------------------------------------------------------------------------------ | -------- |
| 值       | `<margin-width>                                                                      | inherit` |
| 初始值   | 0                                                                                    |
| 适用元素 | 所有元素，但具有除 table-caption、table 和 inline-table 以外的表格显示类型的元素除外 |
| 可继承   | 否                                                                                   |
| 百分数   | 相对于包含块的 width 属性值                                                          |
| 计算值   | 指定的百分数或绝对长度                                                               |

| 属性名   | margin                                                                               |
| -------- | ------------------------------------------------------------------------------------ | -------- |
| 值       | `<margin-width>{1,4}                                                                 | inherit` |
| 初始值   | 0                                                                                    |
| 适用元素 | 所有元素，但具有除 table-caption、table 和 inline-table 以外的表格显示类型的元素除外 |
| 可继承   | 否                                                                                   |
| 百分数   | 相对于包含块的 width 属性值                                                          |
| 计算值   | 指定的百分数或绝对长度                                                               |

margin 属性是一个简写属性，用于在样式表的同一位置设置 "margin-top"、"margin-right"、"margin-bottom "和 "margin-left"。

如果只有一个组件值，它适用于所有的边。如果有两个值，顶部和底部的边距被设置为第一个值，而右侧和左侧的边距被设置为第二个值。如果有三个值，顶部被设置为第一个值，左边和右边被设置为第二个值，底部被设置为第三个值。如果有四个值，它们分别适用于顶部、右侧、底部和左侧。

```css
body {
  margin: 2em;
} /* 所有边距都设置为2em */
body {
  margin: 1em 2em;
} /* 顶部和底部=1em，右侧和左侧=2em */
body {
  margin: 1em 2em 3em;
} /* 顶部=1em，右侧=2em /* top=1em, right=2em, bottom=3em, left=2em */
```

上面例子的最后一条规则等同于下面的例子。

```css
body {
  margin-top: 1em;
  margin-right: 2em;
  margin-bottom: 3em;
  margin-left: 2em; /*从对面（右边）复制过来 */
}
```

### 5.2.1. 外边距折叠

在 CSS 中，两个或多个盒（可能是也可能不是同级别的）的相邻外边距可以合并成一个外边距。以这种方式组合的外边距被称为折叠，由此产生的组合外边距被称为 **折叠外边距**。

相邻的垂直外边距会折叠，除了以下情况：

- 根元素盒子的外边距不会折叠。
- 如果一个有间隙的元素的顶部和底部外边距是相邻的，它的外边距就会与下面的兄弟元素的相邻外边距一起折叠，但产生的外边距不会与父块的底部外边距一起折叠。
- 如果一个具有非 0 计算的 "min-height" 和 "auto" 计算的 "height" 的盒子的顶部外边距与它的最后一个 in-flow 子块的底部外边距折叠，那么子块的底部外边距不会与父块的底部外边距折叠。

水平外边距永远不会折叠。

两个边距是 **相邻的**，当且仅当：

- 两者都属于参与同一块格式化环境的 in-flow 块级盒子
- 没有线框，没有间隙，没有填充物，也没有边框将它们分开（注意，某些 0 高度的线框（见 9.4.2）在此被忽略）。
- 两者都属于垂直相邻的方框边缘，即形成以下一对之一：
  - 盒子的上边缘和它的第一个 in-flow 子的上边缘
  - 盒子的底边和它的下一个 in-flow 兄弟姐妹的顶边
  - 如果父元素有 "auto" 计算的高度，最后一个 in-flow 子方的底边和父方的底边
  - 没有建立一个新的块格式化上下文，并且计算的 "min-height" 为 0，计算的 "height" 为 0 或 "auto"，并且没有 in-flow 子代的盒子的顶部和底部外边距。

如果一个折叠的边距与另一个边距相邻，它的任何组成部分的边距都被视为与该边距相邻。

注意。邻接边距可以由没有兄弟或父关系的元素产生。

注意上述规则意味着：

- 浮动盒子和任何其他框之间的边距不会折叠（甚至在浮动框和它的 in-flow 子之间也不会折叠）。
- 建立新的块格式化上下文的元素（如浮动和具有 "可见 "以外的 "溢出 "的元素）的边距不会与它们的 in-flow 子代一起折叠。
- 绝对定位的方框的边距不会折叠（甚至不会与它们的 in-flow 子元素折叠）。
- inline-block 框的边距不会折叠（甚至不会与它们的 in-flow 子集一起折叠）。
- 一个 in-flow 块级元素的底边距总是与它的下一个 in-flow 块级同级元素的顶边距一起折叠，除非该同级元素有间隙。
- 如果一个 in-flow 块元素没有上边框，没有顶部填充，并且该元素没有间隙，那么该元素的上边距将与它的第一个 in-flow 块级子元素的上边距一起折叠。
- 高度为'auto'的 in-flow 块框的底边距与它的最后一个 in-flow 块级子元素的底边距一起折叠，如果：
  - 盒子没有底部填充物，以及
  - 盒子没有底部边框，以及
  - 子节点的底边距既不会与有间隙的顶边距一起折叠，也不会（如果盒子的最小高度不为 0）与盒子的顶边距一起折叠。
- 如果一个盒子的 "最小高度 "属性为 0，并且它既没有顶部或底部边框，也没有顶部或底部填充物，并且它的 "高度 "为 0 或 "自动"，并且它不包含一个线框，并且它的所有 in-flow 子的边框（如果有的话）都会折叠。

当两个或多个边距折叠时，产生的边距宽度是折叠的边距宽度的最大值。如果是负的边距，负的相邻边距的绝对值的最大值将从正的相邻边距的最大值中扣除。如果没有正边距，相邻边距的绝对值的最大值被从 0 中扣除。

如果一个盒子的顶部和底部的边距是相邻的，那么边距有可能通过它折叠。在这种情况下，元素的位置取决于它与其他元素的边距被折叠的关系：

- 如果元素的边距与它的父元素的上边距一起折叠，那么盒子的上边框边缘就被定义为与父元素的边框相同。
- 否则，要么元素的父级不参与边际折叠，要么只涉及父级的底边。元素的上边框边缘的位置与该元素有非 0 下边框时的位置相同。

注意，被折叠过的元素的位置对其他元素的位置没有影响，它们的外边距被折叠了。顶层边框边缘的位置只在放置这些元素的子元素时需要。

## 5.3. 内边距长度

内边距属性指定了一个盒子的内边距区域的宽度。padding 简写属性设置了所有四边的内边距，而其他内边距属性只设置各自的一边。

本节中定义的属性指的是`<padding-width>`值类型，它可以取以下值之一。

- `<length>`
  指定一个固定的宽度。

- `<percentage>`
  百分比是相对于生成的框的包含块的宽度计算的，即使是 'padding-top' 和 'padding-bottom'。

与外边距属性不同，内边距的值不能是负数。和外边距属性一样，内边距属性的百分数指的是生成盒子的包含块的宽度。

| 属性名   | padding-top, padding-right, padding-bottom, padding-left                                                                   |
| -------- | -------------------------------------------------------------------------------------------------------------------------- | -------- |
| 值       | `<padding-width>                                                                                                           | inherit` |
| 初始值   | 0                                                                                                                          |
| 适用元素 | 除了 table-row-group、table-header-group、table-footer-group、table-row、table-column-group 和 table-column 以外的所有元素 |
| 可继承   | 否                                                                                                                         |
| 百分数   | 相对于包含块的 width 属性值                                                                                                |
| 计算值   | 指定的百分数或绝对长度                                                                                                     |

| 属性名   | padding                                                                                                                    |
| -------- | -------------------------------------------------------------------------------------------------------------------------- | -------- |
| 值       | `<padding-width>{1,4}                                                                                                      | inherit` |
| 初始值   | 0                                                                                                                          |
| 适用元素 | 除了 table-row-group、table-header-group、table-footer-group、table-row、table-column-group 和 table-column 以外的所有元素 |
| 可继承   | 否                                                                                                                         |
| 百分数   | 相对于包含块的 width 属性值                                                                                                |
| 计算值   | 指定的百分数或绝对长度                                                                                                     |

padding 属性是一个简写属性，用于在样式表的同一位置设置 'padding-top'、'padding-right'、'padding-bottom'和'padding-left'。

如果只有一个组件值，它适用于所有的边。如果有两个值，顶部和底部的内边距被设置为第一个值，右侧和左侧的内边距被设置为第二个值。如果有三个值，顶部被设置为第一个值，左右被设置为第二个，底部被设置为第三个。如果有四个值，它们分别适用于顶部、右侧、底部和左侧。

内边距区域的表面颜色或图像是通过 "background" 属性指定的。

```css
h1 {
  background: white;
  padding: 1em 2em;
}
```

上面的例子指定了一个'1em'的垂直内边距（'padding-top'和'padding-bottom'）和一个'2em'的水平内边距（'padding-right'和'padding-left'）。em 单位是相对于元素的字体大小而言的：'1em' 等于使用的字体大小。

## 5.4. 边框属性

边框属性指定了一个盒子的边框区域的宽度、颜色和样式。这些属性适用于所有元素。

### 5.4.1. 边框长度

边框宽度属性指定了边框区域的宽度。本节中定义的属性指的是 `<border-width>` 值类型，它可以取以下值之一。

- thin
  一个薄的边框。

- medium
  一个中等厚度的边框。

- thick
  一个厚边框。

- `<length>`
  边框的厚度有一个明确的值。明确的边框宽度不能是负值。

前三个值的解释取决于用户代理。不过，以下关系必须成立。

'thin'<='medium'<='thick'。

此外，这些宽度在整个文档中必须是恒定的。

| 属性名   | border-top-width, border-right-width, border-bottom-width, border-left-width |
| -------- | ---------------------------------------------------------------------------- | -------- |
| 值       | `<border-width>                                                              | inherit` |
| 初始值   | medium                                                                       |
| 适用元素 | 所有                                                                         |
| 可继承   | 否                                                                           |
| 百分数   | 不适用                                                                       |
| 计算值   | 绝对长度；如果 border-style 为'none'或'hidden'，则为'0'。                    |

这个属性设置了一个盒子的顶部、右侧、底部和左侧边框的宽度：

| 属性名   | border-width                                              |
| -------- | --------------------------------------------------------- | -------- |
| 值       | `<border-width>{1,4}                                      | inherit` |
| 初始值   | medium                                                    |
| 适用元素 | 所有                                                      |
| 可继承   | 否                                                        |
| 百分数   | 不适用                                                    |
| 计算值   | 绝对长度；如果 border-style 为'none'或'hidden'，则为'0'。 |

这个属性是在样式表的同一个地方设置 "border-top-width"、"border-right-width"、"border-bottom-width "和 "border-left-width "的简写属性。

如果只有一个组件值，它适用于所有边框。如果有两个值，顶部和底部的边框被设置为第一个值，右侧和左侧被设置为第二个值。如果有三个值，顶部被设置为第一个值，左边和右边被设置为第二个值，底部被设置为第三个值。如果有四个值，它们分别适用于顶部、右侧、底部和左侧。

在下面的例子中，注释指出了顶部、右侧、底部和左侧边框的结果宽度。

```css
h1 {
  border-width: thin;
} /* thin thin thin thin */
h1 {
  border-width: thin thick;
} /* thin thick thick */
h1 {
  border-width: thin thick medium;
} /* thin thick medium thick */
```

### 5.4.2. 边框颜色

边框颜色属性指定了一个盒子的边框的颜色。

| 属性名   | border-top-color, border-right-color, border-bottom-color, border-left-color |
| -------- | ---------------------------------------------------------------------------- | ----------- | -------- |
| 值       | `<color>                                                                     | transparent | inherit` |
| 初始值   | color 属性的值                                                               |
| 适用元素 | 所有                                                                         |
| 可继承   | 否                                                                           |
| 百分数   | 不适用                                                                       |
| 计算值   | 当取自'color'属性时，是'color'的计算值；否则，按照规范执行                   |

| 属性名   | border-color                                               |
| -------- | ---------------------------------------------------------- | ----------------- | -------- |
| 值       | `[<color>                                                  | transparent]{1,4} | inherit` |
| 初始值   | color 属性的值                                             |
| 适用元素 | 所有                                                       |
| 可继承   | 否                                                         |
| 百分数   | 不适用                                                     |
| 计算值   | 当取自'color'属性时，是'color'的计算值；否则，按照规范执行 |

border-color 属性设置了四个边框的颜色。值有以下含义。

- `<color>`
  指定一个颜色值。

- transparent
  边框是透明的（尽管它可能有宽度）。

border-color 属性可以有 1 到 4 个分量值，值的设置与 "border-width" 一样在不同的边上。

如果一个元素的边框颜色没有用 border 属性指定，用户代理必须使用该元素的'color'属性的值作为边框颜色的计算值。

在这个例子中，边框将是一条实心黑线。

```css
p {
  color: black;
  background: white;
  border: solid;
}
```

### 5.4.3. 边框样式

边框样式属性指定了盒子的边框的线条样式（实线、双线、虚线，等等）。本节中定义的属性指的是`<border-style>`值类型，它可以取以下值之一：

- none
  没有边框；计算出的边框宽度为零。

- hidden
  与'无'相同，除了在表格元素的边界冲突解决方面。

- dotted
  边框是一系列的点。

- dashed
  边框是一系列的短线段。

- solid
  边框是一个单一的线段。

- double
  边框是两条实线。两条线和它们之间的空间之和等于'border-width'的值。

- groove
  边框看起来好像是刻在画布上的。

- ridge
  与'凹槽'相反：边框看起来就像从画布里出来的一样。

- inset
  边框使盒子看起来好像嵌入了画布中。

- outset
  与 "inset" 相反：边框使盒子看起来像是从画布中出来的。

所有的边框都是在盒子的背景上画的。对于'groove'、'ridge'、'inset'和'outset'的值所绘制的边框的颜色取决于元素的边框颜色属性，但是用户可以选择自己的算法来计算实际使用的颜色。例如，如果'border-color'的值是'silver'，那么用户可以使用从白色到深灰色的渐变色来表示一个倾斜的边框。

| 属性名   | border-top-style, border-right-style, border-bottom-style, border-left-style |
| -------- | ---------------------------------------------------------------------------- | -------- |
| 值       | `<border-style>                                                              | inherit` |
| 初始值   | none                                                                         |
| 适用元素 | 所有                                                                         |
| 可继承   | 否                                                                           |
| 百分数   | 不适用                                                                       |
| 计算值   | 按照规范执行                                                                 |

| 属性名   | border-color         |
| -------- | -------------------- | -------- |
| 值       | `<border-style>{1,4} | inherit` |
| 初始值   | none                 |
| 适用元素 | 所有                 |
| 可继承   | 否                   |
| 百分数   | 不适用               |
| 计算值   | 按照规范执行         |

border-style 属性设置了四个边框的样式。它可以有 1 到 4 个分量的值，而且这些值是在不同的边上设置的，就像上面的 'border-width'。

```css
#xy34 {
  border-style: solid dotted;
}
```

在上面的例子中，水平边框将是'solid'，垂直边框将是'dotted'。

由于边框样式的初始值是 'none'，所以除非设置了边框样式，否则不会有边框可见。

### 5.4.4. 边框简写属性

| 属性名   | border-top, border-right, border-bottom, border-left |
| -------- | ---------------------------------------------------- | --- | -------------- | --- | ---------------------- | -------- |
| 值       | `[ <border-width>                                    |     | <border-style> |     | <'border-top-color'> ] | inherit` |
| 初始值   | 见单个属性                                           |
| 适用元素 | 所有                                                 |
| 可继承   | 否                                                   |
| 百分数   | 不适用                                               |
| 计算值   | 见单个属性                                           |

这是一个简写属性，用于设置一个盒子的顶部、右侧、底部和左侧边界的宽度、样式和颜色。

```css
h1 {
  border-bottom: thick solid red;
}
```

上述规则将设置 h1 元素下方边框的宽度、样式和颜色。省略的值被设置为其初始值。因为下面的规则没有指定边框的颜色，所以边框将具有'color'属性所指定的颜色。

```css
h1 {
  border-bottom: thick solid;
}
```

| 属性名   | border            |
| -------- | ----------------- | --- | -------------- | --- | ---------------------- | -------- |
| 值       | `[ <border-width> |     | <border-style> |     | <'border-top-color'> ] | inherit` |
| 初始值   | 见单个属性        |
| 适用元素 | 所有              |
| 可继承   | 否                |
| 百分数   | 不适用            |
| 计算值   | 见单个属性        |

border 属性是一个简写属性，用于为一个盒子的所有四个边框设置相同的宽度、颜色和样式。与简写的'margin'和'padding'属性不同，'border'属性不能在四个边框上设置不同的值。要做到这一点，必须使用一个或多个其他的边框属性。

例如，下面的第一条规则等同于它后面显示的四条规则集合。

```css
p {
  border: solid red;
}

p {
  border-top: solid red;
  border-right: solid red;
  border-bottom: solid red;
  border-left: solid red;
}
```

因为在某种程度上，这些属性有重叠的功能，所以指定规则的顺序很重要。

考虑一下这个例子。

```css
blockquote {
  border: solid red;
  border-left: double;
  color: black;
}
```

在上面的例子中，左边边框的颜色是黑色，而其他边框是红色。这是由于'border-left'设置了宽度、样式和颜色。由于颜色值不是由'border-left'属性给出的，它将从'color'属性中获取。事实上，'color'属性是在'border-left'属性之后设置的，这与此无关。

## 5.5. 行内元素与 direction

对于每个行内盒子，用户代理必须采取为每个元素生成的行内盒子，并按照视觉顺序（而不是逻辑顺序）渲染边距、外边距和内边距。

当元素的'direction'属性为'ltr'时，元素出现的第一个行内盒子的最左边生成的框有左外边距、左边框和左内边距，而元素出现的最后一个行内盒子的最右边生成的盒子有右内边距、右边框和右外边距。

当元素的'direction'属性为'rtl'时，元素出现的第一个行内盒子的最右边生成的框有右内边距、右边框 和右外边距，而元素出现的最后一个行内盒子的最左边生成的框有左外边距、左边框 和左内边距。

# 6. 视觉格式化模型

## 6.1. 视觉格式化模型简介

本章和下一章描述了视觉格式化模型：用户代理如何处理视觉媒体的文档树。

在视觉格式化模型中，文档树中的每个元素都会根据盒模型生成 0 个或多个盒子。这些盒子的布局受以下因素制约。

- 盒子的尺寸和类型。
- 定位方案（正常流动、浮动和绝对定位）。
- 文档树中元素之间的关系。
- 外部信息（例如，视口尺寸、图像的固有尺寸等）。

视觉格式化模型并没有指定格式化的所有方面（例如，它没有指定字母间距算法）。符合要求的用户代理可能会对本规范未涵盖的那些格式化问题采取不同的行为。

### 6.1.1. 视口

连续媒体的用户代理通常为用户提供一个视口（屏幕上的一个窗口或其他观察区域），用户通过它来查阅文档。当视口被调整大小时，用户代理可能会改变文档的布局（见初始包含块）。

当视口小于渲染文档的画布的面积时，用户代理应该提供一个滚动机制。每个画布最多只有一个视口，但用户代理可以渲染到一个以上的画布上（即提供同一文档的不同视图）。

### 6.1.2. 包含块

在CSS 2.2中，许多盒子的位置和大小都是相对于一个叫做包含块的矩形盒子的边缘计算的。一般来说，生成盒子作为后代盒子的包含块；我们说一个这为其后代盒子 "建立" 了包含块。短语 "盒子的包含块" 是指 "盒子所处的包含块"，而不是它所生成的那个。

每个盒子都有一个相对于其包含块的位置，但它并不被这个包含块所限制；它可以溢出。

下一章将描述如何计算一个包含块的尺寸的细节。

## 6.2. 控制盒子生成

下面的章节描述了在CSS 2.2中可能生成的盒子的类型。一个盒子的类型部分地影响了它在视觉格式化模型中的行为。下面描述的'display'属性指定了一个盒子的类型。

'display' 属性的某些值会使源文档中的一个元素生成一个 **主盒子**，该主盒子包含了后代盒子和生成的内容，也是任何定位方案中涉及的盒子。一些元素可能在主盒子之外产生额外的盒子: list-item 元素。这些额外的盒子是相对于主盒子放置的。

### 6.2.1. 块级元素和块级盒子

**块级元素** --源文档中那些在视觉上被格式化为块的元素（例如，段落）--是产生块级主盒子的元素。使元素成为块级的 'display' 属性的值包括。'block'、'list-item,' 和 'table'。**块级盒子** 是参与块格式化上下文的盒子。

在CSS 2.2中，一个块级盒子也是一个块容器盒子，除非它是一个表格盒子或一个替换性元素的主盒子。一个 **块级容器盒子** 要么只包含块级盒子，要么建立一个行内格式化上下文，因此只包含行内级盒子。一个主盒子是块级容器盒子的元素是一个 **块级容器元素**。使一个非替换性元素生成一个块级容器的 'display' 属性的值包括 'block'、'list-item'和'inline-block'。并非所有的块容器盒子都是块级盒子：非替换性行内块和非替换性表格单元格是块容器，但不是块级。同时也是块状容器的块级盒子被称为 **块盒子**。

这三个术语 "块级盒子"、"块级容器盒子 "和 "块盒子" 有时在不明确的情况下被缩写为 "块"。

#### 6.2.1.1. 匿名块盒子

在这样的一个文档中：

```html
<DIV>
  Some text
  <P>More text
</DIV>
```

(假设DIV和P都有'display: block'），DIV看起来既有内联内容又有块状内容。为了便于定义格式，我们假设 "一些文本 "周围有一个匿名的块状框。

换句话说：如果一个块状容器框（比如上面为DIV生成的）里面有一个块状级别的框（比如上面的P），那么我们强制它里面只有块状级别的框。

当一个内联框包含一个内流的块级框时，内联框（及其在同一行框内的内联祖先）会围绕块级框（以及任何连续的或仅由可折叠的空白和/或外流元素分隔的块级同级）断开，将内联框分割成两个框（即使任何一边是空的），在块级框的两侧各一个。断裂前和断裂后的行框被包围在匿名块框中，而块级框成为这些匿名框的兄弟姐妹。当这样的内联框受到相对定位的影响时，任何产生的平移也会影响到内联框中包含的块级框。

匿名框的属性是从包围的非匿名框中继承的（例如，在 "匿名块框 "小节标题下的例子中，DIV的属性）。非继承的属性有其初始值。例如，匿名框的字体是继承自DIV的，但边距将是0。

在元素上设置的导致生成匿名方框的属性仍然适用于该元素的方框和内容。例如，如果在上例中的P元素上设置了边框，那么边框将围绕C1（在行末开放）和C2（在行首开放）绘制。

一些用户代理以其他方式在包含块的内联上实现边框，例如，通过将这些嵌套的块包裹在 "匿名行框 "内，从而在这些行框周围绘制内联边框。由于CSS1和CSS2没有定义这种行为，只有CSS1和CSS2的用户代理可以实现这种替代模型，并且仍然声称符合CSS 2.2的这一部分。这不适用于本规范发布后开发的用户代理。

在解析引用它的百分比值时，匿名的块状框会被忽略：会使用最接近的非匿名的祖先框。例如，如果上面DIV内的匿名块框的子代需要知道其包含块的高度来解决百分比高度，那么它将使用DIV形成的包含块的高度，而不是匿名块框的高度。

## 6.3. 定位方案



## 6.4. 正常流

## 6.5. 浮动

## 6.6. 绝对定位

## 6.7. display, position 和 float 之间的关系

## 6.8. 对比正常流，浮动和绝对定位

## 6.9. 分层显示

## 6.10. 文本方向

# 7. 格式化细节

## 7.1. 包含块的定义

## 7.2. 内容宽度：width 属性

## 7.3. 计算 width 和 margin

## 7.4. 最小与最大宽度

## 7.5. 内容高度：height 属性

## 7.6. 计算 height 和 margin

## 7.7. 最小与最大高度

## 7.8. 行高的计算

# 8. 弹性盒子布局

# 9. 网格布局

# 10. 表格

# 11. 生成内容和列表

# 12. 颜色，背景和渐变

## 12.1. 颜色

## 12.2. 背景

## 12.3. 渐变

# 13. 字体

设计字体属性是样式表常见的用途之一。

## 13.1. font-family

我们熟知的字体包含多个变体：粗体，斜体等。例如，Times 字体实际上有：TimesRegular, TimesBold, TimesItalic 等。Times 的这些变体都是来自于一个字体族，而不是一种字体。

使用 font-family 可以指定字体族。例如，让一个文档使用无衬线字体，你可以这样写：

```css
body {
  font-family: sans-serif;
}
```

在一些情况，用户的电脑可能没有安装一个字体。这时，我们可以使用字体族序列指定 font-family:

```css
body {
  font-family: Georgia, serif;
}
```

这样做，如果用户电脑没有安装 Georgia，则文档就会显示 serif。

## 13.2. @font-face

@font-face 的作用是让你在设计中使用自定义的字体。这个特性首次出现在 CSS2 中。

假设你想使用的字体没有广泛安装，而是个特殊的字体。借助 @font-face，你可以定义一个专门的字体族名称，对应服务器上的一个字体文件。用户代理将下载那个文件，使用它渲染。

例如：

```css
@font-face {
  font-family: 'SwitzeraADF';
  src: url('SwitzeraADF-Regular.otf');
}
```

## 13.3. font-weight

font-weight 属性可以精确控制字重。一般来说，自重越大，字体越黑，越粗。

font-weight 属性值可以取 100 到 900 的正一百值。还可以取 normal, bold, bolder, lighter 这几个关键字。不过一般而言，还是推荐使用关键字。

## 13.4. font-size

font-size 属性用于控制字体的大小。

### 13.4.1. 绝对大小

font-size 支持的绝对大小值有：xx-small, x-small, small, medium, large, x-large, 和 xx-large。这个几个关键字没有固定的大小是相对而言的。

### 13.4.2. 相对大小

关键字 larger 和 smaller 相对简单，它们根据父元素的字号增大或减少一定比例。

百分数也可以用作字号，百分数始终根据父元素的字号计算。

em 这个相对单位和百分数相似，1em 相当于 100%。

### 13.4.3. 长度单位

font-size 可以设置为任何的长度值。

## 13.5. font-style

font-style 设置字体在 normal（常规），italic（斜体），和 oblique（倾斜体之间做选择）。

斜体和倾斜体之间的区别是，斜体是一种单独的字型，字母的构造有改动。而倾斜体只是竖直体的倾斜版本。

## 13.6. font-variant

font-variant 设置了字体的一些变形信息。

## 13.7. font

font 属性是 font-style, font-size, font-family 属性的简写。

# 14. 文本

本章讨论关于文本属性的控制。不过在此之前，我们要明白“行内”和“块级”这两个术语。文本书写的块级方向是指文本是竖直放置的，就像一个个段落那样。而行内书写方向是横向的，可能是从左至右（比如英语），也可能是从右往左（阿拉伯语）。

## 14.1. 缩进与行内对齐

### 14.1.1. text-indent

多数语言在排版时，会缩进第一段的第一行。以前，要想达到缩进效果，会在第一行的左边放一个透明的图像。CSS 为缩进文本提供了一个更好的方法：text-indent。

text-indent 属性把元素第一行文本缩进指定的长度。这个属性常用作缩进段落的第一行。

例如：

```css
p {
  text-indent: 2em;
}
```

text-indent 可以用于任何块级元素上，但不能用于行内元素或替换性元素。

### 14.1.2. text-align

text-align 可以控制元素中每行文本的对齐方式。这个属性的值可以取 start，end，left，right，center，justify。

left，right，和 center 取值从字面意思就可以看出它们的含义。left 代表各行文本靠左对齐。right 则是靠右。center 是居中对齐。

CSS3 添加了 start 和 end。这是由于一些语言，如阿拉伯语默认情况下就是从右往左书写的。新修订的 start 值表示文本与元素盒子的起始边对齐。end 表示和元素盒子的终止边对齐。

justify 值表示两端对齐。

### 14.1.3. text-align-last

有时候，你可能希望对齐最后一行。此时，你可以使用 text-align-last。它的取值和 text-align 基本一致。

## 14.2. 块级对齐

讲完行内文本对齐后，我们开始讲块级文本对齐。

### 14.2.1. line-height

line-height 可以控制文本行的高度。在讲解之前我们首先得了解行高是由什么构成的。

实际上，一个文本行的高度并不是字体的大小，而是加上了行距。一般而言，如果字体大小是 16px，那么浏览器会设置行高为 16px 的 1.2 倍，这样字的上下方就各有 (16px \* 1.2 - 16px) = 0.6px 的行距，这样文本行之间显得就不是很紧密。

如果我们设置了 line-height 为 18px，那么相当于增大了行距，假设字体大小为 16px，那么行距为：(18px - 16px)/2 = 1px。

### 14.2.2. vertical-align

vertical-align 可以控制行内元素文本竖直方向的对齐。它可以取值：baseline，sub，super，bottom，text-bottom，middle，top 和 text-top。

当 vertical-align 取 baseline（默认值）时，会使得元素的基线和父元素的基线对齐。如果目标元素没有基线，例如替换性元素，那么元素的底端和父元素的基线对齐。

当 vertical-align 取 sub 值时，元素的基线低于父元素的基线，此时我们说目标元素位于下标位置。不同的浏览器对于目标元素的下沉距离实现不同。

和 sub 类似，super 值使得目标元素位于上标位置。

当 vertical-align 取 bottom 值时，目标元素和父元素的文本行底部对齐。

和 bottom 类似，top 值使得目标元素和父元素的文本行顶部对齐。

## 14.3. 文本间距

本节来讨论单词间距和字符间距。

### 14.3.1. wording-spacing

word-spacing 属性用来指定文本的单词间距。默认值为 0。对于单词的定义，不能适用于象形文字。

### 14.3.2. letter-spacing

letter-spacing 属性用来指定文本的字符间距。默认值为 0。这个属性可以用于象形文字。

## 14.4. text-transform

text-transform 用于转换文本，可以取值：none(默认值), lowercase, uppercase, 和 captalize。

lowercase 用于将文本转为小写。uppercase 用于将文本转为大写。captalize 用于将单词的首字母大写。

## 14.5. text-decoration

text-decoration 用于装饰文本。可以取值：none(默认值), underline, overline, line-through, blink。

underline 在文本下面加上下划线，overline 在文本上面加上一条线。line-through 绘制一条穿过文本的线，也叫删除线。

## 14.6. text-shadow

text-shadow 用于给文本加上阴影。这个属性的默认值为 none。

这个属性可以多次使用，相当于给文本加上多个阴影。

下面的例子演示了一个文本阴影：

```css
p {
  text-shadow: black 5px 2px;
}
```

第一个参数表示阴影的颜色，第 2 个参数表示阴影的横向偏移，在这个例子中阴影向右边偏移了 5px，第 3 个参数表示纵向偏移。

## 14.7. 处理空白

### 14.7.1. white-space

white-space 属性用于处理 HTML 源码中的空格，换行符，制表符。

white-space 属性可以取值：normal(默认值), nowrap, pre, pre-wrap, pre-line。

normal 值表示 HTML 文档中，文本之间连续的空格默认会被合并为 1 个：

```html
<p>有 很多 空格 的 文 本。</p>
```

这个 p 元素实际上和下面的是相同的：

```html
<p>有 很多 空格 的文 本。</p>
```

然而，我们可以设置 white-space 为 pre，这样连续的空格不会被忽略。但不仅如此，回车符，制表符也会得到保留。

nowrap 禁止元素中的文本换行，除非使用了 br 元素。

pre-wrap 和 pre-line 是 CSS2.1 引入的，设为 pre-wrap 时，文本中的空白可以保留，但文本将换行。pre-line 则是合并连续空白，但是保留换行。

下表进行了总结：

| 值       | 空白 | 换行符 | 自动换行 |
| -------- | ---- | ------ | -------- |
| normal   | 合并 | 忽略   | 允许     |
| nowrap   | 合并 | 忽略   | 禁止     |
| pre-line | 合并 | 保留   | 允许     |
| pre-wrap | 保留 | 保留   | 允许     |
| pre      | 保留 | 保留   | 禁止     |

### 14.7.2. tab-size

既然 white-space 取某些值时空白保留下来，那么制表符就会被保留下来。但一个制表符等于多少个空格呢？tab-size 属性就派上了用场。

默认情况下，一个制表符相当于 8 个连续的空格。不过，可以使用 tab-size 属性改变。

## 14.8. 换行和断字

### 14.8.1. word-break

word-break 属性用于控制文本换行。可以取值：normal, break-all, keep-all。

默认值 normal 的意思是文本在单词之间换行。如果使用 break-all，换行可以出现在任意字符之间。keep-all 禁止在字符之间换行。

### 14.8.2. line-break

line-break 适用于中文，日文以及韩文语言的换行。这个属性可以取值：auto，loose，normal，和 strict。

### 14.8.3. overflow-wrap

overflow-wrap 用于文本行超出容器时的处理。可以取值：normal 和 break-word。当取 normal 时，按照单词之间换行。使用 break-word 时可以在单词内部换行。

## 14.9. 书写模式

英语是从左向右从上到下排列的，然而其他语言并不都是这样。

### 14.9.1. writing-mode

writing-mode 可以指定书写模式。可以取值：horizontal-tb（默认值），vertical-rl，vertical-lr。

默认值 horizontal-tb 表示行内方向为横向，块级方向为从上到下。后 2 个值得行内方向时纵向，块级方向分别为从右到左和从
左到右。

### 14.9.2. text-orientation

选定书写模式后，可能还想改变文本行中字符的方向。这就要用到 text-orientation。可以取值：mixed（默认），upright，sideways。

当书写模式取值 vertical-lr 时，中英文的字符方向并不统一，这是因为 text-orientation 默认取值 mixed。当取值 sideways 时，2 种字符都是一个方向向侧边。而 upright 则是从上到下的方向。
