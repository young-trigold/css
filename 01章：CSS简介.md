**目录：**

- [1. CSS 简介](#1-css-简介)
  - [1.1. CSS 历史](#11-css-历史)
  - [1.2. 惯例](#12-惯例)
    - [1.2.1. CSS 属性定义](#121-css-属性定义)
    - [1.2.2. 简写属性](#122-简写属性)
      - [1.2.2.1. all 属性](#1221-all-属性)
  - [1.3. 引入 CSS](#13-引入-css)
    - [1.3.1. 外部样式表](#131-外部样式表)
    - [1.3.2. 内部样式表](#132-内部样式表)
    - [1.3.3. 行内样式](#133-行内样式)
  - [1.4. CSS 处理模型](#14-css-处理模型)
  - [1.5. 重要概念](#15-重要概念)
  - [1.6. 媒体类型](#16-媒体类型)
    - [1.6.1. 媒体类型介绍](#161-媒体类型介绍)
    - [1.6.2. 指定媒体独立样式表](#162-指定媒体独立样式表)
      - [1.6.2.1. @media 规则](#1621-media-规则)
    - [1.6.3. 识别媒体类型](#163-识别媒体类型)
      - [1.6.3.1. 媒体组](#1631-媒体组)

# 1. CSS 简介

## 1.1. CSS 历史

1994 年，正值 Web 开始广泛流行开来，CSS 的第一个提案发布了。那时，浏览器为用户提供了各种各样的定制功能。例如，用户在 Mosaic 的表现偏好设置中可以为单个元素设定字体族，字号和颜色。而文档的编写人员却做不到这一点，文档编写人员只能把内容标记称一个个段落，标题，预格式文本，或者一些其他类型的元素。如果用户愿意，可以把以及标题设为粉红色的小字，而把六级标题设为红色的大字。

CSS 就是在这样的背景下诞生的。它的目标是提供一个简单的声明式样式语言，而且具有一定的灵活性，能为文档编写人员和用户提供等同的样式化功能。层叠样式表中的“层叠”是指样式表可以结合起来使用，而且具有优先级，文档编写人员和用户都有话语权，不过最终的决策权在用户手中。

草案制定的速度很快，到 1996 年末，CSS1 完成了。此后，刚组建的 CSS 工作组开始着手制定 CSS2，而各个浏览器则相互协作，努力实现 CSS1。单独来看，CSS 的每一部分都很简单，但把各部分放在一起就变得已成复杂。而且早期的实现有些先天不足。例如，不同浏览器对盒模型(Box Model)的实现差异尤其为人诟病。这些问题直接影响到 CSS 的名声，幸好一些聪明人提出了变通方法，让浏览器的行为保持了一致。得益于一致性的提高和高调的开发活动，几年之间，CSS 逐渐开始流行。

不过，在此之前，CSS2 规范于 1998 年初定案。随后，CSS 工作组立即投身 CSS3 的制定工作，以及 CSS2 的修订工作。与以往不同的是，CSS3 有多个模块构成，而不是单独一个臃肿的规范。XHTML 规范受此启发，也采用了模块机制。

CSS3 分成多个模块的根本原因是各模块可以独立演进，尤其是模块可以按照 W3C 的规划向前推进，而不必受其他模块拖累。事实证明，这样做是对的。截至 2012 年初，有 3 个 CSS3 模块(CSS Color Level 3，CSS Namespace，Selectors Level 3) 变成了推荐状态，而有 7 个模块处于候选状态，还有 7 个模块处在不同的草案状态。如果采用以前的机制，要等到其他部分完成才能在一份完成的规范中发布颜色，选择器和命名控件的新条款。得益于模块化，我们无需等待。

但是，这样做也有缺点，CSS3 规范不能涵盖一切。即便其他模块在某一时刻到达了 Level 3，比如说 2016 年末（然而事实是没有），Selectors Level 4 也都开始制定了。那会不会有 CSS4？CSS3 那些尚未正式发布的新特性呢？还有 Grid Layout，它甚至还没到 Level 1！

可见，我们不能指着一摞厚厚的文件说，这就是 CSS3，而应该分模块学习不同的特性。模块的灵活性有时可以弥补语义不足。

## 1.2. 惯例

### 1.2.1. CSS 属性定义

每个 CSS 属性定义的开头都有一个关键信息的摘要，类似于以下内容：

| 属性名   | 属性的名字         |
| -------- | ------------------ |
| 属性值   | 合法值和语法       |
| 初始值   | 初始值             |
| 适用元素 | 该属性适用的元素   |
| 可继承性 | 该属性是否可被继承 |
| 百分数值 | 百分数值解释方式   |
| 适用媒体 | 该属性适用的媒体组 |
| 计算值   | 计算值的计算方式   |

- **属性值**

这一部分规定了属性值的有效值集。一个属性值可以有一个或多个组件。组件值的类型有几种指定方式：

- 关键字值（例如，auto, inherit 等）
- 基本数据类型，出现在"<"和">"之间（例如，`<length>`，`<percentage>`，等等）。
- 与同名属性具有相同取值范围的类型（例如，<'border-width'> <'background-attachment'>，等等）。在这种情况下，类型名称是"<"和">"之间的属性名称（完整的引号）（例如，<'border-width'>）。这样的类型不包括 'inherit' 这个值。
- 与属性不共享同一名称的非终结符。在这种情况下，非终结符出现在"<"和">"之间，如`<border-width>`。注意`<border-width>`和`<'border-width'>`之间的区别；后者是根据前者来定义的。

这些定义中的其他词语是关键词，必须按字面意思出现，不加引号（例如，red）。斜线（/）和逗号（,）也必须按字面意思出现。

组件值可按以下方式排列成属性值：

- 几个并列的词意味着它们都必须按照给定的顺序出现。
- 一个竖线(|)分隔了两个或更多的选项：其中必须有一个正好出现。
- 一个双竖线(||)分隔两个或多个选项：其中一个或多个必须以任何顺序出现。
- 一个双和号(&&)分隔两个或更多的组件，所有这些组件必须以任何顺序出现。
- 括号（[ ]）是用来分组的。

并列比双和号强，双和号比双竖线强，双竖线比竖线强。因此，以下 2 行是等同的：

```
a b | c || d && e f
[ a b ] | [ c || [ d && [ e f ]] ]
```

每个类型、关键字或括号内的组都可以在后面加上以下修饰语之一。

- 星号（\*）表示前面的类型、词或组出现了零次或多次。
- 加号（+）表示前面的类型、词或组出现一次或多次。
- 问号(?)表示前面的类型、词或组是可选的。
- 大括号中的一对数字（{A,B}）表示前面的类型、词或组至少出现 A 次，最多 B 次。

下面的例子说明了不同的值类型：

```css
属性值: N | NW | NE
属性值: [ <length> | thick | thin ]{1,4}
属性值: [<family-name> , ]* <family-name>
属性值: <uri>? <color> [ / <color> ]?
属性值: <uri> || <color>
属性值: inset? && [ <length>{2,4} && <color>? ]
```

属性值中的符号之间也可能出现空格。

注意：在许多情况下，为了将它们彼此区分开来，符号之间实际上需要空格。例如，值'1em2em'会被解析为一个带有数字'1'和标识符'em2em'的单一 DIMEN 符号，这是一个无效的单位。在这种情况下，需要在'2'前加一个空格，以便将其解析为两个长度的'1em'和'2em'。

- **初始值**

这一部分指定了属性的初始值。关于样式表指定的、继承的和初始属性值之间的交互信息，请参考 [层叠](#44-层叠) 部分。

- **适用元素**

这一部分列出了该属性所适用的元素。所有的元素都被认为拥有所有的属性，但有些属性对某些类型的元素没有渲染效果。例如，'clear' 属性只影响到块级元素。

- **可继承性**

这一部分表示该属性的值是否从祖先元素继承。关于样式表指定的、继承的和初始属性值之间的交互信息，请参考 [层叠](#44-层叠) 部分。

- **百分数值**

如果百分数值出现在属性的值中，这部分表明应如何解释百分数值。如果 "N/A" 出现在这里，这意味着该属性不接受百分数值。

- **适用媒体**

这一部分表示该属性所适用的媒体组。请参见 [媒体类型](#16-媒体类型) 部分。

- **计算值**

这一部分描述了该属性的计算值。关于此定义的使用方法，请参见 [计算值](#412-计算值) 部分。

### 1.2.2. 简写属性

有些属性是 **简写属性**，意思是它们允许作者用一个属性指定几个属性的值。一个简写属性设置了它所有的长式子属性，就像在原地展开一样。

当值从简写形式中省略时，除非另有定义，否则每个“缺失的”子属性都会被分配其初始值。

这意味着一个简写属性声明总是设置其所有的子属性，甚至那些没有明确设置的子属性。如果不小心使用，这可能会导致无意中重新设置一些子属性。谨慎地使用，简写可以通过重设不经意间从其他来源串联的子属性来保证 "白板"。
例如，写background: green而不是background-color: green可以确保背景色覆盖任何先前的声明，这些声明可能将背景设置为带有background-image的图像。

例如，CSS level 1 'font' 属性是一个简写属性，用于一次性设置font-style、font-variant、font-weight、font-size、line-height和font-family。这个例子中的多个声明：

```css
h1 {
  font-weight: bold;
  font-size: 12pt;
  line-height: 14pt;
  font-family: Helvetica;
  font-variant: normal;
  font-style: normal;
}
```

因此，可以改写为：

```css
h1 { font: bold 12pt/14pt Helvetica }
```

随着更多的字体子属性被引入到CSS中，简写声明也会将这些子属性重置为初始值。

在某些情况下，一个简写项可能会有不同的语法或特殊的关键字，它们并不直接对应于其子属性的值。(在这种情况下，简写项将明确地定义其值的扩展）。

在其他情况下，一个属性可能是简写属性的一个 **只重置的子属性**。像其他子属性一样，当未指定时，它被简写属性重置为其初始值，但简写属性可能不包括将该子属性设置为其任何其他值的语法。例如，border简写属性将border-image重置为其初始值none，但没有语法将其设置为任何其他值。

如果一个简写属性被指定为全局关键字之一，它就会将其所有的子属性设置为该关键字，包括任何只重置的子属性。(注意，这些关键字不能在一个声明中与其他值结合，甚至在一个简写中也不行）。

将一个简写属性声明为!important 等同于将其所有的子属性声明为!important。

#### 1.2.2.1. all 属性

| 属性名   | all                                                           |
| -------- | ------------------------------------------------------------------------------------ | -------- |
| 值       | `initial|inherit|unset` |
| 初始值   |见单独属性                                                                                    |
| 适用元素 | 见单独属性 |
| 可继承   | 见单独属性                                                                                   |
| 百分数   | 见单独属性                                                          |
| 计算值   | 见单独属性                                                               |

all属性是一个简写属性，可以重置除 'direction' 和 'unicode-bidi' 之外的所有CSS属性。它只接受CSS范围内的关键字。它不会重置自定义属性[css-variables-1]。

注意：除了方向和unicode-bidi之外的CSS属性实际上是标记级的特性，不应该在作者的样式表中设置。(它们作为CSS属性存在，只是为了给UA不支持的文档语言设置样式）。作者应该使用适当的标记，如HTML的dir属性，而不是。[css-writing-modes-3]。

例如，如果作者在一个元素上指定了all: initial，它将阻止所有的继承并重置所有的属性，就像没有规则出现在级联的作者、用户或user-agent层一样。

这对包含在一个页面中的 "组件" 的根元素很有用，它不希望继承外部页面的样式。然而，请注意，任何应用于该元素的 "默认" 样式（例如，来自`<div>`等块级元素的UA样式表的display: block）也将被覆盖。

## 1.3. 引入 CSS

在学习 CSS 之前，我们得首先在 HTML 关联 CSS，不然 CSS 就没法影响 HTML 文档。下面介绍 3 种引入 CSS 的方式。

### 1.3.1. 外部样式表

外部样式表式引入 CSS 最常用的方式。这种方式用到了 link 元素，例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>外部样式表</title>
    <link rel="stylesheet" href="style.css" media="screen" />
  </head>
  <body></body>
</html>
```

上述例子向 HTML 文档中引入了一个 style.css 外部样式表。

外部样式表中没有任何 HTML 标签。外部样式表保存为纯文本文件，文件扩展名是 .css。

- link 元素的属性

link 元素的 rel 属性表示链接资源和 HTML 文档的关系，对于 CSS 文档来说，就是“stylesheet”。

link 元素的 href 属性制定了链接资源的地址。

最后的 media 属性，它的值是一个或多个媒体描述符(media descriptor)，表示什么样的媒体应该使用这个 CSS 文档。例如：

```html
<link rel="stylesheet" href="style.css" media="screen, screen" />
```

多个媒体描述符用逗号分隔。媒体描述符本书后面会详细的介绍。

link 的 type 属性现在已经不常用了，它用来指定资源的 MIME 类型，不过对于 CSS 文档，浏览器默认为 "text/css"。

- @import

@import 指令可以出现在 CSS 文档中，它的作用是链接另外一个 CSS 文档。例如：

```css
@import url(basic.css);
```

@import 指令必需放在 CSS 规则之前，否则不会有效。

### 1.3.2. 内部样式表

另外一种引入 CSS 的方式是通过 style 元素。例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>内部样式表</title>
    <style>
      h1 {
        color: red;
      }

      h2 {
        color: maroon;
        background: black;
      }
    </style>
  </head>
  <body></body>
</html>
```

### 1.3.3. 行内样式

最后一种的方式是通过 HTML 元素的 style 全局属性。例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>行内样式</title>
  </head>
  <body>
    <p style="color: red;">一段文本。</p>
  </body>
</html>
```

## 1.4. CSS 处理模型

本节介绍了支持 CSS 的用户代理如何工作的一个可能模型。这只是一个概念性的模型；实际的实现可能会有所不同。

在这个模型中，用户代理通过以下步骤来处理一个来源：

1. 解析源文档并创建一个文档树。
2. 识别目标媒体类型。
3. 检索所有与该文档相关的、为目标媒体类型指定的样式表。
4. 通过给适用于目标媒体类型的每个属性分配一个单一的值来注释文档树的每个元素。属性是根据层叠和继承一节中描述的机制来分配数值的。部分数值的计算取决于适合于目标媒体类型的格式化算法。例如，如果目标媒体是屏幕，用户代理会应用视觉格式化模型。
5. 从注释的文档树中，生成一个格式化结构。通常，格式化结构与文档树非常相似，但也可能有很大不同，特别是当作者使用伪元素和生成的内容时。首先，格式化结构根本不需要是 "树形 "的，结构的性质取决于实现。第二，格式化结构可能包含比文档树更多或更少的信息。例如，如果文档树中的一个元素的 "display "属性的值是 "none"，那么这个元素在格式化结构中就不会产生任何信息。另一方面，一个列表元素可能会在格式化结构中产生更多的信息：列表元素的内容和列表样式信息（例如，一个子弹头图像）。请注意，CSS 用户代理在这个阶段不会改变文档树。特别是，由于样式表产生的内容不会被反馈给文档语言处理器（例如，用于重新解析）。
6. 将格式化结构转移到目标媒体（例如，打印结果、在屏幕上显示、渲染成语音等）。

## 1.5. 重要概念

- **样式表**

一组指定文档表现形式的语句。
样式表可能有三个不同的来源：作者、用户、和用户代理。这些来源的交互在层叠和继承一节中描述。

- **有效样式表**

样式表的有效性取决于样式表所使用的 CSS 的级别。所有有效的 CSS1 样式表都是有效的 CSS2.2 样式表，但是 CSS1 的一些变化意味着一些 CSS1 样式表在 CSS2.2 中会有轻微的语义不同。CSS2 中的一些特性不是 CSS2.2 的一部分，所以不是所有的 CSS2 样式表都是有效的 CSS2.2 样式表。

一个有效的 CSS2.2 样式表必须按照 CSS2.2 的语法来写。此外，它必须只包含本规范中定义的 at-rules、属性名称和属性值。一个非法的（无效的）at-rule、属性名或属性值是无效的。

- **源文档**

一个或多个样式表所适用的文档。这是用某种语言编码的，它把文档表示为一棵元素树。每个元素由一个识别元素类型的名称、可选择的一些属性和一个（可能是空的）内容组成。例如，源文件可以是一个 XML 或 SGML 实例。

- **文档语言**

源文档的编码语言（例如，HTML、XHTML 或 SVG）。CSS 用于描述文档语言的表现形式，CSS 并不改变文档语言的基本语义。

- **元素**

文档语言的主要语法结构。大多数 CSS 样式表规则使用这些元素的名称（如 HTML 中的 P、TABLE 和 OL）来指定这些元素应该如何被呈现。

- **替换性元素**

一个内容不在 CSS 格式化模型范围内的元素，如图像、嵌入式文档或小程序。例如，HTML IMG 元素的内容经常被其 "src" 属性指定的图像所取代。被替换的元素通常有固有的尺寸：固有的宽度、固有的高度和固有的比例。例如，一个位图图像有一个以绝对单位指定的固有宽度和固有高度（固有尺寸比显然可以从这里确定）。另一方面，其他文档可能没有任何固有的尺寸（例如，一个空白的 HTML 文档）。

如果用户代理认为一个被替换的元素没有任何固有的尺寸，那么这些尺寸可能会向第三方泄露敏感信息。例如，如果一个 HTML 文档根据用户的银行余额改变了固有的尺寸，那么 UA 可能希望像该资源没有固有的尺寸一样行事。

被替换的元素的内容在 CSS 渲染模型中不被考虑。

- **固有尺寸**

由元素本身定义的宽度和高度，而不是由周围环境强加的。CSS 并没有定义如何找到固有尺寸。在 CSS 2.2 中，只有被替换的元素可以带有固有的尺寸。对于没有可靠分辨率信息的光栅图像，必须假定每个图像源像素的尺寸为 1px 单位。

- **属性**

一个与元素相关的值，由一个名称和一个相关的（文本）值组成。

- **内容**

在源文档中与一个元素相关的内容。有些元素没有内容，在这种情况下，它们被称为 **空元素**。一个元素的内容可能包括文本，也可能包括一些子元素，在这种情况下，该元素被称为这些子元素的父元素。

- **忽略**

这个术语在本规范中有两种略有不同的含义。首先，一个 CSS 解析器在发现样式表中的未知或非法语法时必须遵循某些规则。然后，解析器必须忽略样式表的某些部分。哪些部分必须被忽略的确切规则在这些章节（声明和属性、处理解析错误的规则、不支持的值）中描述，或者可以在术语 "忽略 "出现的文本中解释。第二，一个用户代理可以（而且在某些情况下必须）不理会样式表中的某些属性或值，即使语法是合法的。例如，表列元素不能影响表列的字体，所以字体属性必须被忽略。

- **渲染内容**

一个元素的内容在根据相关样式表适用于它的渲染后被应用。一个替换性元素的内容是如何被渲染的，本规范没有定义。渲染的内容也可以是一个元素的替代文本（例如，XHTML "alt" 属性的值），并可能包括由样式表隐含地或显式地插入的项目，如栏目、编号等。

- **文档树**
  在源文档中编码的元素树。这个树中的每个元素都有一个父元素，但根元素除外，它没有。

- **子元素**

当且仅当 B 是 A 的父元素时，一个元素 A 被称为元素 B 的子元素。

- **后代元素**

一个元素 A 被称为元素 B 的后代元素，如果(1)A 是 B 的一个子元素，或者(2)A 是某个元素 C 的子元素，而这个元素 C 是 B 的后代元素。

- **祖先元素**

当且仅当 B 是 A 的后代元素时，元素 A 被称为元素 B 的祖先元素。

- **兄弟元素**

一个元素 A 被称为元素 B 的兄弟元素，当且仅当 B 和 A 共享同一个父元素。如果元素 A 在文档树中排在元素 B 之前，它就是一个前级兄弟元素。如果元素 B 在文档树中排在 A 的后面，那么它就是一个跟随的兄弟元素。

- **前置元素**

当且仅当(1)A 是 B 的祖先或(2)A 是 B 的前面的兄弟元素时，一个元素 A 被称为元素 B 的前置元素。

- **后置元素**

当且仅当 B 是 A 的前面的元素时，一个元素 A 被称为 B 的后置元素。

- **作者**

作者是一个编写文档和相关样式表的人。编写工具是一个生成样式表的用户代理。

- **用户**

用户是与用户代理互动以查看、听取或以其他方式使用一个文件及其相关的样式表的人。用户可以提供一个编码个人偏好的个人样式表。

- **用户代理（UA）**

用户代理是任何解释以文档语言编写的文档并根据本规范的条款应用相关样式表的程序。一个用户代理可以显示一个文档，大声朗读它，使它被打印出来，把它转换成另一种格式，等等。

一个 HTML 用户代理是一个支持一个或多个 HTML 规范的用户代理。一个支持 XHTML[XHTML]，但不支持 HTML 的用户代理不被认为是一个符合本规范的 HTML 用户代理。

- **属性**

CSS 定义了一个有限的参数集，称为属性，用于指导文档的渲染。每个属性都有一个名称（例如，'color'、'font' 或 'border'）和一个值（例如，'red'、'12pt' 或 'dotted'）。属性通过特指度、层叠和继承等机制被附加到文档的各个部分和显示文档的页面上（见 "属性值、层叠和继承" 章节）。

## 1.6. 媒体类型

### 1.6.1. 媒体类型介绍

样式表的一个最重要的特点是，它们规定了一个文档在不同媒体上的呈现方式：在屏幕上、在纸上、用语音合成器、用盲文设备等等。

某些 CSS 属性只为某些媒体而设计（例如，'page-break-before' 属性只适用于分页媒体）。然而，有时候，不同媒体类型的样式表可能共享一个属性，但要求该属性的值不同。例如，'font-size' 属性对屏幕和印刷媒体都有用。这两种媒体类型是不同的，以至于需要为这个共同的属性取不同的值；一个文档在电脑屏幕上通常需要一个比纸上更大的字体。因此，有必要表达一个样式表，或一个样式表的某个部分，适用于某些媒体类型。

### 1.6.2. 指定媒体独立样式表

目前有两种方法来指定样式表的媒体依赖性：

- 用@media 或@import at-rules 从样式表中指定目标媒体。

```css
@import url('fancyfonts.css') screen;
@media print {
  /* 用于打印的样式表放在这里 */
}
```

- 在文档语言中指定目标媒体。例如，在 HTML 4（[HTML4]）中，LINK 元素上的 "media" 属性指定了一个外部样式表的目标媒体。

```css
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
   <HEAD>
      <TITLE>Link to a target medium</TITLE>
      <LINK REL="stylesheet" TYPE="text/css"
	 MEDIA="print, handheld" HREF="foo.css">
   </HEAD>
   <BODY>
      <P>The body...
   </BODY>
</HTML>
```

@import 规则在关于层叠的章节中定义。

#### 1.6.2.1. @media 规则

一个@media 规则指定了一组声明（以大括号为界）的目标媒体类型（以逗号分隔），无效的语句必须被忽略。@media 结构允许在同一个样式表中为各种媒体制定样式表规则。

@media 规则之外的样式规则适用于样式表所适用的所有媒体类型。在@media 里面的规则在 CSS 2.2 中是无效的。

### 1.6.3. 识别媒体类型

为 CSS 媒体类型选择的名称反映了相关属性对其有意义的目标设备。在下面的 CSS 媒体类型列表中，媒体类型的名称是规范性的，但描述是信息性的。同样地，每个属性描述中的 "Media" 字段也是信息性的。

- all
  适用于所有设备。

- braille
  适用于盲文触觉反馈设备。

- embossed
  打算用于分页盲文打印机。

- handheld
  适用于手持设备（通常是小屏幕，带宽有限）。

- print
  适用于分页材料和在屏幕上以打印预览模式查看的文件。

- projection
  适用于投影演示，例如投影仪。请查阅关于分页媒体的部分，了解分页媒体特有的格式问题。

- screen
  主要用于彩色计算机屏幕。

- speech
  适用于语音合成器。注意：CSS2 有一个类似的媒体类型，称为 "aural"，用于这一目的。

- tty
  用于使用固定间距字符网格的媒体（如电话机、终端或显示能力有限的便携式设备）。作者不应使用 "tty "媒体类型的像素单位。

- tv
  用于电视类型的设备（低分辨率、彩色、有限的可滚动屏幕，有声音）。
  媒体类型名称是不区分大小写的。

媒体类型是相互排斥的，即一个用户代理在渲染一个文件时只能支持一种媒体类型。然而，用户代理可以在不同的画布上使用不同的媒体类型。例如，一个文件可以（同时）在一个画布上以 "screen" 模式显示，在另一个画布上以 "print" 模式显示。

请注意，一个多模态媒体类型仍然只是一个媒体类型。例如，"tv" 媒体类型是一种多模态媒体类型，它在视觉和听觉上都呈现在一个画布上。

带有未知媒体类型（但仍是有效的标识符）的@media 和@import 规则被视为不存在未知媒体类型。如果一个@media/@import 规则包含一个错误的媒体类型（不是一个标识符），那么这个声明是无效的。

注意：媒体查询忽略了这种错误处理。

例如，在下面的片段中，P 元素上的规则适用于 "print" 模式（即使 "3D" 媒体类型不详）。

```css
@media screen, 3d {
  P {
    color: green;
  }
}
```

注意。未来的 CSS 更新可能会扩展媒体类型的列表。作者不应该依赖那些尚未被 CSS 规范定义的媒体类型名称。

#### 1.6.3.1. 媒体组

本节是信息性的，不是规范性的。

每个 CSS 属性定义都指定了该属性适用于哪些媒体类型。由于属性通常适用于几种媒体类型，每个属性定义的 "适用媒体" 部分列出了媒体组而不是单个媒体类型。每个属性都适用于其定义中所列媒体组中的所有媒体类型。

CSS 2.2 定义了以下媒体组。

- **连续** 或 **分页**。
- **视觉**、**音频**、**语音** 或 **触觉**。
- **网格**（用于字符网格设备），或 **位图**。
- **交互的**（用于允许用户交互的设备），或 **静态的**（用于不允许交互的设备）。
- **所有**（包括所有媒体类型）

下表显示了媒体组和媒体类型之间的关系。

| 媒体类型   | 连续/分页 | 视觉/音频/语音/触觉 | 网格/位图 | 交互的/静态的 |
| ---------- | --------- | ------------------- | --------- | ------------- |
| braille    | 连续      | 触觉                | 网格      | 都是          |
| embossed   | 分页      | 触觉                | 网格      | 静态          |
| handheld   | 都是      | 视觉，音频，语音    | 都是      | 都是          |
| print      | 分页      | 视觉                | 位图      | 静态          |
| projection | 分页      | 视觉                | 位图      | 交互          |
| screen     | 连续      | 视觉、音频          | 位图      | 都是          |
| speech     | 连续      | 语音                | N/A       | 都是          |
| tty        | 连续      | 视觉                | 网格      | 都是          |
| tv         | 都是      | 视觉，音频          | 位图      | 都是          |
