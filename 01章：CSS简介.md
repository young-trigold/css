**目录：**

- [1. CSS 简介](#1-css-简介)
  - [1.1. CSS 历史](#11-css-历史)
  - [1.2. HTML 元素](#12-html-元素)
    - [1.2.1. 可替换性](#121-可替换性)
    - [1.2.2. 显示类型](#122-显示类型)
  - [1.3. 引入 CSS](#13-引入-css)
    - [1.3.1. 外部样式表](#131-外部样式表)
    - [1.3.2. 内部样式表](#132-内部样式表)
    - [1.3.3. 行内样式](#133-行内样式)
  - [1.4. CSS 处理模型](#14-css-处理模型)
  - [1.5. 样式表](#15-样式表)
    - [1.5.1. 样式规则](#151-样式规则)
    - [1.5.2. 厂商前缀](#152-厂商前缀)
    - [1.5.3. 空白](#153-空白)
    - [1.5.4. 注释](#154-注释)

# 1. CSS 简介

**层叠样式表(Cascading Style Sheet, CSS)** 是一个强大的工具，能影响一个或一组文档的表现。CSS 几乎触及 Web 的每个角落，甚至很多非 Web 环境也能见到它的身影。

## 1.1. CSS 历史

1994 年，正值 Web 开始广泛流行开来，CSS 的第一个提案发布了。那时，浏览器为用户提供了各种各样的定制功能。例如，用户在 Mosaic 的表现偏好设置中可以为单个元素设定字体族，字号和颜色。而文档的编写人员却做不到这一点，文档编写人员只能把内容标记称一个个段落，标题，预格式文本，或者一些其他类型的元素。如果用户愿意，可以把以及标题设为粉红色的小字，而把六级标题设为红色的大字。

CSS 就是在这样的背景下诞生的。它的目标是提供一个简单的声明式样式语言，而且具有一定的灵活性，能为文档编写人员和用户提供等同的样式化功能。层叠样式表中的“层叠”是指样式表可以结合起来使用，而且具有优先级，文档编写人员和用户都有话语权，不过最终的决策权在用户手中。

草案制定的速度很快，到 1996 年末，CSS1 完成了。此后，刚组建的 CSS 工作组开始着手制定 CSS2，而各个浏览器则相互协作，努力实现 CSS1。单独来看，CSS 的每一部分都很简单，但把各部分放在一起就变得已成复杂。而且早期的实现有些先天不足。例如，不同浏览器对盒模型(Box Model)的实现差异尤其为人诟病。这些问题直接影响到 CSS 的名声，幸好一些聪明人提出了变通方法，让浏览器的行为保持了一致。得益于一致性的提高和高调的开发活动，几年之间，CSS 逐渐开始流行。

不过，在此之前，CSS2 规范于 1998 年初定案。随后，CSS 工作组立即投身 CSS3 的制定工作，以及 CSS2 的修订工作。与以往不同的是，CSS3 有多个模块构成，而不是单独一个臃肿的规范。XHTML 规范受此启发，也采用了模块机制。

CSS3 分成多个模块的根本原因是各模块可以独立演进，尤其是模块可以按照 W3C 的规划向前推进，而不必受其他模块拖累。事实证明，这样做是对的。截至 2012 年初，有 3 个 CSS3 模块(CSS Color Level 3，CSS Namespace，Selectors Level 3) 变成了推荐状态，而有 7 个模块处于候选状态，还有 7 个模块处在不同的草案状态。如果采用以前的机制，要等到其他部分完成才能在一份完成的规范中发布颜色，选择器和命名控件的新条款。得益于模块化，我们无需等待。

但是，这样做也有缺点，CSS3 规范不能涵盖一切。即便其他模块在某一时刻到达了 Level 3，比如说 2016 年末（然而事实是没有），Selectors Level 4 也都开始制定了。那会不会有 CSS4？CSS3 那些尚未正式发布的新特性呢？还有 Grid Layout，它甚至还没到 Level 1！

可见，我们不能指着一摞厚厚的文件说，这就是 CSS3，而应该分模块学习不同的特性。模块的灵活性有时可以弥补语义不足。

了解这些历史之后，就可以开始学习 CSS 了。在此之前，我们不得不介绍一下 CSS 中的 HTML 元素。

## 1.2. HTML 元素

CSS 依赖 HTML 元素，但并非每种元素都以同样的方式创建。例如，img 和 p 是不同类型的元素。对 CSS 而言，HTML 元素分为两种：替换元素和非替换元素。

### 1.2.1. 可替换性

- 替换性元素

替换性元素(replaced element)是指用来替换元素内容的部分不是由文档内容表示的。例如，img 元素，它的内容由文档之外的图像文件替换，由文档直接表示的内容是空的：

```html
<img src="img.jpg" />
```

这个元素只包含一个属性，并没有内容。

还有 input 元素，根据类型的不同会被替换为复选框或者输入框。

- 非替换性元素

HTML 元素大部分都是非替换性的，意思就是这种元素的内容在文档中直接表示了。例如：

```html
<p>一段文本。</p>
```

这个元素在显示时，直接显示的是 "一段文本。"。

### 1.2.2. 显示类型

除了 HTML 元素的可替换性外，CSS 还把元素分为块级和行内类型，这是根据元素的 display 属性进行区分的，当然还有其他显式类型。

- 块级元素

HTML 元素大多数都是“块级”元素或行内元素。块级元素占据其父元素的整个水平空间，垂直空间等于其内容高度，因此创建了一个“块”。通常浏览器会在块级元素前后另起一个新行。

块级元素可以包含行内元素，也可以包含块级块级元素。

块级元素的 display 属性值为 block。

- 行内元素

一个行内元素只占据它对应标签的边框所包含的空间。也不会在前后另起新行。

行内元素可以包含文本和行内元素，但不能包含块级元素。

行内元素的 display 属性值为 inline。

## 1.3. 引入 CSS

在学习 CSS 之前，我们得首先在 HTML 关联 CSS，不然 CSS 就没法影响 HTML 文档。下面介绍 3 种引入 CSS 的方式。

### 1.3.1. 外部样式表

外部样式表式引入 CSS 最常用的方式。这种方式用到了 link 元素，例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>外部样式表</title>
    <link rel="stylesheet" href="style.css" media="screen" />
  </head>
  <body></body>
</html>
```

上述例子向 HTML 文档中引入了一个 style.css 外部样式表。

外部样式表中没有任何 HTML 标签。外部样式表保存为纯文本文件，文件扩展名是 .css。

- link 元素的属性

link 元素的 rel 属性表示链接资源和 HTML 文档的关系，对于 CSS 文档来说，就是“stylesheet”。

link 元素的 href 属性制定了链接资源的地址。

最后的 media 属性，它的值是一个或多个媒体描述符(media descriptor)，表示什么样的媒体应该使用这个 CSS 文档。例如：

```html
<link rel="stylesheet" href="style.css" media="screen, screen" />
```

多个媒体描述符用逗号分隔。媒体描述符本书后面会详细的介绍。

link 的 type 属性现在已经不常用了，它用来指定资源的 MIME 类型，不过对于 CSS 文档，浏览器默认为 "text/css"。

- @import

@import 指令可以出现在 CSS 文档中，它的作用是链接另外一个 CSS 文档。例如：

```css
@import url(basic.css);
```

@import 指令必需放在 CSS 规则之前，否则不会有效。

### 1.3.2. 内部样式表

另外一种引入 CSS 的方式是通过 style 元素。例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>内部样式表</title>
    <style>
      h1 {
        color: red;
      }

      h2 {
        color: maroon;
        background: black;
      }
    </style>
  </head>
  <body></body>
</html>
```

内部样式表的层叠优先级大于外部样式表。本书后面会详细讨论。

### 1.3.3. 行内样式

最后一种的方式是通过 HTML 元素的 style 全局属性。例如：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>行内样式</title>
  </head>
  <body>
    <p style="color: red;">一段文本。</p>
  </body>
</html>
```

这种方式应用的 CSS 样式层叠优先级最高。但是这种方式使用 CSS 不好管理。

## 1.4. CSS 处理模型

本节介绍了支持 CSS 的用户代理如何工作的一个可能模型。这只是一个概念性的模型；实际的实现可能会有所不同。

在这个模型中，用户代理通过以下步骤来处理一个源。

1. 解析源文档并创建一个文档树。
2. 识别目标媒体类型。
3. 检索所有与该文档相关的、为目标媒体类型指定的样式表。
4. 通过给适用于目标媒体类型的每个属性分配一个单一的值来注释文档树的每个元素。属性是根据层叠和继承一节中描述的机制来分配数值的。部分数值的计算取决于适合于目标媒体类型的格式化算法。例如，如果目标媒体是屏幕，用户代理会应用视觉格式化模型。
5. 从注释的文档树中，生成一个格式化结构。通常，格式化结构与文档树非常相似，但也可能有很大不同，特别是当作者使用伪元素和生成的内容时。首先，格式化结构根本不需要是 "树形 "的，结构的性质取决于实现。第二，格式化结构可能包含比文档树更多或更少的信息。例如，如果文档树中的一个元素的 "display "属性的值是 "none"，那么这个元素在格式化结构中就不会产生任何信息。另一方面，一个列表元素可能会在格式化结构中产生更多的信息：列表元素的内容和列表样式信息（例如，一个子弹头图像）。请注意，CSS 用户代理在这个阶段不会改变文档树。特别是，由于样式表产生的内容不会被反馈给文档语言处理器（例如，用于重新解析）。
6. 将格式化结构转移到目标媒介（例如，打印结果、在屏幕上显示、渲染成语音等）。

## 1.5. 样式表

样式表包含什么呢？其实是一系列 CSS 样式规则。例如：

```css
h1 {
  color: red;
}

h2 {
  color: maroon;
  background: black;
}
```

### 1.5.1. 样式规则

一个 CSS 样式规则有 2 个部分组成：选择器和声明块。选择器制定了声明块中样式的应用目标元素。声明块则由一个或多个样式声明组成。一个样式声明是一个键值对，包含属性和对应值。

例如：

```css
h1 {
  color: red;
  background-color: yellow;
}
```

这个例子中，h1 就是一个最简单的选择器（本书后面会介绍各种选择器），后面的声明块中包含了 2 条样式声明：color 和 backgroung-color。属性和值用冒号分开。每一条声明都要以分号结尾。

### 1.5.2. 厂商前缀

有时候，CSS 中的属性会包含厂商前缀(vendor prefix)。如：-o-border-image。带有厂商前缀的属性往往只是对应厂商的浏览器有，或者这些属性还在实验中。

下表列出了常用的厂商前缀：

| 浏览器            | 前缀     |
| ----------------- | -------- |
| Chrome, Safari    | -webkit- |
| Opera             | -o-      |
| Firefox           | -moz-    |
| Internet Explorer | -ms-     |

### 1.5.3. 空白

CSS 对 CSS 文档中的空白没有严格要求。一般来说，样式规则之间用换行符分隔。选择器和声明块之间用一个空格分隔。样式声明之间用换行符分隔，且缩进 2 个或是 4 个空格。

良好的空白有助于阅读。

### 1.5.4. 注释

CSS 支持注释。CSS 文档注释的风格和很多语言相似。

例如：

```css
/* 这是一个注释 */
h1 {
  color: red;
}
```

在解析时，注释会被浏览器忽略。

良好的注释风格有助于理解 CSS 文档。

