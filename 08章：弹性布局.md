**目录：**

- [8. 弹性布局](#8-弹性布局)
  - [8.1. 弹性盒子盒模型以及术语](#81-弹性盒子盒模型以及术语)
  - [8.2. 弹性容器](#82-弹性容器)
  - [8.3. 弹性子项](#83-弹性子项)
    - [8.3.1. 绝对定位的弹性子项](#831-绝对定位的弹性子项)
    - [8.3.2. 弹性子项的内外边距](#832-弹性子项的内外边距)
    - [8.3.3. 弹性子项 Z-轴顺序](#833-弹性子项-z-轴顺序)
    - [8.3.4. 折叠子项](#834-折叠子项)
    - [8.3.5. 弹性子项的自动最小大小](#835-弹性子项的自动最小大小)
  - [8.4. 顺序和方向](#84-顺序和方向)
    - [8.4.1. flex-direction 属性](#841-flex-direction-属性)
    - [8.4.2. flex-wrap 属性](#842-flex-wrap-属性)
    - [8.4.3. flex-flow 属性](#843-flex-flow-属性)
    - [8.4.4. order 属性](#844-order-属性)
  - [8.5. 弹性行](#85-弹性行)
  - [8.6. 弹性度](#86-弹性度)
    - [8.6.1. flex 简写属性](#861-flex-简写属性)
    - [8.6.2. flex-grow](#862-flex-grow)
    - [8.6.3. flex-shrink](#863-flex-shrink)
    - [8.6.4. flex-basis](#864-flex-basis)
  - [8.7. 排置](#87-排置)
    - [8.7.1. 自动外边距排置](#871-自动外边距排置)
    - [8.7.2. justify-content 属性](#872-justify-content-属性)
    - [8.7.3. align-items 和 align-self 属性](#873-align-items-和-align-self-属性)
    - [8.7.4. align-content 属性](#874-align-content-属性)
    - [8.7.5. 弹性容器基线](#875-弹性容器基线)
  - [8.8. 弹性布局算法](#88-弹性布局算法)

# 8. 弹性布局

CSS 2.1 定义了四种布局模式--根据盒子与同级和祖先盒子的关系来确定盒子的大小和位置的算法：

- 块布局，设计用于布置文档

- 行内布局，设计用于布局文本

- 表格布局，设计用于以表格的形式布局 2D 数据

- 定位布局，设计用于非常明确的定位，而不考虑文档中的其他元素

本模块引入了一种新的布局模式：**弹性布局**，它是为布局更复杂的应用程序和网页而设计的。

弹性布局从表面上看与块布局相似。它缺乏许多可用于块布局的更复杂的以文本或文档为中心的属性，如浮动和列。作为回报，它获得了简单而强大的工具，用于分配空间，并以网络应用和复杂网页经常需要的方式对齐内容。弹性容器的内容：

- 可以按任何流动方向布局（向左、向右、向下，甚至向上！）。

- 可以在样式层颠倒显示顺序或重新排列（即视觉顺序可以独立于源和语音顺序）。

- 可以沿单一（主）轴线性布局，或沿次要（交叉）轴包装成多个行

- 可以 "放缩" 它们的尺寸以应对可用的空间

- 可以相对于它们的容器或彼此在副轴（交叉轴）上对齐

- 可以沿主轴动态地折叠或松开，同时保留容器的交叉尺寸

## 8.1. 弹性盒子盒模型以及术语

**弹性容器** 是由一个 display 计算为 flex 或 inline-flex 的元素生成的盒子。弹性容器的流内子项被称为 **弹性子项**，并使用弹性布局模型进行布局。

与块和行内布局不同，其布局计算偏向于块和行流内动方向，而弹性布局则偏向于 **弹性方向**。为了更容易地谈论弹性布局，本节定义了一组与弹性流相关的术语。Flex-flow 值和书写模式决定了这些术语如何映射到物理方向（上/右/下/左）、轴（垂直/水平）和尺寸（宽/高）。

![弹性方向术语](illustrations/flex-direction-terms.svg)

- **主轴/主尺寸**
  弹性容器的 **主轴** 是布置弹性子项的主要轴线。它在 **主尺寸** 上延伸。
- **主起点/主终点**
  弹性子项被放置在容器内，从主起点一侧开始，向主终点一侧前进。
- **主大小/主大小属性**
  弹性容器或弹性子项的宽度或高度（以主尺寸为准）是该盒子的主尺寸。因此，它的主大小属性是它的宽度或高度属性，无论哪一个在主尺寸中。同样，它的最小和最大主尺寸属性是它的最小宽度/最大宽度或最小高度/最大高度属性，以在主尺寸上为准，并确定其最小/最大主尺寸。
- **交叉轴/交叉尺寸**
  垂直于主轴的轴称为十字轴。它在交叉尺寸中延伸。
- **交叉起点/交叉终点**
  弹性线装满物品，从弹性容器的交叉起点一侧开始，向交叉终点一侧放入容器中。
- **交叉大小/交叉大小属性**
  一个弹性容器或弹性子项的宽度或高度，无论哪一个在交叉尺寸中，都是该盒子的交叉尺寸。因此，它的交叉尺寸属性是它的宽度或高度属性，无论哪一个在交叉尺寸中。同样，它的最小和最大交叉尺寸属性是它的最小宽度/最大宽度或最小高度/最大高度属性，以在交叉维度中的哪个为准，并确定其最小/最大交叉尺寸。

本规范中使用的其他尺寸术语在 CSS 内在和外在尺寸中定义。[CSS-SIZING-3]

## 8.2. 弹性容器

| 属性名     | display |
| ---------- | ------- | ------------ |
| 新的属性值 | `flex   | inline-flex` |

- **flex**
  这个值会使一个元素产生一个弹性容器，当放置在流布局中时是块级的。
- **inline-flex**
  此值使元素在流布局中产生一个弹性容器，它是行内级的。

一个弹性容器为其内容建立一个新的弹性格式化上下文。这与建立一个块格式化上下文是一样的，只是使用的是弹性布局而不是块布局。例如，浮动盒子不会侵入弹性容器，弹性容器的外边距不会随其内容的外边距折叠。弹性容器为其内容形成一个包含块，就像块容器一样。[CSS21] 'overflow' 属性适用于弹性容器。

弹性容器不是块容器，因此，一些以块布局为假设而设计的属性并不适用于弹性布局。特别是：

- float 和 clear 不会创建浮动或清除弹性项目，也不会使其脱离流。

- vertical-align 对 flex item 没有影响。

- ::first-line 和 ::first-letter 伪元素不适用于弹性容器，并且弹性容器不会为其祖先提供第一个格式化的行或第一个字母。

如果一个元素的指定显示方式是 inline-flex，那么它的显示属性在某些情况下会计算为 flex：CSS 2.1 第 9.7 节中的表格被修改为包含一个额外的行，inline-flex 在 "指定值" 列，flex 在 "计算值 "列。

## 8.3. 弹性子项

宽泛地讲，一个弹性容器的弹性项子是代表其流内内容的盒子。

弹性容器的每个流内子项都成为一个弹性子项，而每个连续的子文本运行序列都被包裹在一个匿名的块容器弹性子项中。然而，如果整个子文本运行序列只包含空白（即可以被 white-space 属性影响的字符），它反而不会被渲染（就像它的文本节点是 display:none 一样）。

### 8.3.1. 绝对定位的弹性子项

### 8.3.2. 弹性子项的内外边距

### 8.3.3. 弹性子项 Z-轴顺序

### 8.3.4. 折叠子项

### 8.3.5. 弹性子项的自动最小大小

## 8.4. 顺序和方向

### 8.4.1. flex-direction 属性

### 8.4.2. flex-wrap 属性

### 8.4.3. flex-flow 属性

### 8.4.4. order 属性

## 8.5. 弹性行

## 8.6. 弹性度

### 8.6.1. flex 简写属性

### 8.6.2. flex-grow

### 8.6.3. flex-shrink

### 8.6.4. flex-basis

## 8.7. 排置

### 8.7.1. 自动外边距排置

### 8.7.2. justify-content 属性

### 8.7.3. align-items 和 align-self 属性

### 8.7.4. align-content 属性

### 8.7.5. 弹性容器基线

## 8.8. 弹性布局算法
